<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>DynamoRIO API: Container Data Structures</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
<link rel="shortcut icon" type="image/x-icon" href="favicon.ico" />
</head><body>
<!-- Generated by Doxygen 1.6.3 -->
<div class="contents">
<h1>Container Data Structures</h1><table border="0" cellpadding="0" cellspacing="0">
<tr><td colspan="2"><h2>Data Structures</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct__hashtable__config__t.html">_hashtable_config_t</a></td></tr>
<tr><td colspan="2"><h2>Typedefs</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="struct__hashtable__config__t.html">_hashtable_config_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__drcontainers.html#ga9caff1942d844cffe52c953d448c2e6c">hashtable_config_t</a></td></tr>
<tr><td colspan="2"><h2>Enumerations</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__drcontainers.html#ga2cde78f27c3374749c462a5d58a5e38e">hash_type_t</a> { <br/>
&nbsp;&nbsp;<a class="el" href="group__drcontainers.html#gga2cde78f27c3374749c462a5d58a5e38ea7e83c8ad190fd19419c301ace3bcbe2e">HASH_INTPTR</a>, 
<br/>
&nbsp;&nbsp;<a class="el" href="group__drcontainers.html#gga2cde78f27c3374749c462a5d58a5e38ea3a57810af6552f1efcda7a6abddbe92a">HASH_STRING</a>, 
<br/>
&nbsp;&nbsp;<a class="el" href="group__drcontainers.html#gga2cde78f27c3374749c462a5d58a5e38eae0b0e4c68e2bab129d1d2a6ff43d44d4">HASH_STRING_NOCASE</a>, 
<br/>
&nbsp;&nbsp;<a class="el" href="group__drcontainers.html#gga2cde78f27c3374749c462a5d58a5e38eaa90b8cffea02e8d64d001982ddb0c310">HASH_CUSTOM</a>
<br/>
 }</td></tr>
<tr><td colspan="2"><h2>Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__drcontainers.html#gae5206874469dc2551dad9e8f375e87df">drvector_init</a> (drvector_t *vec, uint initial_capacity, bool synch, void(*free_data_func)(void *))</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__drcontainers.html#gaa578776ea720fb04c87ac04181d89f4e">drvector_get_entry</a> (drvector_t *vec, uint idx)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__drcontainers.html#ga380b542d2b8b997ded501df7f54b6919">drvector_append</a> (drvector_t *vec, void *data)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__drcontainers.html#ga2e5949b592508c61e35ec14bfa731d62">drvector_delete</a> (drvector_t *vec)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__drcontainers.html#gacf1b3d3080e42bc98cddc75d675cd786">drvector_lock</a> (drvector_t *vec)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__drcontainers.html#ga752060ab72ce4d597fed7684332bba5b">drvector_unlock</a> (drvector_t *vec)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__drcontainers.html#gab341e9839c6cbd89a5a442df73468f5f">stri_eq</a> (const char *s1, const char *s2)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__drcontainers.html#gaf202d20209b04c9ea9fd0657f3cfccc6">hashtable_global_config</a> (void *(*alloc_func)(size_t), void(*free_func)(void *, size_t), void(*assert_fail_func)(const char *))</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__drcontainers.html#ga96d69f3a60f5ba9c75698649465be695">hashtable_init</a> (hashtable_t *table, uint num_bits, <a class="el" href="group__drcontainers.html#ga2cde78f27c3374749c462a5d58a5e38e">hash_type_t</a> hashtype, bool str_dup)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__drcontainers.html#ga307d17165381371418414308b3eed803">hashtable_init_ex</a> (hashtable_t *table, uint num_bits, <a class="el" href="group__drcontainers.html#ga2cde78f27c3374749c462a5d58a5e38e">hash_type_t</a> hashtype, bool str_dup, bool synch, void(*free_payload_func)(void *), uint(*hash_key_func)(void *), bool(*cmp_key_func)(void *, void *))</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__drcontainers.html#ga2e9225a8b532a579db4f193b2a236686">hashtable_configure</a> (hashtable_t *table, <a class="el" href="struct__hashtable__config__t.html">hashtable_config_t</a> *config)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__drcontainers.html#gaa6af018f2bb18648861e76bc0fdec96e">hashtable_lookup</a> (hashtable_t *table, void *key)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__drcontainers.html#ga42cb0b8a85c6b4cdba6ee7b984aeff25">hashtable_add</a> (hashtable_t *table, void *key, void *payload)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__drcontainers.html#ga3d443ee70d3fd35d853b9697f999cbf7">hashtable_add_replace</a> (hashtable_t *table, void *key, void *payload)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__drcontainers.html#ga8972b42e34447e229489ab120271dbfd">hashtable_remove</a> (hashtable_t *table, void *key)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__drcontainers.html#ga4a9699afdfaab140f2e98b7783a51b19">hashtable_remove_range</a> (hashtable_t *table, void *start, void *end)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__drcontainers.html#ga2bcb10d265f6005bbcef89129ad58548">hashtable_clear</a> (hashtable_t *table)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__drcontainers.html#ga9e402d49c64df6809c82483a8ddd6770">hashtable_delete</a> (hashtable_t *table)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__drcontainers.html#ga98ba198cad4e146607e8a07db005b514">hashtable_lock</a> (hashtable_t *table)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__drcontainers.html#ga8d7f9e88180c79d080113e2bec858dbf">hashtable_unlock</a> (hashtable_t *table)</td></tr>
</table>
<hr/><h2>Typedef Documentation</h2>
<a class="anchor" id="ga9caff1942d844cffe52c953d448c2e6c"></a><!-- doxytag: member="hashtable.h::hashtable_config_t" ref="ga9caff1942d844cffe52c953d448c2e6c" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="struct__hashtable__config__t.html">_hashtable_config_t</a>  <a class="el" href="struct__hashtable__config__t.html">hashtable_config_t</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Configuration parameters for a hashtable. </p>

</div>
</div>
<hr/><h2>Enumeration Type Documentation</h2>
<a class="anchor" id="ga2cde78f27c3374749c462a5d58a5e38e"></a><!-- doxytag: member="hashtable.h::hash_type_t" ref="ga2cde78f27c3374749c462a5d58a5e38e" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__drcontainers.html#ga2cde78f27c3374749c462a5d58a5e38e">hash_type_t</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>The type of hash key </p>
<dl><dt><b>Enumerator: </b></dt><dd><table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" id="gga2cde78f27c3374749c462a5d58a5e38ea7e83c8ad190fd19419c301ace3bcbe2e"></a><!-- doxytag: member="HASH_INTPTR" ref="gga2cde78f27c3374749c462a5d58a5e38ea7e83c8ad190fd19419c301ace3bcbe2e" args="" -->HASH_INTPTR</em>&nbsp;</td><td>
<p>A pointer-sized integer or pointer </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="gga2cde78f27c3374749c462a5d58a5e38ea3a57810af6552f1efcda7a6abddbe92a"></a><!-- doxytag: member="HASH_STRING" ref="gga2cde78f27c3374749c462a5d58a5e38ea3a57810af6552f1efcda7a6abddbe92a" args="" -->HASH_STRING</em>&nbsp;</td><td>
<p>A case-sensitive string </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="gga2cde78f27c3374749c462a5d58a5e38eae0b0e4c68e2bab129d1d2a6ff43d44d4"></a><!-- doxytag: member="HASH_STRING_NOCASE" ref="gga2cde78f27c3374749c462a5d58a5e38eae0b0e4c68e2bab129d1d2a6ff43d44d4" args="" -->HASH_STRING_NOCASE</em>&nbsp;</td><td>
<p>A case-insensitive string </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="gga2cde78f27c3374749c462a5d58a5e38eaa90b8cffea02e8d64d001982ddb0c310"></a><!-- doxytag: member="HASH_CUSTOM" ref="gga2cde78f27c3374749c462a5d58a5e38eaa90b8cffea02e8d64d001982ddb0c310" args="" -->HASH_CUSTOM</em>&nbsp;</td><td>
<p>A custom key. Hash and compare operations must be provided in <a class="el" href="group__drcontainers.html#ga307d17165381371418414308b3eed803">hashtable_init_ex()</a>. The hash operation can return a full uint, as its result will be truncated via a mod of the hash key bit size. This allows for resizing the table without changing the hash operation. </p>
</td></tr>
</table>
</dd>
</dl>

</div>
</div>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="ga380b542d2b8b997ded501df7f54b6919"></a><!-- doxytag: member="drvector.h::drvector_append" ref="ga380b542d2b8b997ded501df7f54b6919" args="(drvector_t *vec, void *data)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool drvector_append </td>
          <td>(</td>
          <td class="paramtype">drvector_t *&nbsp;</td>
          <td class="paramname"> <em>vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>data</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Adds a new entry to the end of the vector, resizing it if necessary. </p>

</div>
</div>
<a class="anchor" id="ga2e5949b592508c61e35ec14bfa731d62"></a><!-- doxytag: member="drvector.h::drvector_delete" ref="ga2e5949b592508c61e35ec14bfa731d62" args="(drvector_t *vec)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool drvector_delete </td>
          <td>(</td>
          <td class="paramtype">drvector_t *&nbsp;</td>
          <td class="paramname"> <em>vec</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Destroys all storage for the vector. If free_payload_func was specified calls it for each payload. </p>

</div>
</div>
<a class="anchor" id="gaa578776ea720fb04c87ac04181d89f4e"></a><!-- doxytag: member="drvector.h::drvector_get_entry" ref="gaa578776ea720fb04c87ac04181d89f4e" args="(drvector_t *vec, uint idx)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* drvector_get_entry </td>
          <td>(</td>
          <td class="paramtype">drvector_t *&nbsp;</td>
          <td class="paramname"> <em>vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&nbsp;</td>
          <td class="paramname"> <em>idx</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Returns the entry at index <code>idx</code>. For an unsychronized table, the caller is free to directly access the <code>array</code> field of <code>vec</code>. </p>

</div>
</div>
<a class="anchor" id="gae5206874469dc2551dad9e8f375e87df"></a><!-- doxytag: member="drvector.h::drvector_init" ref="gae5206874469dc2551dad9e8f375e87df" args="(drvector_t *vec, uint initial_capacity, bool synch, void(*free_data_func)(void *))" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool drvector_init </td>
          <td>(</td>
          <td class="paramtype">drvector_t *&nbsp;</td>
          <td class="paramname"> <em>vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&nbsp;</td>
          <td class="paramname"> <em>initial_capacity</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>synch</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(*)(void *)&nbsp;</td>
          <td class="paramname"> <em>free_data_func</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Initializes a drvector with the given parameters</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>vec</em>&nbsp;</td><td>The vector to be initialized. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>initial_capacity</em>&nbsp;</td><td>The initial number of entries allocated for the vector. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>synch</em>&nbsp;</td><td>Whether to synchronize each operation. Even when <code>synch</code> is false, the vector's lock is initialized and can be used via vector_lock() and vector_unlock(), allowing the caller to extend synchronization beyond just the operation in question, to include accessing a looked-up payload, e.g. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>free_data_func</em>&nbsp;</td><td>A callback for freeing each data item. Leave it NULL if no callback is needed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gacf1b3d3080e42bc98cddc75d675cd786"></a><!-- doxytag: member="drvector.h::drvector_lock" ref="gacf1b3d3080e42bc98cddc75d675cd786" args="(drvector_t *vec)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void drvector_lock </td>
          <td>(</td>
          <td class="paramtype">drvector_t *&nbsp;</td>
          <td class="paramname"> <em>vec</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Acquires the vector lock. </p>

</div>
</div>
<a class="anchor" id="ga752060ab72ce4d597fed7684332bba5b"></a><!-- doxytag: member="drvector.h::drvector_unlock" ref="ga752060ab72ce4d597fed7684332bba5b" args="(drvector_t *vec)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void drvector_unlock </td>
          <td>(</td>
          <td class="paramtype">drvector_t *&nbsp;</td>
          <td class="paramname"> <em>vec</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Releases the vector lock. </p>

</div>
</div>
<a class="anchor" id="ga42cb0b8a85c6b4cdba6ee7b984aeff25"></a><!-- doxytag: member="hashtable.h::hashtable_add" ref="ga42cb0b8a85c6b4cdba6ee7b984aeff25" args="(hashtable_t *table, void *key, void *payload)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool hashtable_add </td>
          <td>(</td>
          <td class="paramtype">hashtable_t *&nbsp;</td>
          <td class="paramname"> <em>table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>payload</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Adds a new entry. Returns false if an entry for <code>key</code> already exists. </p>
<dl class="note"><dt><b>Note:</b></dt><dd>Never use NULL as a payload as that is used for a lookup failure. </dd></dl>

</div>
</div>
<a class="anchor" id="ga3d443ee70d3fd35d853b9697f999cbf7"></a><!-- doxytag: member="hashtable.h::hashtable_add_replace" ref="ga3d443ee70d3fd35d853b9697f999cbf7" args="(hashtable_t *table, void *key, void *payload)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* hashtable_add_replace </td>
          <td>(</td>
          <td class="paramtype">hashtable_t *&nbsp;</td>
          <td class="paramname"> <em>table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>payload</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Adds a new entry, replacing an existing entry if any. </p>
<dl class="note"><dt><b>Note:</b></dt><dd>Never use NULL as a payload as that is used for a lookup failure. </dd></dl>

</div>
</div>
<a class="anchor" id="ga2bcb10d265f6005bbcef89129ad58548"></a><!-- doxytag: member="hashtable.h::hashtable_clear" ref="ga2bcb10d265f6005bbcef89129ad58548" args="(hashtable_t *table)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void hashtable_clear </td>
          <td>(</td>
          <td class="paramtype">hashtable_t *&nbsp;</td>
          <td class="paramname"> <em>table</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Removes all entries from the table. If free_payload_func was specified calls it for each payload. </p>

</div>
</div>
<a class="anchor" id="ga2e9225a8b532a579db4f193b2a236686"></a><!-- doxytag: member="hashtable.h::hashtable_configure" ref="ga2e9225a8b532a579db4f193b2a236686" args="(hashtable_t *table, hashtable_config_t *config)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void hashtable_configure </td>
          <td>(</td>
          <td class="paramtype">hashtable_t *&nbsp;</td>
          <td class="paramname"> <em>table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct__hashtable__config__t.html">hashtable_config_t</a> *&nbsp;</td>
          <td class="paramname"> <em>config</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Configures optional parameters of hashtable operation. </p>

</div>
</div>
<a class="anchor" id="ga9e402d49c64df6809c82483a8ddd6770"></a><!-- doxytag: member="hashtable.h::hashtable_delete" ref="ga9e402d49c64df6809c82483a8ddd6770" args="(hashtable_t *table)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void hashtable_delete </td>
          <td>(</td>
          <td class="paramtype">hashtable_t *&nbsp;</td>
          <td class="paramname"> <em>table</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Destroys all storage for the table, including all entries and the table itself. If free_payload_func was specified calls it for each payload. </p>

</div>
</div>
<a class="anchor" id="gaf202d20209b04c9ea9fd0657f3cfccc6"></a><!-- doxytag: member="hashtable.h::hashtable_global_config" ref="gaf202d20209b04c9ea9fd0657f3cfccc6" args="(void *(*alloc_func)(size_t), void(*free_func)(void *, size_t), void(*assert_fail_func)(const char *))" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void hashtable_global_config </td>
          <td>(</td>
          <td class="paramtype">void *(*)(size_t)&nbsp;</td>
          <td class="paramname"> <em>alloc_func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(*)(void *, size_t)&nbsp;</td>
          <td class="paramname"> <em>free_func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(*)(const char *)&nbsp;</td>
          <td class="paramname"> <em>assert_fail_func</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>The hashtable has parametrized heap and assert routines for flexibility. This routine must be called BEFORE any other hashtable_ routine; else, the defaults will be used. </p>

</div>
</div>
<a class="anchor" id="ga96d69f3a60f5ba9c75698649465be695"></a><!-- doxytag: member="hashtable.h::hashtable_init" ref="ga96d69f3a60f5ba9c75698649465be695" args="(hashtable_t *table, uint num_bits, hash_type_t hashtype, bool str_dup)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void hashtable_init </td>
          <td>(</td>
          <td class="paramtype">hashtable_t *&nbsp;</td>
          <td class="paramname"> <em>table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&nbsp;</td>
          <td class="paramname"> <em>num_bits</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__drcontainers.html#ga2cde78f27c3374749c462a5d58a5e38e">hash_type_t</a>&nbsp;</td>
          <td class="paramname"> <em>hashtype</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>str_dup</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Initializes a hashtable with the given size, hash type, and whether to duplicate string keys. All operations are synchronized by default. </p>

</div>
</div>
<a class="anchor" id="ga307d17165381371418414308b3eed803"></a><!-- doxytag: member="hashtable.h::hashtable_init_ex" ref="ga307d17165381371418414308b3eed803" args="(hashtable_t *table, uint num_bits, hash_type_t hashtype, bool str_dup, bool synch, void(*free_payload_func)(void *), uint(*hash_key_func)(void *), bool(*cmp_key_func)(void *, void *))" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void hashtable_init_ex </td>
          <td>(</td>
          <td class="paramtype">hashtable_t *&nbsp;</td>
          <td class="paramname"> <em>table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&nbsp;</td>
          <td class="paramname"> <em>num_bits</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__drcontainers.html#ga2cde78f27c3374749c462a5d58a5e38e">hash_type_t</a>&nbsp;</td>
          <td class="paramname"> <em>hashtype</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>str_dup</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>synch</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(*)(void *)&nbsp;</td>
          <td class="paramname"> <em>free_payload_func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint(*)(void *)&nbsp;</td>
          <td class="paramname"> <em>hash_key_func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool(*)(void *, void *)&nbsp;</td>
          <td class="paramname"> <em>cmp_key_func</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Initializes a hashtable with the given parameters.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>table</em>&nbsp;</td><td>The hashtable to be initialized. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>num_bits</em>&nbsp;</td><td>The initial number of bits to use for the hash key which determines the initial size of the table itself. The result of the hash function will be truncated to this size. This size will be increased when the table is resized (resizing always doubles the size). </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>hashtype</em>&nbsp;</td><td>The type of hash to perform. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>str_dup</em>&nbsp;</td><td>Whether to duplicate string keys. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>synch</em>&nbsp;</td><td>Whether to synchronize each operation. Even when <code>synch</code> is false, the hashtable's lock is initialized and can be used via <a class="el" href="group__drcontainers.html#ga98ba198cad4e146607e8a07db005b514">hashtable_lock()</a> and <a class="el" href="group__drcontainers.html#ga8d7f9e88180c79d080113e2bec858dbf">hashtable_unlock()</a>, allowing the caller to extend synchronization beyond just the operation in question, to include accessing a looked-up payload, e.g. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>free_payload_func</em>&nbsp;</td><td>A callback for freeing each payload. Leave it NULL if no callback is needed. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>hash_key_func</em>&nbsp;</td><td>A callback for hashing a key. Leave it NULL if no callback is needed and the default is to be used. For HASH_CUSTOM, a callback must be provided. The hash operation can return a full uint, as its result will be truncated via a mod of the hash key bit size. This allows for resizing the table without changing the hash operation. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>cmp_key_func</em>&nbsp;</td><td>A callback for comparing two keys. Leave it NULL if no callback is needed and the default is to be used. For HASH_CUSTOM, a callback must be provided. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga98ba198cad4e146607e8a07db005b514"></a><!-- doxytag: member="hashtable.h::hashtable_lock" ref="ga98ba198cad4e146607e8a07db005b514" args="(hashtable_t *table)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void hashtable_lock </td>
          <td>(</td>
          <td class="paramtype">hashtable_t *&nbsp;</td>
          <td class="paramname"> <em>table</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Acquires the hashtable lock. </p>

</div>
</div>
<a class="anchor" id="gaa6af018f2bb18648861e76bc0fdec96e"></a><!-- doxytag: member="hashtable.h::hashtable_lookup" ref="gaa6af018f2bb18648861e76bc0fdec96e" args="(hashtable_t *table, void *key)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* hashtable_lookup </td>
          <td>(</td>
          <td class="paramtype">hashtable_t *&nbsp;</td>
          <td class="paramname"> <em>table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>key</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Returns the payload for the given key, or NULL if the key is not found </p>

</div>
</div>
<a class="anchor" id="ga8972b42e34447e229489ab120271dbfd"></a><!-- doxytag: member="hashtable.h::hashtable_remove" ref="ga8972b42e34447e229489ab120271dbfd" args="(hashtable_t *table, void *key)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool hashtable_remove </td>
          <td>(</td>
          <td class="paramtype">hashtable_t *&nbsp;</td>
          <td class="paramname"> <em>table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>key</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Removes the entry for key. If free_payload_func was specified calls it for the payload being removed. Returns false if no such entry exists. </p>

</div>
</div>
<a class="anchor" id="ga4a9699afdfaab140f2e98b7783a51b19"></a><!-- doxytag: member="hashtable.h::hashtable_remove_range" ref="ga4a9699afdfaab140f2e98b7783a51b19" args="(hashtable_t *table, void *start, void *end)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool hashtable_remove_range </td>
          <td>(</td>
          <td class="paramtype">hashtable_t *&nbsp;</td>
          <td class="paramname"> <em>table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>end</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Removes all entries with key in [start..end). If free_payload_func was specified calls it for each payload being removed. Returns false if no such entry exists. </p>

</div>
</div>
<a class="anchor" id="ga8d7f9e88180c79d080113e2bec858dbf"></a><!-- doxytag: member="hashtable.h::hashtable_unlock" ref="ga8d7f9e88180c79d080113e2bec858dbf" args="(hashtable_t *table)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void hashtable_unlock </td>
          <td>(</td>
          <td class="paramtype">hashtable_t *&nbsp;</td>
          <td class="paramname"> <em>table</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Releases the hashtable lock. </p>

</div>
</div>
<a class="anchor" id="gab341e9839c6cbd89a5a442df73468f5f"></a><!-- doxytag: member="hashtable.h::stri_eq" ref="gab341e9839c6cbd89a5a442df73468f5f" args="(const char *s1, const char *s2)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool stri_eq </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>s1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>s2</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Caseless string compare </p>

</div>
</div>
</div>
<hr size="1"><address style="text-align: center;"><small>
<img border=0 src="favicon.png"> &nbsp; DynamoRIO API version 3.2.0 --- Wed Mar 28 12:55:33 2012 
&nbsp; <img border=0 src="favicon.png">
</body>
</html>
