<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>DynamoRIO API: dr_tools.h File Reference</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
<link rel="shortcut icon" type="image/x-icon" href="favicon.ico" />
</head><body>
<!-- Generated by Doxygen 1.6.3 -->
<div class="contents">
<h1>dr_tools.h File Reference</h1>
<p>Main API routines, including transparency support.  
<a href="#_details">More...</a></p>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td colspan="2"><h2>Data Structures</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct__dr__mem__info__t.html">_dr_mem_info_t</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">union &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="union__version__number__t.html">_version_number_t</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct__module__names__t.html">_module_names_t</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct__dr__os__version__info__t.html">_dr_os_version_info_t</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct__module__segment__data__t.html">_module_segment_data_t</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct__module__data__t.html">_module_data_t</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct__dr__export__info__t.html">_dr_export_info_t</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct__tracedump__file__header__t.html">_tracedump_file_header_t</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct__tracedump__trace__header__t.html">_tracedump_trace_header_t</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct__tracedump__stub__data.html">_tracedump_stub_data</a></td></tr>
<tr><td colspan="2"><h2>Defines</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#ac2c501052e751bc9c72c622b1ca8b96c">DR_MEMPROT_NONE</a>&nbsp;&nbsp;&nbsp;0x00</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#ab430d92dd0d6338ec3e42b527ae91efb">DR_MEMPROT_READ</a>&nbsp;&nbsp;&nbsp;0x01</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#a1dafb99a4933112c603189bc091fa752">DR_MEMPROT_WRITE</a>&nbsp;&nbsp;&nbsp;0x02</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#ad98be75b6fde3dc1dbfb8bfda59fce66">DR_MEMPROT_EXEC</a>&nbsp;&nbsp;&nbsp;0x04</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#a4e6bdc93e35ee5a9f081564a162ec3b9">GLOBAL_DCONTEXT</a>&nbsp;&nbsp;&nbsp;((void *)-1)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#abd6d066ab9bdd578d4000e80df8503bc">DR_ASSERT_MSG</a>(x, msg)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#a7c07630dffdfd92bc6ee63abf405768c">DR_ASSERT</a>(x)&nbsp;&nbsp;&nbsp;DR_ASSERT_MSG(x, &quot;&quot;)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#adb9ba447c606e5e58400ac7b6ef719d1">DR_TRY_EXCEPT</a>(drcontext, try_statement, except_statement)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#ad0772bc47090cec1a333baf1259f226d">DR_FILE_READ</a>&nbsp;&nbsp;&nbsp;0x1</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#a11f713faf2e1eac95bc26a98b67e28cc">DR_FILE_WRITE_REQUIRE_NEW</a>&nbsp;&nbsp;&nbsp;0x2</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#ac989ab040f48c4c91cc3a6ea63f9ec1f">DR_FILE_WRITE_APPEND</a>&nbsp;&nbsp;&nbsp;0x4</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#a5fb30eb2b5d14486b3ecbc2b2457dfdb">DR_FILE_WRITE_OVERWRITE</a>&nbsp;&nbsp;&nbsp;0x8</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#a77a3b276c8d9a62bf6d78c3707d4effd">DR_FILE_ALLOW_LARGE</a>&nbsp;&nbsp;&nbsp;0x10</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#a0401a3003f578602bf31a984a4d5419d">DR_FILE_CLOSE_ON_FORK</a>&nbsp;&nbsp;&nbsp;0x20</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#aa675a6270b664511299295ebc1f5562e">DR_SEEK_SET</a>&nbsp;&nbsp;&nbsp;0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#ad31bd52878d2454d8263d0951cfd1ca0">DR_SEEK_CUR</a>&nbsp;&nbsp;&nbsp;1</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#a06e58c043e838f1457853329fd4344a3">DR_SEEK_END</a>&nbsp;&nbsp;&nbsp;2</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#a016c45394c5057ce6c699cae82d2ac2b">DR_MAP_PRIVATE</a>&nbsp;&nbsp;&nbsp;0x1</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#afe59b9f8bc395c1873bd9d0ebe294f22">DR_MAP_FIXED</a>&nbsp;&nbsp;&nbsp;0x2</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#a1632479322efa3952798f98177b54471">LOG_NONE</a>&nbsp;&nbsp;&nbsp;0x00000000</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#a9dd9f361c4a23133f724c84192eef8e1">LOG_STATS</a>&nbsp;&nbsp;&nbsp;0x00000001</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#a9fdb93b09477bb1b1ee08d132dd6f4dc">LOG_TOP</a>&nbsp;&nbsp;&nbsp;0x00000002</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#a9390202fe239f2ee56c097d6940d10f6">LOG_THREADS</a>&nbsp;&nbsp;&nbsp;0x00000004</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#a87ef794555c43a1988eb760835b2fa76">LOG_SYSCALLS</a>&nbsp;&nbsp;&nbsp;0x00000008</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#a5895b0ef2efc255ad93e50bc88277b6d">LOG_ASYNCH</a>&nbsp;&nbsp;&nbsp;0x00000010</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#a54bbda8cb7e78f2ea32209bab2d7201c">LOG_INTERP</a>&nbsp;&nbsp;&nbsp;0x00000020</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#a06582648acdd995a11019f726b15adda">LOG_EMIT</a>&nbsp;&nbsp;&nbsp;0x00000040</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#a438ad3561d9d8616ff702b36d0b2bb7c">LOG_LINKS</a>&nbsp;&nbsp;&nbsp;0x00000080</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#a031661fca6b5cb813db972d758caca2b">LOG_CACHE</a>&nbsp;&nbsp;&nbsp;0x00000100</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#a7c5fcb805e6a1fdfac332931888b3ef7">LOG_FRAGMENT</a>&nbsp;&nbsp;&nbsp;0x00000200</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#a9929e24db31369398fbdc52ee040b234">LOG_DISPATCH</a>&nbsp;&nbsp;&nbsp;0x00000400</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#a2575baf458eee6334f746544f91fa6cf">LOG_MONITOR</a>&nbsp;&nbsp;&nbsp;0x00000800</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#a5522e92b98898a21b7c26ba9df95f094">LOG_HEAP</a>&nbsp;&nbsp;&nbsp;0x00001000</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#a557f3a77c5d95b7cd06661245030c687">LOG_VMAREAS</a>&nbsp;&nbsp;&nbsp;0x00002000</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#a8879b800acfbbe8f2ada805be6ef5121">LOG_SYNCH</a>&nbsp;&nbsp;&nbsp;0x00004000</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#aabb9931c63f1cf95cacca6463d5a9b09">LOG_MEMSTATS</a>&nbsp;&nbsp;&nbsp;0x00008000</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#a9f746aa1ef6a208cd1cd7174a694c9e5">LOG_OPTS</a>&nbsp;&nbsp;&nbsp;0x00010000</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#a8ad7f6071c29a882af67d3a72fe4e787">LOG_SIDELINE</a>&nbsp;&nbsp;&nbsp;0x00020000</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#a65630bab8d9fcde517b3f8ecb03c6de9">LOG_SYMBOLS</a>&nbsp;&nbsp;&nbsp;0x00040000</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#a297668a84187b740ff4fe1e1d6e52eeb">LOG_RCT</a>&nbsp;&nbsp;&nbsp;0x00080000</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#a4f3856a58f1f9971ebcd62c99a448a5a">LOG_NT</a>&nbsp;&nbsp;&nbsp;0x00100000</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#a51c2bbdf11618716da67a305dd24ddde">LOG_HOT_PATCHING</a>&nbsp;&nbsp;&nbsp;0x00200000</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#a6ec73009ed3f0c2baa1d3c44033c261e">LOG_HTABLE</a>&nbsp;&nbsp;&nbsp;0x00400000</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#abba5e74dd3a5577b7af5177960ecb9dd">LOG_MODULEDB</a>&nbsp;&nbsp;&nbsp;0x00800000</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#a7574ce4aa047de1f4a564c9b441e69dc">LOG_ALL</a>&nbsp;&nbsp;&nbsp;0x00ffffff</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#a7af2dcd801f468cdc1cce40f7e885ffc">BB_ORIGIN_HEADER_SIZE</a>&nbsp;&nbsp;&nbsp;(sizeof(app_pc)+sizeof(int))</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#a25512292915eb6d1109b90f9c3bd1518">STUB_DATA_FIXED_SIZE</a>&nbsp;&nbsp;&nbsp;(offsetof(<a class="el" href="struct__tracedump__stub__data.html">tracedump_stub_data_t</a>, count))</td></tr>
<tr><td colspan="2"><h2>Typedefs</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef void *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#ad4bb25312a86996379357f79a4c7c1c1">dr_auxlib_handle_t</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef void(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#a9442b3e0a17431ef00a90ffc0c956224">dr_auxlib_routine_ptr_t</a> )()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="struct__dr__mem__info__t.html">_dr_mem_info_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#a2834876d9bbe13989ed6ebc2e2f94c6a">dr_mem_info_t</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef void *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#ab855db7dce02dc18831280f19df840cf">module_handle_t</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef union <a class="el" href="union__version__number__t.html">_version_number_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#aee552e6017b95b4708435b9467223d98">version_number_t</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="struct__module__names__t.html">_module_names_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#a8d2fef062beef2b521283369e0108282">module_names_t</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef struct <br class="typebreak"/>
<a class="el" href="struct__dr__os__version__info__t.html">_dr_os_version_info_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#ad4b7c9d9efa9ec7a767855587eaa622e">dr_os_version_info_t</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef void *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#afd116a488df74505f27ff57cd49b9f88">dr_module_iterator_t</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef struct <br class="typebreak"/>
<a class="el" href="struct__module__segment__data__t.html">_module_segment_data_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#ab49d9cfe4b0a8495532e5e4189515e83">module_segment_data_t</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="struct__dr__export__info__t.html">_dr_export_info_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#af3e96c875a305558239b74496c4030d0">dr_export_info_t</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef struct <br class="typebreak"/>
<a class="el" href="struct__tracedump__file__header__t.html">_tracedump_file_header_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#a99aca5de3a975309ebf0f24cfe42c1e8">tracedump_file_header_t</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef struct <br class="typebreak"/>
<a class="el" href="struct__tracedump__trace__header__t.html">_tracedump_trace_header_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#a3fe0415406026b8daf538ab6ac31519d">tracedump_trace_header_t</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="struct__tracedump__stub__data.html">_tracedump_stub_data</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#afbec914b027f98ee51e888671aac55f0">tracedump_stub_data_t</a></td></tr>
<tr><td colspan="2"><h2>Enumerations</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#aff97be516bbb1aecdb6bd043841aaa10">dr_mem_type_t</a> { <br/>
&nbsp;&nbsp;<a class="el" href="dr__tools_8h.html#aff97be516bbb1aecdb6bd043841aaa10a60e91c7b948d92d08b74ee0cd50dee3d">DR_MEMTYPE_FREE</a>, 
<br/>
&nbsp;&nbsp;<a class="el" href="dr__tools_8h.html#aff97be516bbb1aecdb6bd043841aaa10a6edf083337f9c953747a2cf4461dcbf7">DR_MEMTYPE_IMAGE</a>, 
<br/>
&nbsp;&nbsp;<a class="el" href="dr__tools_8h.html#aff97be516bbb1aecdb6bd043841aaa10ac0350de0d08726ea8a5a5f02bb7010b0">DR_MEMTYPE_DATA</a>
<br/>
 }</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#a311ab26d3bdc2d6ff7830b6f3ae9760c">dr_os_version_t</a> { , <a class="el" href="dr__tools_8h.html#a311ab26d3bdc2d6ff7830b6f3ae9760caf960b684d92226cd35590c2804c8dfa6">DR_WINDOWS_VERSION_2003</a> =  52
 }</td></tr>
<tr><td colspan="2"><h2>Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#af63184f56cc0508e2840f64e84b1c48d">dr_standalone_init</a> (void)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#a54934632c814904bd9e0ce9c83980466">dr_using_all_private_caches</a> (void)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#a902bfca468a7a2cc3dbc45b4bd127444">dr_request_synchronized_exit</a> (void)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const char *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#a10831623706378cfc3082c0e27e31c4c">dr_get_options</a> (<a class="el" href="dr__defines_8h.html#a68540a70b4f8150a4fe6dcec91bf8825">client_id_t</a> client_id)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const char *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#afb7d403eb032bd14ae78807ae3d59ea0">dr_get_client_path</a> (<a class="el" href="dr__defines_8h.html#a68540a70b4f8150a4fe6dcec91bf8825">client_id_t</a> client_id)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">byte *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#aae96ea91548daf1a0b5a78197bc86f07">dr_get_client_base</a> (<a class="el" href="dr__defines_8h.html#a68540a70b4f8150a4fe6dcec91bf8825">client_id_t</a> client_id)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const char *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#aace5e8084f523fd25871b31463c7ecda">dr_get_application_name</a> (void)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">process_id_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#a83b3658ca78e6b7adc81c57691f0fe50">dr_get_process_id</a> (void)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">process_id_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#a11575b203a0558f5df50126ff04c4598">dr_get_parent_id</a> (void)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#abab30ef95ab36e4e885a9dc89f540c39">dr_get_os_version</a> (<a class="el" href="struct__dr__os__version__info__t.html">dr_os_version_info_t</a> *info)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#ac5804006579a63b49827169d3ffbebc8">dr_is_wow64</a> (void)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#a81037ee313844d4fbce3368f4421e5b4">dr_get_app_PEB</a> (void)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#ae517c4817d67af6ad92b8f1d7694080a">dr_get_time</a> (<a class="el" href="structdr__time__t.html">dr_time_t</a> *time)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">uint64&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#a4b187636a3fc9ba7964ae11a7fd30fb6">dr_get_milliseconds</a> (void)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">uint&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#aeb3d12bdde33dd279f09bcb2a5bfd901">dr_get_random_value</a> (uint max)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#a53bfa41e85c457ff39452a68eaf2281b">dr_set_random_seed</a> (uint seed)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">uint&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#af3212441c8fd1642d6d1fb7850562106">dr_get_random_seed</a> (void)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#a12c1ca981b7d3049cb2d31c0f19da332">dr_abort</a> (void)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#a4274226adda06339e247e4a311abdd9b">dr_thread_alloc</a> (void *drcontext, size_t size)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#a3f1f3862009f52182e9ca1f943fa6f14">dr_thread_free</a> (void *drcontext, void *mem, size_t size)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#a60faa40f7e8c819c34fd25cb367c5473">dr_global_alloc</a> (size_t size)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#ace8794210449c50fb4d411ad74a8dec1">dr_global_free</a> (void *mem, size_t size)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#ac32b5be072876c25a832d510efeba6e4">dr_nonheap_alloc</a> (size_t size, uint prot)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#a401b819525f805d04e0a9560fdcfdf89">dr_nonheap_free</a> (void *mem, size_t size)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#a3687f50774c89e7a09833a71adbb7771">__wrap_malloc</a> (size_t size)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#adcaad79adf4fc109015dd6a2d49b9031">__wrap_realloc</a> (void *mem, size_t size)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#a818524883cd69709fe0e3499d6748d14">__wrap_calloc</a> (size_t nmemb, size_t size)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#a82dca5b3d5bfbd3de8891502badd861e">__wrap_free</a> (void *mem)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#aa1dd6ff985f0b21deada31ea33485737">dr_memory_is_readable</a> (const byte *pc, size_t size)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#ad158d2822dd8bb9caa9604d84b666bfa">dr_query_memory</a> (const byte *pc, byte **base_pc, size_t *size, uint *prot)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#a5a6e4049f8accbc73ec5dbaf0deb25a7">dr_query_memory_ex</a> (const byte *pc, OUT <a class="el" href="struct__dr__mem__info__t.html">dr_mem_info_t</a> *info)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">size_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#a55ca77553e86a0656dc186ae3fc8222f">dr_virtual_query</a> (const byte *pc, MEMORY_BASIC_INFORMATION *mbi, size_t mbi_size)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#a6a94558696130c76f34dcdac0ce50c47">dr_safe_read</a> (const void *base, size_t size, void *out_buf, size_t *bytes_read)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#ab94f47b693cc7dd9eecba07d8cfd1bc8">dr_safe_write</a> (void *base, size_t size, const void *in_buf, size_t *bytes_written)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#aef746f843b3270add2c763ab71457e5d">dr_try_setup</a> (void *drcontext, void **try_cxt)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#aa59cdd4f9fa2884b5d236f0fedc5bda3">dr_try_start</a> (void *buf)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#afde42618a83e7e1abdc58961a084e774">dr_try_stop</a> (void *drcontext, void *try_cxt)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#a2c3a19a0dc146c1e5b6747e89bacfb55">dr_memory_protect</a> (void *base, size_t size, uint new_prot)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#a813f98fcc06c0a1198262b744e98eced">dr_memory_is_dr_internal</a> (const byte *pc)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#a2a67b03d64626f3d0a78b64bf096ed25">dr_memory_is_in_client</a> (const byte *pc)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="dr__tools_8h.html#ad4bb25312a86996379357f79a4c7c1c1">dr_auxlib_handle_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#a94c8a2e52880f44d43402d6b0d686db2">dr_load_aux_library</a> (const char *name, byte **lib_start, byte **lib_end)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="dr__tools_8h.html#a9442b3e0a17431ef00a90ffc0c956224">dr_auxlib_routine_ptr_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#a814a1a50cc288dc902f2a2dcef9812c6">dr_lookup_aux_library_routine</a> (<a class="el" href="dr__tools_8h.html#ad4bb25312a86996379357f79a4c7c1c1">dr_auxlib_handle_t</a> lib, const char *name)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#a552563b1ccb84e3708041b276404d577">dr_unload_aux_library</a> (<a class="el" href="dr__tools_8h.html#ad4bb25312a86996379357f79a4c7c1c1">dr_auxlib_handle_t</a> lib)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#a55da3fd48670f25ec69ee5daf5975de5">dr_mutex_create</a> (void)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#aaab148b68bc8e1479a14c175cbf42fc0">dr_mutex_destroy</a> (void *mutex)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#a04beaefb3e0be6bd0dac39f76398ec1e">dr_mutex_lock</a> (void *mutex)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#a61a3a4ffffd0058a37211405fbb6ba51">dr_mutex_unlock</a> (void *mutex)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#a6b2ae4a29e2dc18dde2a6f01f26cbe79">dr_mutex_trylock</a> (void *mutex)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#ae453a9c1ded7c8cd31d1a1aa2c8810af">dr_mutex_self_owns</a> (void *mutex)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#a536222ea450d92cabebd3b24fe08098e">dr_rwlock_create</a> (void)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#aba97c3f8aea471718852b424e6bce35d">dr_rwlock_destroy</a> (void *rwlock)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#a96d7cd454ca96a0c2d1e701ab78cbcd8">dr_rwlock_read_lock</a> (void *rwlock)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#a3acf4f252a71dc5034aa0d99a59103a8">dr_rwlock_read_unlock</a> (void *rwlock)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#afcb402769c7bc443876c00ad1f9cdbf9">dr_rwlock_write_lock</a> (void *rwlock)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#adfb241b0d90ee47cc3885d2c24c70d94">dr_rwlock_write_unlock</a> (void *rwlock)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#ac7e812e134e71ea3b844387a75bfc273">dr_rwlock_write_trylock</a> (void *rwlock)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#aeb9b30addf3e5bf910109061159aef01">dr_rwlock_self_owns_write_lock</a> (void *rwlock)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#a5563eff378a7e2ea61b7dd7fcd777a36">dr_recurlock_create</a> (void)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#af7a203f4a8ebcc35d50e51ed31a51b1f">dr_recurlock_destroy</a> (void *reclock)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#abf5a80009a8f667b86acb529fbc75ac4">dr_recurlock_lock</a> (void *reclock)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#a7d36a11978be634e28116da9dd408030">dr_recurlock_unlock</a> (void *reclock)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#a16d473debdc03a782d8aa5032fb3dd97">dr_recurlock_trylock</a> (void *reclock)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#ac33bd56345cfb4286a05e0c3eab6b3a0">dr_recurlock_self_owns</a> (void *reclock)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct__module__data__t.html">module_data_t</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#a4892d089da710e952a23055bd7db38af">dr_lookup_module</a> (byte *pc)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct__module__data__t.html">module_data_t</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#addd653edd3322cfb025ef8bdc6ae1060">dr_lookup_module_by_name</a> (const char *name)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="dr__tools_8h.html#afd116a488df74505f27ff57cd49b9f88">dr_module_iterator_t</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#a3310b1bfc22da285af72b1a4a9d10945">dr_module_iterator_start</a> (void)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#a1702cf25e24e722d9441f92c41fac33e">dr_module_iterator_hasnext</a> (<a class="el" href="dr__tools_8h.html#afd116a488df74505f27ff57cd49b9f88">dr_module_iterator_t</a> *mi)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct__module__data__t.html">module_data_t</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#a9d49edb3a7b59f5d817afaa8fc0f1ef9">dr_module_iterator_next</a> (<a class="el" href="dr__tools_8h.html#afd116a488df74505f27ff57cd49b9f88">dr_module_iterator_t</a> *mi)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#a15134844f1dd3e914c0da59c65cb3a8d">dr_module_iterator_stop</a> (<a class="el" href="dr__tools_8h.html#afd116a488df74505f27ff57cd49b9f88">dr_module_iterator_t</a> *mi)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct__module__data__t.html">module_data_t</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#a8c99a2d79ed312cd852d57e975601adc">dr_copy_module_data</a> (const <a class="el" href="struct__module__data__t.html">module_data_t</a> *data)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#ad72ba1e8b98c8e01f2c28ef2e4d3e16e">dr_free_module_data</a> (<a class="el" href="struct__module__data__t.html">module_data_t</a> *data)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const char *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#a082fe71b00688310237fbc2e027c4388">dr_module_preferred_name</a> (const <a class="el" href="struct__module__data__t.html">module_data_t</a> *data)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#ac520aa05555ecbf9e525de582d4baa8c">dr_lookup_module_section</a> (<a class="el" href="dr__tools_8h.html#ab855db7dce02dc18831280f19df840cf">module_handle_t</a> lib, byte *pc, IMAGE_SECTION_HEADER *section_out)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">generic_func_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#a8da7923ecc4e020e31442bcc8d9f8d3e">dr_get_proc_address</a> (<a class="el" href="dr__tools_8h.html#ab855db7dce02dc18831280f19df840cf">module_handle_t</a> lib, const char *name)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#af1a068ad89408abbcfba026706810211">dr_get_proc_address_ex</a> (<a class="el" href="dr__tools_8h.html#ab855db7dce02dc18831280f19df840cf">module_handle_t</a> lib, const char *name, <a class="el" href="struct__dr__export__info__t.html">dr_export_info_t</a> *info OUT, size_t info_len)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">reg_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#a1e01fe123ecc9908ada9c9fccbf3f6ab">dr_syscall_get_param</a> (void *drcontext, int param_num)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#ac21a83f1812443112303ef3ea8b76de2">dr_syscall_set_param</a> (void *drcontext, int param_num, reg_t new_value)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">reg_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#ad12463724bf63a891e991891c72e6a4b">dr_syscall_get_result</a> (void *drcontext)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#a601cd2b724ac627aef0756a4c4eee637">dr_syscall_set_result</a> (void *drcontext, reg_t value)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#abc80dfdf8bff3c3feb486aacd69aba7c">dr_syscall_set_sysnum</a> (void *drcontext, int new_num)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#a76797a9310bf67ebeb820d80e11764b8">dr_syscall_invoke_another</a> (void *drcontext)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#a1ee2651cad7bafe65f3df7d4aeb82120">dr_create_dir</a> (const char *fname)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#a02f86a68a105442a029baa05a1af9d57">dr_directory_exists</a> (const char *fname)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#af471633d0954d80c09ca6c2bfe40475b">dr_file_exists</a> (const char *fname)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">file_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#ae3ae2190774a204af207602791a32cb6">dr_open_file</a> (const char *fname, uint mode_flags)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#ac25b305e0be9f6c09f9761b14f3bbc74">dr_close_file</a> (file_t f)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#ab23dff0c2d6d045cd938fc5f2c77a1ff">dr_rename_file</a> (const char *src, const char *dst, bool replace)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#a7ce7b5b2390cb5e03466cd605735bdfc">dr_delete_file</a> (const char *filename)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#ae51098d1c742e3189a197db0c212eaa9">dr_flush_file</a> (file_t f)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">ssize_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#aeddf708cc2271dc50209b3e78e1d23fb">dr_write_file</a> (file_t f, const void *buf, size_t count)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">ssize_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#a71f6940085912cdce608f317a27fc397">dr_read_file</a> (file_t f, void *buf, size_t count)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#a18c2c9d68ceceef8c6455b06502667ee">dr_file_seek</a> (file_t f, int64 offset, int origin)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int64&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#a1fc1d26f3050d6f361e7b07f98c7e82d">dr_file_tell</a> (file_t f)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">file_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#a66ef4b43d78d787c7622569d30717051">dr_dup_file_handle</a> (file_t f)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#a06a8173579db03d018935afb1ca891f6">dr_file_size</a> (file_t fd, OUT uint64 *size)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#af7d3a723c65e3762dd62b115577e0625">dr_map_file</a> (file_t f, INOUT size_t *size, uint64 offs, app_pc addr, uint prot, uint flags)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#ae7f36900cafd048db5b8d34cf92faa45">dr_unmap_file</a> (void *map, size_t size)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#a332a14861f12823994465e8c9b6a3015">dr_log</a> (void *drcontext, uint mask, uint level, const char *fmt,...)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">file_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#afd7e9d485a84aa147e0ec0e75ad6d962">dr_get_logfile</a> (void *drcontext)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#af91a810b83f1173a5720a955c3d0fd4a">dr_is_notify_on</a> (void)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">file_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#a0353e78f517dc281de22539682d9e6d9">dr_get_stdout_file</a> (void)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">file_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#a20dccb3e2b03e8f408b2a340c70a28e2">dr_get_stderr_file</a> (void)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">file_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#aed162d7ad949b05fe8232771eaeca6a9">dr_get_stdin_file</a> (void)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#ad444a204e7ca45f9965cfe973470375a">dr_messagebox</a> (const char *fmt,...)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#abad2eddb3786e3e909ff36da39b7e31e">dr_printf</a> (const char *fmt,...)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#afe7ede5b10890505021ac03e8f9ba97f">dr_fprintf</a> (file_t f, const char *fmt,...)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#a712de67b3f6adb6778ce302925009753">dr_enable_console_printing</a> (void)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#a505318c1ece53cdaff85f387dc6bf758">dr_using_console</a> (void)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#ab0c5f2529d9c076b5b0b0e92a70834b7">dr_snprintf</a> (char *buf, size_t max, const char *fmt,...)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#ad6b928d8cbc48fdf7d1d82c4fa95e40e">dr_vsnprintf</a> (char *buf, size_t max, const char *fmt, va_list ap)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#aecb77c99028d913a72c6aaeef48db785">dr_print_instr</a> (void *drcontext, file_t f, <a class="el" href="structinstr__t.html">instr_t</a> *instr, const char *msg)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#a5902fa16202c9c42d96c755e9412d372">dr_print_opnd</a> (void *drcontext, file_t f, <a class="el" href="structopnd__t.html">opnd_t</a> opnd, const char *msg)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#a13217cc252506b06184c7c72adedf26c">dr_get_current_drcontext</a> (void)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">thread_id_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#a3980d703cc13379a6b57396a7901b1d1">dr_get_thread_id</a> (void *drcontext)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#a787aff5df1ded3de8a7ce9f3efef0594">dr_get_tls_field</a> (void *drcontext)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#a05b499c8a3115e9ceb4c45dbee660738">dr_set_tls_field</a> (void *drcontext, void *value)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#a8d753cde7a82c612fcb0e1cdbc65fdf0">dr_get_dr_segment_base</a> (IN reg_id_t segment_register)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#a95b53d79cae021a473c39f3b2662323f">dr_raw_tls_calloc</a> (OUT reg_id_t *segment_register, OUT uint *offset, IN uint num_slots, IN uint alignment)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#afc53219d019078a38c80ffa80d71829e">dr_raw_tls_cfree</a> (uint offset, uint num_slots)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#ac6b80b83502ff13d4674b13e7b30b555">dr_create_client_thread</a> (void(*func)(void *param), void *arg)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#af57b95b87d8da29a16ca923a5b1b98b3">dr_client_thread_set_suspendable</a> (bool suspendable)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#af154e498d8b185931ef970676cb65351">dr_sleep</a> (int time_ms)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#ac262422c1e5e487113176bd4193c387f">dr_thread_yield</a> (void)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#a01fbe357fcc8352ba63c9a1a23e0c207">dr_suspend_all_other_threads</a> (OUT void ***drcontexts, OUT uint *num_suspended, OUT uint *num_unsuspended)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#a1193842150b09442a1b3c91f4e02d280">dr_resume_all_other_threads</a> (IN void **drcontexts, IN uint num_suspended)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#a9191c67a267070ed51289d7192f986aa">dr_set_itimer</a> (int which, uint millisec, void(*func)(void *drcontext, <a class="el" href="struct__dr__mcontext__t.html">dr_mcontext_t</a> *mcontext))</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">uint&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#ab5cd85ea911bd99dedbd8d05796260bc">dr_get_itimer</a> (int which)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#a5421c0abd69da94ed3e7fb898d5bb132">dr_replace_fragment</a> (void *drcontext, void *tag, instrlist_t *ilist)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#a7600cc31d68dc0e30ab91261d08836ed">dr_delete_fragment</a> (void *drcontext, void *tag)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#abe87d17869a51a66d59eecf459d71cc0">dr_flush_region</a> (app_pc start, size_t size)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#a56909cf76e4a71fca13731053ef48928">dr_unlink_flush_region</a> (app_pc start, size_t size)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#afa5ea6649e644074ca55f456c89264e8">dr_delay_flush_region</a> (app_pc start, size_t size, uint flush_id, void(*flush_completion_callback)(int flush_id))</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#a775fdf1d5a55b5fbca094a4d2f18d28f">dr_fragment_exists_at</a> (void *drcontext, void *tag)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#aad3b09e886366ac10341e69a577555dd">dr_bb_exists_at</a> (void *drcontext, void *tag)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">uint&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#acfe1f6436b234406bde1970ecfa614b5">dr_fragment_size</a> (void *drcontext, void *tag)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">app_pc&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#a724aa7f7e87a604071fffa0a01925bf0">dr_fragment_app_pc</a> (void *tag)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">app_pc&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#acd67a10cd03a382853a0523bde9990f5">dr_app_pc_for_decoding</a> (app_pc pc)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">app_pc&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#ac150776be7e338321cbb8edc49ab7790">dr_app_pc_from_cache_pc</a> (byte *cache_pc)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#a7ed94a2b046bb9ee777afe4f3ef1237f">dr_using_app_state</a> (void *drcontext)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#aa2944aa54d591a236f5334a35bfb41bf">dr_switch_to_app_state</a> (void *drcontext)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#a97ba972c50a47e7121c98652b461ae8e">dr_switch_to_dr_state</a> (void *drcontext)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#a9e262e93823dbc5914eca34540afbc07">dr_mark_trace_head</a> (void *drcontext, void *tag)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#a1e3f7e4e3e4048021966c04a4b00fbc9">dr_trace_head_at</a> (void *drcontext, void *tag)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#a1d4c9a29f1c962457c123322aa3e1931">dr_trace_exists_at</a> (void *drcontext, void *tag)</td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<p>Main API routines, including transparency support. </p>
<hr/><h2>Define Documentation</h2>
<a class="anchor" id="a7af2dcd801f468cdc1cce40f7e885ffc"></a><!-- doxytag: member="dr_tools.h::BB_ORIGIN_HEADER_SIZE" ref="a7af2dcd801f468cdc1cce40f7e885ffc" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define BB_ORIGIN_HEADER_SIZE&nbsp;&nbsp;&nbsp;(sizeof(app_pc)+sizeof(int))</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Size of tag + bb_code_size fields for each bb. <a class="el" href="struct__tracedump__stub__data.html#ab397d14965f6ac0c4f0c28a36f667200">tracedump_stub_data_t.stub_size</a> will not exceed this value. </p>

</div>
</div>
<a class="anchor" id="a7c07630dffdfd92bc6ee63abf405768c"></a><!-- doxytag: member="dr_tools.h::DR_ASSERT" ref="a7c07630dffdfd92bc6ee63abf405768c" args="(x)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define DR_ASSERT</td>
          <td>(</td>
          <td class="paramtype">x&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td>&nbsp;&nbsp;&nbsp;DR_ASSERT_MSG(x, &quot;&quot;)</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>If <code>x</code> is false, displays a message about an assertion failure and then calls <a class="el" href="dr__tools_8h.html#a12c1ca981b7d3049cb2d31c0f19da332">dr_abort()</a> </p>

</div>
</div>
<a class="anchor" id="abd6d066ab9bdd578d4000e80df8503bc"></a><!-- doxytag: member="dr_tools.h::DR_ASSERT_MSG" ref="abd6d066ab9bdd578d4000e80df8503bc" args="(x, msg)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define DR_ASSERT_MSG</td>
          <td>(</td>
          <td class="paramtype">x, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">msg&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<b>Value:</b><div class="fragment"><pre class="fragment">((void)((!(x)) ? \
        (<a class="code" href="dr__tools_8h.html#ad444a204e7ca45f9965cfe973470375a">dr_messagebox</a>(<span class="stringliteral">&quot;ASSERT FAILURE: %s:%d: %s (%s)&quot;</span>, __FILE__,  __LINE__, #x, msg),\
         <a class="code" href="dr__tools_8h.html#a12c1ca981b7d3049cb2d31c0f19da332">dr_abort</a>(), 0) : 0))
</pre></div><p>If <code>x</code> is false, displays a message about an assertion failure (appending <code>msg</code> to the message) and then calls <a class="el" href="dr__tools_8h.html#a12c1ca981b7d3049cb2d31c0f19da332">dr_abort()</a> </p>

</div>
</div>
<a class="anchor" id="a77a3b276c8d9a62bf6d78c3707d4effd"></a><!-- doxytag: member="dr_tools.h::DR_FILE_ALLOW_LARGE" ref="a77a3b276c8d9a62bf6d78c3707d4effd" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define DR_FILE_ALLOW_LARGE&nbsp;&nbsp;&nbsp;0x10</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Open with large (&gt;2GB) file support. Only applicable on 32-bit Linux. </p>
<dl class="note"><dt><b>Note:</b></dt><dd>DR's log files and tracedump files are all created with this flag. </dd></dl>

</div>
</div>
<a class="anchor" id="a0401a3003f578602bf31a984a4d5419d"></a><!-- doxytag: member="dr_tools.h::DR_FILE_CLOSE_ON_FORK" ref="a0401a3003f578602bf31a984a4d5419d" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define DR_FILE_CLOSE_ON_FORK&nbsp;&nbsp;&nbsp;0x20</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Linux-only. This file will be closed in the child of a fork. </p>

</div>
</div>
<a class="anchor" id="ad0772bc47090cec1a333baf1259f226d"></a><!-- doxytag: member="dr_tools.h::DR_FILE_READ" ref="ad0772bc47090cec1a333baf1259f226d" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define DR_FILE_READ&nbsp;&nbsp;&nbsp;0x1</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Open with read access. </p>

</div>
</div>
<a class="anchor" id="ac989ab040f48c4c91cc3a6ea63f9ec1f"></a><!-- doxytag: member="dr_tools.h::DR_FILE_WRITE_APPEND" ref="ac989ab040f48c4c91cc3a6ea63f9ec1f" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define DR_FILE_WRITE_APPEND&nbsp;&nbsp;&nbsp;0x4</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Open with write access. If the file already exists, set the file position to the end of the file. </p>

</div>
</div>
<a class="anchor" id="a5fb30eb2b5d14486b3ecbc2b2457dfdb"></a><!-- doxytag: member="dr_tools.h::DR_FILE_WRITE_OVERWRITE" ref="a5fb30eb2b5d14486b3ecbc2b2457dfdb" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define DR_FILE_WRITE_OVERWRITE&nbsp;&nbsp;&nbsp;0x8</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Open with write access. If the file already exists, truncate the file to zero length. </p>

</div>
</div>
<a class="anchor" id="a11f713faf2e1eac95bc26a98b67e28cc"></a><!-- doxytag: member="dr_tools.h::DR_FILE_WRITE_REQUIRE_NEW" ref="a11f713faf2e1eac95bc26a98b67e28cc" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define DR_FILE_WRITE_REQUIRE_NEW&nbsp;&nbsp;&nbsp;0x2</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Open with write access, but do not open if the file already exists. </p>

</div>
</div>
<a class="anchor" id="afe59b9f8bc395c1873bd9d0ebe294f22"></a><!-- doxytag: member="dr_tools.h::DR_MAP_FIXED" ref="afe59b9f8bc395c1873bd9d0ebe294f22" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define DR_MAP_FIXED&nbsp;&nbsp;&nbsp;0x2</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>If set, indicates that the passed-in start address is required rather than a hint. On Linux, this has the same semantics as mmap with MAP_FIXED: i.e., any existing mapping in [addr,addr+size) will be unmapped. This flags is not supported on Windows. </p>

</div>
</div>
<a class="anchor" id="a016c45394c5057ce6c699cae82d2ac2b"></a><!-- doxytag: member="dr_tools.h::DR_MAP_PRIVATE" ref="a016c45394c5057ce6c699cae82d2ac2b" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define DR_MAP_PRIVATE&nbsp;&nbsp;&nbsp;0x1</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>If set, changes to mapped memory are private to the mapping process and are not reflected in the underlying file. If not set, changes are visible to other processes that map the same file, and will be propagated to the file itself. </p>

</div>
</div>
<a class="anchor" id="ad98be75b6fde3dc1dbfb8bfda59fce66"></a><!-- doxytag: member="dr_tools.h::DR_MEMPROT_EXEC" ref="ad98be75b6fde3dc1dbfb8bfda59fce66" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define DR_MEMPROT_EXEC&nbsp;&nbsp;&nbsp;0x04</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Execute privileges. </p>

</div>
</div>
<a class="anchor" id="ac2c501052e751bc9c72c622b1ca8b96c"></a><!-- doxytag: member="dr_tools.h::DR_MEMPROT_NONE" ref="ac2c501052e751bc9c72c622b1ca8b96c" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define DR_MEMPROT_NONE&nbsp;&nbsp;&nbsp;0x00</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>No read, write, or execute privileges. </p>

</div>
</div>
<a class="anchor" id="ab430d92dd0d6338ec3e42b527ae91efb"></a><!-- doxytag: member="dr_tools.h::DR_MEMPROT_READ" ref="ab430d92dd0d6338ec3e42b527ae91efb" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define DR_MEMPROT_READ&nbsp;&nbsp;&nbsp;0x01</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Read privileges. </p>

</div>
</div>
<a class="anchor" id="a1dafb99a4933112c603189bc091fa752"></a><!-- doxytag: member="dr_tools.h::DR_MEMPROT_WRITE" ref="a1dafb99a4933112c603189bc091fa752" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define DR_MEMPROT_WRITE&nbsp;&nbsp;&nbsp;0x02</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Write privileges. </p>

</div>
</div>
<a class="anchor" id="ad31bd52878d2454d8263d0951cfd1ca0"></a><!-- doxytag: member="dr_tools.h::DR_SEEK_CUR" ref="ad31bd52878d2454d8263d0951cfd1ca0" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define DR_SEEK_CUR&nbsp;&nbsp;&nbsp;1</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>current file position </p>

</div>
</div>
<a class="anchor" id="a06e58c043e838f1457853329fd4344a3"></a><!-- doxytag: member="dr_tools.h::DR_SEEK_END" ref="a06e58c043e838f1457853329fd4344a3" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define DR_SEEK_END&nbsp;&nbsp;&nbsp;2</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>end of file </p>

</div>
</div>
<a class="anchor" id="aa675a6270b664511299295ebc1f5562e"></a><!-- doxytag: member="dr_tools.h::DR_SEEK_SET" ref="aa675a6270b664511299295ebc1f5562e" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define DR_SEEK_SET&nbsp;&nbsp;&nbsp;0</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>start of file </p>

</div>
</div>
<a class="anchor" id="adb9ba447c606e5e58400ac7b6ef719d1"></a><!-- doxytag: member="dr_tools.h::DR_TRY_EXCEPT" ref="adb9ba447c606e5e58400ac7b6ef719d1" args="(drcontext, try_statement, except_statement)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define DR_TRY_EXCEPT</td>
          <td>(</td>
          <td class="paramtype">drcontext, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">try_statement, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">except_statement&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<b>Value:</b><div class="fragment"><pre class="fragment"><span class="keywordflow">do</span> {\
    <span class="keywordtype">void</span> *try_cxt;                                                    \
    <a class="code" href="dr__tools_8h.html#aef746f843b3270add2c763ab71457e5d">dr_try_setup</a>(drcontext, &amp;try_cxt);                                \
    <span class="keywordflow">if</span> (<a class="code" href="dr__tools_8h.html#aa59cdd4f9fa2884b5d236f0fedc5bda3">dr_try_start</a>(try_cxt) == 0) {                                 \
        try_statement                                                 \
        <a class="code" href="dr__tools_8h.html#afde42618a83e7e1abdc58961a084e774">dr_try_stop</a>(drcontext, try_cxt);                              \
    } <span class="keywordflow">else</span> {                                                          \
        <span class="comment">/* roll back first in case except faults or returns */</span>        \
        <a class="code" href="dr__tools_8h.html#afde42618a83e7e1abdc58961a084e774">dr_try_stop</a>(drcontext, try_cxt);                              \
        except_statement                                              \
    }                                                                 \
} <span class="keywordflow">while</span> (0)
</pre></div><p>Simple try..except support for executing operations that might fault and recovering if they do. Be careful with this feature as it has some limitations:</p>
<ul>
<li>do not use a return within a try statement (we do not have language support)</li>
<li>any automatic variables that you want to use in the except block should be declared volatile</li>
<li>no locks should be grabbed in a try statement (because there is no finally support to release them)</li>
<li>nesting is supported, but finally statements are not supported</li>
</ul>
<p>For fault-free reads or writes in isolation, use <a class="el" href="dr__tools_8h.html#a6a94558696130c76f34dcdac0ce50c47">dr_safe_read()</a> or <a class="el" href="dr__tools_8h.html#ab94f47b693cc7dd9eecba07d8cfd1bc8">dr_safe_write()</a> instead, although on Windows those operations invoke a system call and this construct can be more performant. </p>

</div>
</div>
<a class="anchor" id="a4e6bdc93e35ee5a9f081564a162ec3b9"></a><!-- doxytag: member="dr_tools.h::GLOBAL_DCONTEXT" ref="a4e6bdc93e35ee5a9f081564a162ec3b9" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define GLOBAL_DCONTEXT&nbsp;&nbsp;&nbsp;((void *)-1)</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Use this dcontext for use with the standalone static decoder library. Pass it whenever a decoding-related API routine asks for a context. </p>

</div>
</div>
<a class="anchor" id="a7574ce4aa047de1f4a564c9b441e69dc"></a><!-- doxytag: member="dr_tools.h::LOG_ALL" ref="a7574ce4aa047de1f4a564c9b441e69dc" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LOG_ALL&nbsp;&nbsp;&nbsp;0x00ffffff</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Log all data. </p>

</div>
</div>
<a class="anchor" id="a5895b0ef2efc255ad93e50bc88277b6d"></a><!-- doxytag: member="dr_tools.h::LOG_ASYNCH" ref="a5895b0ef2efc255ad93e50bc88277b6d" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LOG_ASYNCH&nbsp;&nbsp;&nbsp;0x00000010</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Log data related to signals/callbacks/etc. </p>

</div>
</div>
<a class="anchor" id="a031661fca6b5cb813db972d758caca2b"></a><!-- doxytag: member="dr_tools.h::LOG_CACHE" ref="a031661fca6b5cb813db972d758caca2b" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LOG_CACHE&nbsp;&nbsp;&nbsp;0x00000100</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Log data related to code cache management. </p>

</div>
</div>
<a class="anchor" id="a9929e24db31369398fbdc52ee040b234"></a><!-- doxytag: member="dr_tools.h::LOG_DISPATCH" ref="a9929e24db31369398fbdc52ee040b234" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LOG_DISPATCH&nbsp;&nbsp;&nbsp;0x00000400</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Log data on every context switch dispatch. </p>

</div>
</div>
<a class="anchor" id="a06582648acdd995a11019f726b15adda"></a><!-- doxytag: member="dr_tools.h::LOG_EMIT" ref="a06582648acdd995a11019f726b15adda" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LOG_EMIT&nbsp;&nbsp;&nbsp;0x00000040</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Log data related to emitting code. </p>

</div>
</div>
<a class="anchor" id="a7c5fcb805e6a1fdfac332931888b3ef7"></a><!-- doxytag: member="dr_tools.h::LOG_FRAGMENT" ref="a7c5fcb805e6a1fdfac332931888b3ef7" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LOG_FRAGMENT&nbsp;&nbsp;&nbsp;0x00000200</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Log data related to app code fragments. </p>

</div>
</div>
<a class="anchor" id="a5522e92b98898a21b7c26ba9df95f094"></a><!-- doxytag: member="dr_tools.h::LOG_HEAP" ref="a5522e92b98898a21b7c26ba9df95f094" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LOG_HEAP&nbsp;&nbsp;&nbsp;0x00001000</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Log data related to memory management. </p>

</div>
</div>
<a class="anchor" id="a51c2bbdf11618716da67a305dd24ddde"></a><!-- doxytag: member="dr_tools.h::LOG_HOT_PATCHING" ref="a51c2bbdf11618716da67a305dd24ddde" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LOG_HOT_PATCHING&nbsp;&nbsp;&nbsp;0x00200000</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Log data related to hot patching. </p>

</div>
</div>
<a class="anchor" id="a6ec73009ed3f0c2baa1d3c44033c261e"></a><!-- doxytag: member="dr_tools.h::LOG_HTABLE" ref="a6ec73009ed3f0c2baa1d3c44033c261e" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LOG_HTABLE&nbsp;&nbsp;&nbsp;0x00400000</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Log data related to hash tables. </p>

</div>
</div>
<a class="anchor" id="a54bbda8cb7e78f2ea32209bab2d7201c"></a><!-- doxytag: member="dr_tools.h::LOG_INTERP" ref="a54bbda8cb7e78f2ea32209bab2d7201c" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LOG_INTERP&nbsp;&nbsp;&nbsp;0x00000020</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Log data related to app interpretation. </p>

</div>
</div>
<a class="anchor" id="a438ad3561d9d8616ff702b36d0b2bb7c"></a><!-- doxytag: member="dr_tools.h::LOG_LINKS" ref="a438ad3561d9d8616ff702b36d0b2bb7c" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LOG_LINKS&nbsp;&nbsp;&nbsp;0x00000080</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Log data related to linking code. </p>

</div>
</div>
<a class="anchor" id="aabb9931c63f1cf95cacca6463d5a9b09"></a><!-- doxytag: member="dr_tools.h::LOG_MEMSTATS" ref="aabb9931c63f1cf95cacca6463d5a9b09" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LOG_MEMSTATS&nbsp;&nbsp;&nbsp;0x00008000</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Log data related to memory statistics. </p>

</div>
</div>
<a class="anchor" id="abba5e74dd3a5577b7af5177960ecb9dd"></a><!-- doxytag: member="dr_tools.h::LOG_MODULEDB" ref="abba5e74dd3a5577b7af5177960ecb9dd" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LOG_MODULEDB&nbsp;&nbsp;&nbsp;0x00800000</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Log data related to the module database. </p>

</div>
</div>
<a class="anchor" id="a2575baf458eee6334f746544f91fa6cf"></a><!-- doxytag: member="dr_tools.h::LOG_MONITOR" ref="a2575baf458eee6334f746544f91fa6cf" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LOG_MONITOR&nbsp;&nbsp;&nbsp;0x00000800</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Log data related to trace building. </p>

</div>
</div>
<a class="anchor" id="a1632479322efa3952798f98177b54471"></a><!-- doxytag: member="dr_tools.h::LOG_NONE" ref="a1632479322efa3952798f98177b54471" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LOG_NONE&nbsp;&nbsp;&nbsp;0x00000000</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Log no data. </p>

</div>
</div>
<a class="anchor" id="a4f3856a58f1f9971ebcd62c99a448a5a"></a><!-- doxytag: member="dr_tools.h::LOG_NT" ref="a4f3856a58f1f9971ebcd62c99a448a5a" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LOG_NT&nbsp;&nbsp;&nbsp;0x00100000</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Log data related to Windows Native API. </p>

</div>
</div>
<a class="anchor" id="a9f746aa1ef6a208cd1cd7174a694c9e5"></a><!-- doxytag: member="dr_tools.h::LOG_OPTS" ref="a9f746aa1ef6a208cd1cd7174a694c9e5" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LOG_OPTS&nbsp;&nbsp;&nbsp;0x00010000</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Log data related to optimizations. </p>

</div>
</div>
<a class="anchor" id="a297668a84187b740ff4fe1e1d6e52eeb"></a><!-- doxytag: member="dr_tools.h::LOG_RCT" ref="a297668a84187b740ff4fe1e1d6e52eeb" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LOG_RCT&nbsp;&nbsp;&nbsp;0x00080000</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Log data related to indirect transfers. </p>

</div>
</div>
<a class="anchor" id="a8ad7f6071c29a882af67d3a72fe4e787"></a><!-- doxytag: member="dr_tools.h::LOG_SIDELINE" ref="a8ad7f6071c29a882af67d3a72fe4e787" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LOG_SIDELINE&nbsp;&nbsp;&nbsp;0x00020000</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Log data related to sideline threads. </p>

</div>
</div>
<a class="anchor" id="a9dd9f361c4a23133f724c84192eef8e1"></a><!-- doxytag: member="dr_tools.h::LOG_STATS" ref="a9dd9f361c4a23133f724c84192eef8e1" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LOG_STATS&nbsp;&nbsp;&nbsp;0x00000001</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Log per-thread and global statistics. </p>

</div>
</div>
<a class="anchor" id="a65630bab8d9fcde517b3f8ecb03c6de9"></a><!-- doxytag: member="dr_tools.h::LOG_SYMBOLS" ref="a65630bab8d9fcde517b3f8ecb03c6de9" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LOG_SYMBOLS&nbsp;&nbsp;&nbsp;0x00040000</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Log data related to app symbols. </p>

</div>
</div>
<a class="anchor" id="a8879b800acfbbe8f2ada805be6ef5121"></a><!-- doxytag: member="dr_tools.h::LOG_SYNCH" ref="a8879b800acfbbe8f2ada805be6ef5121" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LOG_SYNCH&nbsp;&nbsp;&nbsp;0x00004000</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Log data related to synchronization. </p>

</div>
</div>
<a class="anchor" id="a87ef794555c43a1988eb760835b2fa76"></a><!-- doxytag: member="dr_tools.h::LOG_SYSCALLS" ref="a87ef794555c43a1988eb760835b2fa76" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LOG_SYSCALLS&nbsp;&nbsp;&nbsp;0x00000008</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Log data related to system calls. </p>

</div>
</div>
<a class="anchor" id="a9390202fe239f2ee56c097d6940d10f6"></a><!-- doxytag: member="dr_tools.h::LOG_THREADS" ref="a9390202fe239f2ee56c097d6940d10f6" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LOG_THREADS&nbsp;&nbsp;&nbsp;0x00000004</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Log data related to threads. </p>

</div>
</div>
<a class="anchor" id="a9fdb93b09477bb1b1ee08d132dd6f4dc"></a><!-- doxytag: member="dr_tools.h::LOG_TOP" ref="a9fdb93b09477bb1b1ee08d132dd6f4dc" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LOG_TOP&nbsp;&nbsp;&nbsp;0x00000002</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Log top-level information. </p>

</div>
</div>
<a class="anchor" id="a557f3a77c5d95b7cd06661245030c687"></a><!-- doxytag: member="dr_tools.h::LOG_VMAREAS" ref="a557f3a77c5d95b7cd06661245030c687" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LOG_VMAREAS&nbsp;&nbsp;&nbsp;0x00002000</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Log data related to address space regions. </p>

</div>
</div>
<a class="anchor" id="a25512292915eb6d1109b90f9c3bd1518"></a><!-- doxytag: member="dr_tools.h::STUB_DATA_FIXED_SIZE" ref="a25512292915eb6d1109b90f9c3bd1518" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define STUB_DATA_FIXED_SIZE&nbsp;&nbsp;&nbsp;(offsetof(<a class="el" href="struct__tracedump__stub__data.html">tracedump_stub_data_t</a>, count))</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>The last offset into tracedump_stub_data_t of always-present fields. </p>

</div>
</div>
<hr/><h2>Typedef Documentation</h2>
<a class="anchor" id="ad4bb25312a86996379357f79a4c7c1c1"></a><!-- doxytag: member="dr_tools.h::dr_auxlib_handle_t" ref="ad4bb25312a86996379357f79a4c7c1c1" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void* <a class="el" href="dr__tools_8h.html#ad4bb25312a86996379357f79a4c7c1c1">dr_auxlib_handle_t</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>A handle to a loaded client auxiliary library. This is a different type than module_handle_t and is not necessarily the base address. </p>

</div>
</div>
<a class="anchor" id="a9442b3e0a17431ef00a90ffc0c956224"></a><!-- doxytag: member="dr_tools.h::dr_auxlib_routine_ptr_t" ref="a9442b3e0a17431ef00a90ffc0c956224" args=")()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* <a class="el" href="dr__tools_8h.html#a9442b3e0a17431ef00a90ffc0c956224">dr_auxlib_routine_ptr_t</a>)()</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>An exported routine in a loaded client auxiliary library. </p>

</div>
</div>
<a class="anchor" id="af3e96c875a305558239b74496c4030d0"></a><!-- doxytag: member="dr_tools.h::dr_export_info_t" ref="af3e96c875a305558239b74496c4030d0" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="struct__dr__export__info__t.html">_dr_export_info_t</a>  <a class="el" href="struct__dr__export__info__t.html">dr_export_info_t</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Data structure used by <a class="el" href="dr__tools_8h.html#af1a068ad89408abbcfba026706810211">dr_get_proc_address_ex()</a> to retrieve information about an exported symbol. </p>

</div>
</div>
<a class="anchor" id="a2834876d9bbe13989ed6ebc2e2f94c6a"></a><!-- doxytag: member="dr_tools.h::dr_mem_info_t" ref="a2834876d9bbe13989ed6ebc2e2f94c6a" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="struct__dr__mem__info__t.html">_dr_mem_info_t</a>  <a class="el" href="struct__dr__mem__info__t.html">dr_mem_info_t</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Describes a memory region. Used by <a class="el" href="dr__tools_8h.html#a5a6e4049f8accbc73ec5dbaf0deb25a7">dr_query_memory_ex()</a>. </p>

</div>
</div>
<a class="anchor" id="afd116a488df74505f27ff57cd49b9f88"></a><!-- doxytag: member="dr_tools.h::dr_module_iterator_t" ref="afd116a488df74505f27ff57cd49b9f88" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void* <a class="el" href="dr__tools_8h.html#afd116a488df74505f27ff57cd49b9f88">dr_module_iterator_t</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>For dr_module_iterator_* interface </p>

</div>
</div>
<a class="anchor" id="ad4b7c9d9efa9ec7a767855587eaa622e"></a><!-- doxytag: member="dr_tools.h::dr_os_version_info_t" ref="ad4b7c9d9efa9ec7a767855587eaa622e" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="struct__dr__os__version__info__t.html">_dr_os_version_info_t</a>  <a class="el" href="struct__dr__os__version__info__t.html">dr_os_version_info_t</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Data structure used with <a class="el" href="dr__tools_8h.html#abab30ef95ab36e4e885a9dc89f540c39">dr_get_os_version()</a> </p>

</div>
</div>
<a class="anchor" id="ab855db7dce02dc18831280f19df840cf"></a><!-- doxytag: member="dr_tools.h::module_handle_t" ref="ab855db7dce02dc18831280f19df840cf" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void* <a class="el" href="dr__tools_8h.html#ab855db7dce02dc18831280f19df840cf">module_handle_t</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Type used for <a class="el" href="dr__tools_8h.html#a8da7923ecc4e020e31442bcc8d9f8d3e">dr_get_proc_address()</a>. This can be obtained from the <a class="el" href="struct__module__data__t.html">_module_data_t</a> structure. It is equivalent to the base address of the module on both Windows and Linux. </p>

</div>
</div>
<a class="anchor" id="a8d2fef062beef2b521283369e0108282"></a><!-- doxytag: member="dr_tools.h::module_names_t" ref="a8d2fef062beef2b521283369e0108282" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="struct__module__names__t.html">_module_names_t</a>  <a class="el" href="struct__module__names__t.html">module_names_t</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Holds the names of a module. This structure contains multiple fields corresponding to different sources of a module name. Note that some of these names may not exist for certain modules. It is highly likely, however, that at least one name is available. Use <a class="el" href="dr__tools_8h.html#a082fe71b00688310237fbc2e027c4388">dr_module_preferred_name()</a> on the parent <a class="el" href="struct__module__data__t.html">_module_data_t</a> to get the preferred name of the module. </p>

</div>
</div>
<a class="anchor" id="ab49d9cfe4b0a8495532e5e4189515e83"></a><!-- doxytag: member="dr_tools.h::module_segment_data_t" ref="ab49d9cfe4b0a8495532e5e4189515e83" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="struct__module__segment__data__t.html">_module_segment_data_t</a>  <a class="el" href="struct__module__segment__data__t.html">module_segment_data_t</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Holds information on a segment of a loaded module. </p>

</div>
</div>
<a class="anchor" id="a99aca5de3a975309ebf0f24cfe42c1e8"></a><!-- doxytag: member="dr_tools.h::tracedump_file_header_t" ref="a99aca5de3a975309ebf0f24cfe42c1e8" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="struct__tracedump__file__header__t.html">_tracedump_file_header_t</a>  <a class="el" href="struct__tracedump__file__header__t.html">tracedump_file_header_t</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<pre>
 Binary trace dump format:
 the file starts with a tracedump_file_header_t
 then, for each trace:
     struct _tracedump_trace_header
     if num_bbs &gt; 0 # tracedump_origins
       foreach bb:
           app_pc tag;
           int bb_code_size;
           byte code[bb_code_size];
     endif
     foreach exit:
       struct <a class="el" href="struct__tracedump__stub__data.html">_tracedump_stub_data</a>
       if linkcount_size &gt; 0
         linkcount_type_t count; # sizeof == linkcount_size
       endif
       if separate from body
       (i.e., exit_stub &lt; cache_start_pc || exit_stub &gt;= cache_start_pc+code_size):
           byte stub_code[15]; # all separate stubs are 15
       endif
     endfor
     byte code[code_size];
 if the -tracedump_threshold option (deprecated) was specified:
     int num_below_treshold
     linkcount_type_t count_below_threshold
   endif
</pre> 
</div>
</div>
<a class="anchor" id="afbec914b027f98ee51e888671aac55f0"></a><!-- doxytag: member="dr_tools.h::tracedump_stub_data_t" ref="afbec914b027f98ee51e888671aac55f0" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="struct__tracedump__stub__data.html">_tracedump_stub_data</a>  <a class="el" href="struct__tracedump__stub__data.html">tracedump_stub_data_t</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>The format of a stub in a trace dump file. </p>

</div>
</div>
<a class="anchor" id="a3fe0415406026b8daf538ab6ac31519d"></a><!-- doxytag: member="dr_tools.h::tracedump_trace_header_t" ref="a3fe0415406026b8daf538ab6ac31519d" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="struct__tracedump__trace__header__t.html">_tracedump_trace_header_t</a>  <a class="el" href="struct__tracedump__trace__header__t.html">tracedump_trace_header_t</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Header for an individual trace in a binary trace dump file. </p>

</div>
</div>
<a class="anchor" id="aee552e6017b95b4708435b9467223d98"></a><!-- doxytag: member="dr_tools.h::version_number_t" ref="aee552e6017b95b4708435b9467223d98" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef union <a class="el" href="union__version__number__t.html">_version_number_t</a>  <a class="el" href="union__version__number__t.html">version_number_t</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Used to hold .rsrc section version number information. This number is usually presented as p1.p2.p3.p4 by PE parsing tools. </p>

</div>
</div>
<hr/><h2>Enumeration Type Documentation</h2>
<a class="anchor" id="aff97be516bbb1aecdb6bd043841aaa10"></a><!-- doxytag: member="dr_tools.h::dr_mem_type_t" ref="aff97be516bbb1aecdb6bd043841aaa10" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="dr__tools_8h.html#aff97be516bbb1aecdb6bd043841aaa10">dr_mem_type_t</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Flags describing memory used by <a class="el" href="dr__tools_8h.html#a5a6e4049f8accbc73ec5dbaf0deb25a7">dr_query_memory_ex()</a>. </p>
<dl><dt><b>Enumerator: </b></dt><dd><table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" id="aff97be516bbb1aecdb6bd043841aaa10a60e91c7b948d92d08b74ee0cd50dee3d"></a><!-- doxytag: member="DR_MEMTYPE_FREE" ref="aff97be516bbb1aecdb6bd043841aaa10a60e91c7b948d92d08b74ee0cd50dee3d" args="" -->DR_MEMTYPE_FREE</em>&nbsp;</td><td>
<p>No memory is allocated here </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="aff97be516bbb1aecdb6bd043841aaa10a6edf083337f9c953747a2cf4461dcbf7"></a><!-- doxytag: member="DR_MEMTYPE_IMAGE" ref="aff97be516bbb1aecdb6bd043841aaa10a6edf083337f9c953747a2cf4461dcbf7" args="" -->DR_MEMTYPE_IMAGE</em>&nbsp;</td><td>
<p>An executable file is mapped here </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="aff97be516bbb1aecdb6bd043841aaa10ac0350de0d08726ea8a5a5f02bb7010b0"></a><!-- doxytag: member="DR_MEMTYPE_DATA" ref="aff97be516bbb1aecdb6bd043841aaa10ac0350de0d08726ea8a5a5f02bb7010b0" args="" -->DR_MEMTYPE_DATA</em>&nbsp;</td><td>
<p>Some other data is allocated here </p>
</td></tr>
</table>
</dd>
</dl>

</div>
</div>
<a class="anchor" id="a311ab26d3bdc2d6ff7830b6f3ae9760c"></a><!-- doxytag: member="dr_tools.h::dr_os_version_t" ref="a311ab26d3bdc2d6ff7830b6f3ae9760c" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="dr__tools_8h.html#a311ab26d3bdc2d6ff7830b6f3ae9760c">dr_os_version_t</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Windows versions </p>
<dl><dt><b>Enumerator: </b></dt><dd><table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" id="a311ab26d3bdc2d6ff7830b6f3ae9760caf960b684d92226cd35590c2804c8dfa6"></a><!-- doxytag: member="DR_WINDOWS_VERSION_2003" ref="a311ab26d3bdc2d6ff7830b6f3ae9760caf960b684d92226cd35590c2804c8dfa6" args="" -->DR_WINDOWS_VERSION_2003</em>&nbsp;</td><td>
<p>64-bit XP is this version as well </p>
</td></tr>
</table>
</dd>
</dl>

</div>
</div>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="a818524883cd69709fe0e3499d6748d14"></a><!-- doxytag: member="dr_tools.h::__wrap_calloc" ref="a818524883cd69709fe0e3499d6748d14" args="(size_t nmemb, size_t size)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* __wrap_calloc </td>
          <td>(</td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>nmemb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>size</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Allocates memory from DR's global memory pool, but mimics the behavior of calloc. Memory must be freed with <a class="el" href="dr__tools_8h.html#a82dca5b3d5bfbd3de8891502badd861e">__wrap_free()</a>. The __wrap routines are intended to be used with ld's -wrap option; see <a class="el" href="dr__tools_8h.html#a3687f50774c89e7a09833a71adbb7771">__wrap_malloc()</a> for more information. </p>
<dl class="note"><dt><b>Note:</b></dt><dd>Currently Linux only. </dd></dl>

</div>
</div>
<a class="anchor" id="a82dca5b3d5bfbd3de8891502badd861e"></a><!-- doxytag: member="dr_tools.h::__wrap_free" ref="a82dca5b3d5bfbd3de8891502badd861e" args="(void *mem)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void __wrap_free </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>mem</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Frees memory from DR's global memory pool. Memory must have been allocated with <a class="el" href="dr__tools_8h.html#a3687f50774c89e7a09833a71adbb7771">__wrap_malloc()</a>. The __wrap routines are intended to be used with ld's -wrap option; see <a class="el" href="dr__tools_8h.html#a3687f50774c89e7a09833a71adbb7771">__wrap_malloc()</a> for more information. </p>
<dl class="note"><dt><b>Note:</b></dt><dd>Currently Linux only. </dd></dl>

</div>
</div>
<a class="anchor" id="a3687f50774c89e7a09833a71adbb7771"></a><!-- doxytag: member="dr_tools.h::__wrap_malloc" ref="a3687f50774c89e7a09833a71adbb7771" args="(size_t size)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* __wrap_malloc </td>
          <td>(</td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>size</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Allocates memory from DR's global memory pool, but mimics the behavior of malloc. Memory must be freed with <a class="el" href="dr__tools_8h.html#a82dca5b3d5bfbd3de8891502badd861e">__wrap_free()</a>. The __wrap routines are intended to be used with ld's -wrap option to replace a client's use of malloc, realloc, and free with internal versions that allocate memory from DR's private pool. With -wrap, clients can link to libraries that allocate heap memory without interfering with application allocations. </p>
<dl class="note"><dt><b>Note:</b></dt><dd>Currently Linux only. </dd></dl>

</div>
</div>
<a class="anchor" id="adcaad79adf4fc109015dd6a2d49b9031"></a><!-- doxytag: member="dr_tools.h::__wrap_realloc" ref="adcaad79adf4fc109015dd6a2d49b9031" args="(void *mem, size_t size)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* __wrap_realloc </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>mem</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>size</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Reallocates memory from DR's global memory pool, but mimics the behavior of realloc. Memory must be freed with <a class="el" href="dr__tools_8h.html#a82dca5b3d5bfbd3de8891502badd861e">__wrap_free()</a>. The __wrap routines are intended to be used with ld's -wrap option; see <a class="el" href="dr__tools_8h.html#a3687f50774c89e7a09833a71adbb7771">__wrap_malloc()</a> for more information. </p>
<dl class="note"><dt><b>Note:</b></dt><dd>Currently Linux only. </dd></dl>

</div>
</div>
<a class="anchor" id="a12c1ca981b7d3049cb2d31c0f19da332"></a><!-- doxytag: member="dr_tools.h::dr_abort" ref="a12c1ca981b7d3049cb2d31c0f19da332" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dr_abort </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Aborts the process immediately. </p>

</div>
</div>
<a class="anchor" id="acd67a10cd03a382853a0523bde9990f5"></a><!-- doxytag: member="dr_tools.h::dr_app_pc_for_decoding" ref="acd67a10cd03a382853a0523bde9990f5" args="(app_pc pc)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">app_pc dr_app_pc_for_decoding </td>
          <td>(</td>
          <td class="paramtype">app_pc&nbsp;</td>
          <td class="paramname"> <em>pc</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Given an application PC, returns a PC that contains the application code corresponding to the original PC. In some circumstances on Windows DR inserts a jump on top of the original code, which the client will not see in the bb and trace hooks due to DR replacing it there with the displaced original application code in order to present the client with an unmodified view of the application code. A client should use this routine when attempting to decode the original application instruction that caused a fault from the translated fault address, as the translated address may actually point in the middle of DR's jump.</p>
<dl class="note"><dt><b>Note:</b></dt><dd>Other applications on the system sometimes insert their own hooks, which will not be hidden by DR and will appear to the client as jumps and subsequent displaced code. </dd></dl>

</div>
</div>
<a class="anchor" id="ac150776be7e338321cbb8edc49ab7790"></a><!-- doxytag: member="dr_tools.h::dr_app_pc_from_cache_pc" ref="ac150776be7e338321cbb8edc49ab7790" args="(byte *cache_pc)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">app_pc dr_app_pc_from_cache_pc </td>
          <td>(</td>
          <td class="paramtype">byte *&nbsp;</td>
          <td class="paramname"> <em>cache_pc</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Given a code cache pc, returns the corresponding application pc. This involves translating the state and thus may incur calls to the basic block and trace events (see <a class="el" href="dr__events_8h.html#a043a3588c4cf0c2d6838140fce530e72">dr_register_bb_event()</a>). If translation fails, returns NULL. </p>

</div>
</div>
<a class="anchor" id="aad3b09e886366ac10341e69a577555dd"></a><!-- doxytag: member="dr_tools.h::dr_bb_exists_at" ref="aad3b09e886366ac10341e69a577555dd" args="(void *drcontext, void *tag)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool dr_bb_exists_at </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>drcontext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>tag</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Returns true if a basic block with tag <code>tag</code> exists in the code cache. </p>

</div>
</div>
<a class="anchor" id="af57b95b87d8da29a16ca923a5b1b98b3"></a><!-- doxytag: member="dr_tools.h::dr_client_thread_set_suspendable" ref="af57b95b87d8da29a16ca923a5b1b98b3" args="(bool suspendable)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool dr_client_thread_set_suspendable </td>
          <td>(</td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>suspendable</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Can only be called from a client thread: returns false if called from a non-client thread.</p>
<p>Controls whether a client thread created with <a class="el" href="dr__tools_8h.html#ac6b80b83502ff13d4674b13e7b30b555">dr_create_client_thread()</a> will be suspended by DR for synchronization operations such as flushing or client requests like <a class="el" href="dr__tools_8h.html#a01fbe357fcc8352ba63c9a1a23e0c207">dr_suspend_all_other_threads()</a>. A client thread that spends a lot of time holding locks can gain greater performance by not being suspended.</p>
<p>A client thread <b>will</b> be suspended for a thread termination operation, including at process exit, regardless of its suspendable requests. </p>

</div>
</div>
<a class="anchor" id="ac25b305e0be9f6c09f9761b14f3bbc74"></a><!-- doxytag: member="dr_tools.h::dr_close_file" ref="ac25b305e0be9f6c09f9761b14f3bbc74" args="(file_t f)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dr_close_file </td>
          <td>(</td>
          <td class="paramtype">file_t&nbsp;</td>
          <td class="paramname"> <em>f</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Closes file <code>f</code>. </p>

</div>
</div>
<a class="anchor" id="a8c99a2d79ed312cd852d57e975601adc"></a><!-- doxytag: member="dr_tools.h::dr_copy_module_data" ref="a8c99a2d79ed312cd852d57e975601adc" args="(const module_data_t *data)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct__module__data__t.html">module_data_t</a>* dr_copy_module_data </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct__module__data__t.html">module_data_t</a> *&nbsp;</td>
          <td class="paramname"> <em>data</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Makes a copy of <code>data</code>. Copy must be freed with <a class="el" href="dr__tools_8h.html#ad72ba1e8b98c8e01f2c28ef2e4d3e16e">dr_free_module_data()</a>. Useful for making persistent copies of module_data_t's received as part of image load and unload event callbacks. </p>

</div>
</div>
<a class="anchor" id="ac6b80b83502ff13d4674b13e7b30b555"></a><!-- doxytag: member="dr_tools.h::dr_create_client_thread" ref="ac6b80b83502ff13d4674b13e7b30b555" args="(void(*func)(void *param), void *arg)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool dr_create_client_thread </td>
          <td>(</td>
          <td class="paramtype">void(*)(void *param)&nbsp;</td>
          <td class="paramname"> <em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>arg</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Creates a new thread that is marked as a non-application thread (i.e., DR will let it run natively and not execute its code from the code cache). The thread will terminate automatically simply by returning from <code>func</code>; if running when the application terminates its last thread, the client thread will also terminate when DR shuts the process down.</p>
<p>Init and exit events will not be raised for this thread (instead simply place init and exit code in <code>func</code>).</p>
<p>The new client thread has a drcontext that can be used for thread-private heap allocations. It has a stack of the same size as the DR stack used by application threads.</p>
<p>On Linux, this thread is guaranteed to have its own private itimer if <a class="el" href="dr__tools_8h.html#a9191c67a267070ed51289d7192f986aa">dr_set_itimer()</a> is called from it. However this does mean it will have its own process id.</p>
<p>A client thread should refrain from spending most of its time in calls to other libraries or making blocking or long-running system calls as such actions may incur performance or correctness problems with DR's synchronization engine, which needs to be able to suspend client threads at safe points and cannot determine whether the aforementioned actions are safe for suspension. Calling <a class="el" href="dr__tools_8h.html#af154e498d8b185931ef970676cb65351">dr_sleep()</a>, <a class="el" href="dr__tools_8h.html#ac262422c1e5e487113176bd4193c387f">dr_thread_yield()</a>, <a class="el" href="dr__tools_8h.html#ad444a204e7ca45f9965cfe973470375a">dr_messagebox()</a>, or using DR's locks are safe. If a client thread spends a lot of time holding locks, consider marking it as un-suspendable by calling <a class="el" href="dr__tools_8h.html#af57b95b87d8da29a16ca923a5b1b98b3">dr_client_thread_set_suspendable()</a> for better performance.</p>
<p>Client threads, whether suspendable or not, must never execute from the code cache as the underlying fragments might be removed by another thread.</p>
<dl class="note"><dt><b>Note:</b></dt><dd>Thread creation via this routine is not yet fully transparent: on Windows, the thread will show up in the list of application threads if the operating system is queried about threads. The thread will not trigger a DLL_THREAD_ATTACH message. On Linux, the thread will not receive signals meant for the application, and is guaranteed to have a private itimer. </dd></dl>

</div>
</div>
<a class="anchor" id="a1ee2651cad7bafe65f3df7d4aeb82120"></a><!-- doxytag: member="dr_tools.h::dr_create_dir" ref="a1ee2651cad7bafe65f3df7d4aeb82120" args="(const char *fname)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool dr_create_dir </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>fname</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Creates a new directory. Fails if the directory already exists or if it can't be created. </p>

</div>
</div>
<a class="anchor" id="afa5ea6649e644074ca55f456c89264e8"></a><!-- doxytag: member="dr_tools.h::dr_delay_flush_region" ref="afa5ea6649e644074ca55f456c89264e8" args="(app_pc start, size_t size, uint flush_id, void(*flush_completion_callback)(int flush_id))" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool dr_delay_flush_region </td>
          <td>(</td>
          <td class="paramtype">app_pc&nbsp;</td>
          <td class="paramname"> <em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&nbsp;</td>
          <td class="paramname"> <em>flush_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(*)(int flush_id)&nbsp;</td>
          <td class="paramname"> <em>flush_completion_callback</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Request a flush of all fragments containing code from the region [<code>start</code>, <code>start</code> + <code>size</code>). The flush will be performed at the next safe point in time (usually before any new code is added to the cache after this routine is called). If <code>flush_completion_callback</code> is non-NULL, it will be called with the <code>flush_id</code> provided to this routine when the flush completes, after which no execution will occur out of the fragments flushed. Returns true if the flush was successfully queued.</p>
<dl class="note"><dt><b>Note:</b></dt><dd><a class="el" href="dr__tools_8h.html#abe87d17869a51a66d59eecf459d71cc0">dr_flush_region()</a> and <a class="el" href="dr__tools_8h.html#a56909cf76e4a71fca13731053ef48928">dr_unlink_flush_region()</a> can give stronger guarantees on when the flush will occur, but have more restrictions on use. </dd>
<dd>
Use <code>size</code> == 1 to flush fragments containing the instruction at address <code>start</code>. A flush of <code>size</code> == 0 is not allowed. </dd>
<dd>
As currently implemented there may be a performance penalty for requesting a <code>flush_completion_callback</code>; for most performant usage set <code>flush_completion_callback</code> to NULL. </dd></dl>

</div>
</div>
<a class="anchor" id="a7ce7b5b2390cb5e03466cd605735bdfc"></a><!-- doxytag: member="dr_tools.h::dr_delete_file" ref="a7ce7b5b2390cb5e03466cd605735bdfc" args="(const char *filename)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool dr_delete_file </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>filename</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Deletes the file referred to by <code>filename</code>. Returns true if successful. On both Linux and Windows, if filename refers to a symlink, the symlink will be deleted and not the target of the symlink. On Windows, this will fail to delete any file was not opened with FILE_SHARE_DELETE and is still open. </p>

</div>
</div>
<a class="anchor" id="a7600cc31d68dc0e30ab91261d08836ed"></a><!-- doxytag: member="dr_tools.h::dr_delete_fragment" ref="a7600cc31d68dc0e30ab91261d08836ed" args="(void *drcontext, void *tag)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool dr_delete_fragment </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>drcontext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>tag</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Deletes the fragment with tag <code>tag</code>. This routine is only valid with the -thread_private option; it deletes the fragment in the current thread only. After deletion, the existing fragment is allowed to complete execution. For example, a clean call deleting the currently executing fragment will safely return to the existing code. Subsequent executions will cause DynamoRIO to reconstruct the fragment, and therefore call the appropriate fragment-creation event hook, if registered.</p>
<dl class="note"><dt><b>Note:</b></dt><dd>This routine supports deletion for the current thread only. <code>drcontext</code> must be from the current thread and must be the drcontext used to create the instruction list.</dd></dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>false if the fragment does not exist and true otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="a02f86a68a105442a029baa05a1af9d57"></a><!-- doxytag: member="dr_tools.h::dr_directory_exists" ref="a02f86a68a105442a029baa05a1af9d57" args="(const char *fname)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool dr_directory_exists </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>fname</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Checks for the existence of a directory. </p>

</div>
</div>
<a class="anchor" id="a66ef4b43d78d787c7622569d30717051"></a><!-- doxytag: member="dr_tools.h::dr_dup_file_handle" ref="a66ef4b43d78d787c7622569d30717051" args="(file_t f)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">file_t dr_dup_file_handle </td>
          <td>(</td>
          <td class="paramtype">file_t&nbsp;</td>
          <td class="paramname"> <em>f</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Returns a new copy of the file handle <code>f</code>. Returns INVALID_FILE on error. </p>

</div>
</div>
<a class="anchor" id="a712de67b3f6adb6778ce302925009753"></a><!-- doxytag: member="dr_tools.h::dr_enable_console_printing" ref="a712de67b3f6adb6778ce302925009753" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool dr_enable_console_printing </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Enables <a class="el" href="dr__tools_8h.html#abad2eddb3786e3e909ff36da39b7e31e">dr_printf()</a> and <a class="el" href="dr__tools_8h.html#afe7ede5b10890505021ac03e8f9ba97f">dr_fprintf()</a> to work with a console window (viz., <code>cmd</code>). Loads a private copy of kernel32.dll (if not already loaded) in order to accomplish this. To keep the default DR lean and mean, loading kernel32.dll is not performed by default.</p>
<p>This routine must be called during client initialization (<code><a class="el" href="dr__api_8h.html#a20a4dc9da7f6bb9121e30bb3570c6961">dr_init()</a></code>). If called later, it will fail.</p>
<p>Without calling this routine, <a class="el" href="dr__tools_8h.html#abad2eddb3786e3e909ff36da39b7e31e">dr_printf()</a> and <a class="el" href="dr__tools_8h.html#afe7ede5b10890505021ac03e8f9ba97f">dr_fprintf()</a> will not print anything in a console window.</p>
<p>Even after calling this routine, there are significant limitations to console printing support in DR:</p>
<ul>
<li>On Windows versions from Vista onward, it does not work for 64-bit applications.</li>
<li>On Windows versions prior to Vista, it does not work from the exit event. Once the application terminates its state with csrss (toward the very end of ExitProcess), no output will show up on the console. We have no good solution here yet as exiting early is not ideal.</li>
<li>It does not work at all from graphical applications, even when they are launched from a console.</li>
<li>In the future, with earliest injection (Issue 234), writing to the console may not work from the client init event.</li>
</ul>
<p>These limitations stem from the complex arrangement of the console window in Windows, where printing to it involves sending a message in an undocumented format to the <code>csrss</code> process, rather than a simple write to a file handle. We recommend using a terminal window such as cygwin's <code>rxvt</code> rather than the <code>cmd</code> window, or alternatively redirecting all output to a file, which will solve all of the above limitations.</p>
<p>Returns whether successful. </p>

</div>
</div>
<a class="anchor" id="af471633d0954d80c09ca6c2bfe40475b"></a><!-- doxytag: member="dr_tools.h::dr_file_exists" ref="af471633d0954d80c09ca6c2bfe40475b" args="(const char *fname)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool dr_file_exists </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>fname</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Checks the existence of a file. </p>

</div>
</div>
<a class="anchor" id="a18c2c9d68ceceef8c6455b06502667ee"></a><!-- doxytag: member="dr_tools.h::dr_file_seek" ref="a18c2c9d68ceceef8c6455b06502667ee" args="(file_t f, int64 offset, int origin)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool dr_file_seek </td>
          <td>(</td>
          <td class="paramtype">file_t&nbsp;</td>
          <td class="paramname"> <em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64&nbsp;</td>
          <td class="paramname"> <em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>origin</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Sets the current file position for file <code>f</code> to <code>offset</code> bytes from the specified origin, where <code>origin</code> is one of the DR_SEEK_* values. Returns true if successful. </p>

</div>
</div>
<a class="anchor" id="a06a8173579db03d018935afb1ca891f6"></a><!-- doxytag: member="dr_tools.h::dr_file_size" ref="a06a8173579db03d018935afb1ca891f6" args="(file_t fd, OUT uint64 *size)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool dr_file_size </td>
          <td>(</td>
          <td class="paramtype">file_t&nbsp;</td>
          <td class="paramname"> <em>fd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OUT uint64 *&nbsp;</td>
          <td class="paramname"> <em>size</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Determines the size of the file <code>fd</code>. On success, returns the size in <code>size</code>. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>whether successful. </dd></dl>

</div>
</div>
<a class="anchor" id="a1fc1d26f3050d6f361e7b07f98c7e82d"></a><!-- doxytag: member="dr_tools.h::dr_file_tell" ref="a1fc1d26f3050d6f361e7b07f98c7e82d" args="(file_t f)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int64 dr_file_tell </td>
          <td>(</td>
          <td class="paramtype">file_t&nbsp;</td>
          <td class="paramname"> <em>f</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Returns the current position for the file <code>f</code> in bytes from the start of the file. Returns -1 on an error. </p>

</div>
</div>
<a class="anchor" id="ae51098d1c742e3189a197db0c212eaa9"></a><!-- doxytag: member="dr_tools.h::dr_flush_file" ref="ae51098d1c742e3189a197db0c212eaa9" args="(file_t f)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dr_flush_file </td>
          <td>(</td>
          <td class="paramtype">file_t&nbsp;</td>
          <td class="paramname"> <em>f</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Flushes any buffers for file <code>f</code>. </p>

</div>
</div>
<a class="anchor" id="abe87d17869a51a66d59eecf459d71cc0"></a><!-- doxytag: member="dr_tools.h::dr_flush_region" ref="abe87d17869a51a66d59eecf459d71cc0" args="(app_pc start, size_t size)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool dr_flush_region </td>
          <td>(</td>
          <td class="paramtype">app_pc&nbsp;</td>
          <td class="paramname"> <em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>size</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Flush all fragments containing any code from the region [<code>start</code>, <code>start</code> + <code>size</code>). Once this routine returns no execution will occur out of the fragments flushed. This routine may only be called during a clean call from the cache, from a nudge event handler, or from a pre- or post-system call event handler. It may not be called from any other event callback. No locks can held when calling this routine. If called from a clean call, caller can NOT return to the cache (the fragment that was called out of may have been flushed even if it doesn't apparently overlap the flushed region). Instead the caller must call <a class="el" href="dr__ir__utils_8h.html#a9f612cf9d0ca2025b23d30b6f5bb0231">dr_redirect_execution()</a> after this routine to continue execution. Returns true if successful.</p>
<dl class="note"><dt><b>Note:</b></dt><dd>This routine may not be called from any registered event callback other than the nudge event or the pre- or post-system call event; clean calls out of the cache may call this routine.</dd>
<dd>
If called from a clean call, caller must continue execution by calling <a class="el" href="dr__ir__utils_8h.html#a9f612cf9d0ca2025b23d30b6f5bb0231">dr_redirect_execution()</a> after this routine, as the fragment containing the callout may have been flushed. The context to use can be obtained via <a class="el" href="dr__ir__utils_8h.html#a91ffde2808c16e07f323c34affa72209">dr_get_mcontext()</a> with the exception of the pc to continue at which must be passed as an argument to the callout (see <a class="el" href="dr__ir__instr_8h.html#a57dbc129ab88dfdcf49f1105eba394a7">instr_get_app_pc()</a>) or otherwise determined.</dd>
<dd>
This routine may not be called while any locks are held that could block a thread processing a registered event callback or cache callout.</dd>
<dd>
<a class="el" href="dr__tools_8h.html#afa5ea6649e644074ca55f456c89264e8">dr_delay_flush_region()</a> has fewer restrictions on use, but is less synchronous.</dd>
<dd>
Use <code>size</code> == 1 to flush fragments containing the instruction at address <code>start</code>. A flush of <code>size</code> == 0 is not allowed.</dd>
<dd>
As currently implemented, <a class="el" href="dr__tools_8h.html#afa5ea6649e644074ca55f456c89264e8">dr_delay_flush_region()</a> with no completion callback routine specified can be substantially more performant. </dd></dl>

</div>
</div>
<a class="anchor" id="afe7ede5b10890505021ac03e8f9ba97f"></a><!-- doxytag: member="dr_tools.h::dr_fprintf" ref="afe7ede5b10890505021ac03e8f9ba97f" args="(file_t f, const char *fmt,...)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dr_fprintf </td>
          <td>(</td>
          <td class="paramtype">file_t&nbsp;</td>
          <td class="paramname"> <em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>fmt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname"> <em>...</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Printing to a file that won't interfere with the application's own printing. Currently non-buffered. </p>
<dl class="note"><dt><b>Note:</b></dt><dd>On Windows, this routine is not able to print to STDOUT or STDERR in the <code>cmd</code> window unless <a class="el" href="dr__tools_8h.html#a712de67b3f6adb6778ce302925009753">dr_enable_console_printing()</a> is called ahead of time, and even then there are limitations: see <a class="el" href="dr__tools_8h.html#a712de67b3f6adb6778ce302925009753">dr_enable_console_printing()</a>. </dd>
<dd>
On Windows, this routine does not support printing floating point values. Use <a class="el" href="dr__tools_8h.html#ab0c5f2529d9c076b5b0b0e92a70834b7">dr_snprintf()</a> instead. </dd>
<dd>
If the data to be printed is large it will be truncated to an internal buffer size. Use <a class="el" href="dr__tools_8h.html#ab0c5f2529d9c076b5b0b0e92a70834b7">dr_snprintf()</a> and <a class="el" href="dr__tools_8h.html#aeddf708cc2271dc50209b3e78e1d23fb">dr_write_file()</a> for large output. </dd>
<dd>
On Linux this routine does not check for errors like EINTR. Use <a class="el" href="dr__tools_8h.html#aeddf708cc2271dc50209b3e78e1d23fb">dr_write_file()</a> if that is a concern. </dd>
<dd>
When printing floating-point values, the caller's code should use <a class="el" href="dr__proc_8h.html#a4a11c9d5d127ce126562ad35b4d165dd">proc_save_fpstate()</a> or be inside a clean call that has requested to preserve the floating-point state. </dd></dl>

</div>
</div>
<a class="anchor" id="a724aa7f7e87a604071fffa0a01925bf0"></a><!-- doxytag: member="dr_tools.h::dr_fragment_app_pc" ref="a724aa7f7e87a604071fffa0a01925bf0" args="(void *tag)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">app_pc dr_fragment_app_pc </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>tag</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Retrieves the application PC of a fragment with tag <code>tag</code>. </p>

</div>
</div>
<a class="anchor" id="a775fdf1d5a55b5fbca094a4d2f18d28f"></a><!-- doxytag: member="dr_tools.h::dr_fragment_exists_at" ref="a775fdf1d5a55b5fbca094a4d2f18d28f" args="(void *drcontext, void *tag)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool dr_fragment_exists_at </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>drcontext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>tag</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Returns whether or not there is a fragment in code cache with tag <code>tag</code>. </p>

</div>
</div>
<a class="anchor" id="acfe1f6436b234406bde1970ecfa614b5"></a><!-- doxytag: member="dr_tools.h::dr_fragment_size" ref="acfe1f6436b234406bde1970ecfa614b5" args="(void *drcontext, void *tag)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint dr_fragment_size </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>drcontext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>tag</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Looks up the fragment with tag <code>tag</code>. If not found, returns 0. If found, returns the total size occupied in the cache by the fragment. </p>

</div>
</div>
<a class="anchor" id="ad72ba1e8b98c8e01f2c28ef2e4d3e16e"></a><!-- doxytag: member="dr_tools.h::dr_free_module_data" ref="ad72ba1e8b98c8e01f2c28ef2e4d3e16e" args="(module_data_t *data)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dr_free_module_data </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct__module__data__t.html">module_data_t</a> *&nbsp;</td>
          <td class="paramname"> <em>data</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Frees a module_data_t returned by <a class="el" href="dr__tools_8h.html#a9d49edb3a7b59f5d817afaa8fc0f1ef9">dr_module_iterator_next()</a>, <a class="el" href="dr__tools_8h.html#a4892d089da710e952a23055bd7db38af">dr_lookup_module()</a>, <a class="el" href="dr__tools_8h.html#addd653edd3322cfb025ef8bdc6ae1060">dr_lookup_module_by_name()</a>, or <a class="el" href="dr__tools_8h.html#a8c99a2d79ed312cd852d57e975601adc">dr_copy_module_data()</a>. </p>
<dl class="note"><dt><b>Note:</b></dt><dd>Should NOT be used with a module_data_t obtained as part of a module load or unload event. </dd></dl>

</div>
</div>
<a class="anchor" id="a81037ee313844d4fbce3368f4421e5b4"></a><!-- doxytag: member="dr_tools.h::dr_get_app_PEB" ref="a81037ee313844d4fbce3368f4421e5b4" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* dr_get_app_PEB </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Returns a pointer to the application's Process Environment Block (PEB). DR swaps to a private PEB when running client code, in order to isolate the client and its dependent libraries from the application, so conventional methods of reading the PEB will obtain the private PEB instead of the application PEB. </p>

</div>
</div>
<a class="anchor" id="aace5e8084f523fd25871b31463c7ecda"></a><!-- doxytag: member="dr_tools.h::dr_get_application_name" ref="aace5e8084f523fd25871b31463c7ecda" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* dr_get_application_name </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Returns the image name (without path) of the current application. </p>

</div>
</div>
<a class="anchor" id="aae96ea91548daf1a0b5a78197bc86f07"></a><!-- doxytag: member="dr_tools.h::dr_get_client_base" ref="aae96ea91548daf1a0b5a78197bc86f07" args="(client_id_t client_id)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">byte* dr_get_client_base </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="dr__defines_8h.html#a68540a70b4f8150a4fe6dcec91bf8825">client_id_t</a>&nbsp;</td>
          <td class="paramname"> <em>client_id</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Returns the base address of the client library. <code>client_id</code> is the client ID passed to a client's <a class="el" href="dr__api_8h.html#a20a4dc9da7f6bb9121e30bb3570c6961">dr_init()</a> function. </p>

</div>
</div>
<a class="anchor" id="afb7d403eb032bd14ae78807ae3d59ea0"></a><!-- doxytag: member="dr_tools.h::dr_get_client_path" ref="afb7d403eb032bd14ae78807ae3d59ea0" args="(client_id_t client_id)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* dr_get_client_path </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="dr__defines_8h.html#a68540a70b4f8150a4fe6dcec91bf8825">client_id_t</a>&nbsp;</td>
          <td class="paramname"> <em>client_id</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Returns the client library name and path that were originally specified to load the library. If the resulting string is longer than <a class="el" href="dr__defines_8h.html#a95c7b582d53e0a376f2a0e89323b2a7b">MAXIMUM_PATH</a> it will be truncated. <code>client_id</code> is the client ID passed to a client's <a class="el" href="dr__api_8h.html#a20a4dc9da7f6bb9121e30bb3570c6961">dr_init()</a> function. </p>

</div>
</div>
<a class="anchor" id="a13217cc252506b06184c7c72adedf26c"></a><!-- doxytag: member="dr_tools.h::dr_get_current_drcontext" ref="a13217cc252506b06184c7c72adedf26c" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* dr_get_current_drcontext </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Returns the DR context of the current thread. </p>

</div>
</div>
<a class="anchor" id="a8d753cde7a82c612fcb0e1cdbc65fdf0"></a><!-- doxytag: member="dr_tools.h::dr_get_dr_segment_base" ref="a8d753cde7a82c612fcb0e1cdbc65fdf0" args="(IN reg_id_t segment_register)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* dr_get_dr_segment_base </td>
          <td>(</td>
          <td class="paramtype">IN reg_id_t&nbsp;</td>
          <td class="paramname"> <em>segment_register</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Get DR's segment base pointed at <code>segment_register</code>. It can be used to get the base of thread-local storage segment used by <a class="el" href="dr__tools_8h.html#a95b53d79cae021a473c39f3b2662323f">dr_raw_tls_calloc</a>.</p>
<dl class="note"><dt><b>Note:</b></dt><dd>It should not be called on thread exit event, as the thread exit event may be invoked from other threads. See <a class="el" href="dr__events_8h.html#a0b0c102bb9a99d67c3e62ea8b3790ff1">dr_register_thread_exit_event</a> for details. </dd></dl>

</div>
</div>
<a class="anchor" id="ab5cd85ea911bd99dedbd8d05796260bc"></a><!-- doxytag: member="dr_tools.h::dr_get_itimer" ref="ab5cd85ea911bd99dedbd8d05796260bc" args="(int which)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint dr_get_itimer </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>which</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>If an interval timer is already installed in the itimer sharing group that contains the calling thread, returns its frequency. Else returns 0.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>which</em>&nbsp;</td><td>Must be one of ITIMER_REAL, ITIMER_VIRTUAL, or ITIMER_PROF</td></tr>
  </table>
  </dd>
</dl>
<dl class="note"><dt><b>Note:</b></dt><dd>Linux-only. </dd></dl>

</div>
</div>
<a class="anchor" id="afd7e9d485a84aa147e0ec0e75ad6d962"></a><!-- doxytag: member="dr_tools.h::dr_get_logfile" ref="afd7e9d485a84aa147e0ec0e75ad6d962" args="(void *drcontext)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">file_t dr_get_logfile </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>drcontext</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Returns the log file for the thread with drcontext <code>drcontext</code>. If <code>drcontext</code> is NULL, returns the main log file. </p>

</div>
</div>
<a class="anchor" id="a4b187636a3fc9ba7964ae11a7fd30fb6"></a><!-- doxytag: member="dr_tools.h::dr_get_milliseconds" ref="a4b187636a3fc9ba7964ae11a7fd30fb6" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint64 dr_get_milliseconds </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>On Linux, returns the number of milliseconds since the Epoch (Jan 1, 1970). On Windows, returns the number of milliseconds since Jan 1, 1600 (this is the current UTC time). </p>

</div>
</div>
<a class="anchor" id="a10831623706378cfc3082c0e27e31c4c"></a><!-- doxytag: member="dr_tools.h::dr_get_options" ref="a10831623706378cfc3082c0e27e31c4c" args="(client_id_t client_id)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* dr_get_options </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="dr__defines_8h.html#a68540a70b4f8150a4fe6dcec91bf8825">client_id_t</a>&nbsp;</td>
          <td class="paramname"> <em>client_id</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Returns the client-specific option string specified at client registration. <code>client_id</code> is the client ID passed to <a class="el" href="dr__api_8h.html#a20a4dc9da7f6bb9121e30bb3570c6961">dr_init()</a>. </p>

</div>
</div>
<a class="anchor" id="abab30ef95ab36e4e885a9dc89f540c39"></a><!-- doxytag: member="dr_tools.h::dr_get_os_version" ref="abab30ef95ab36e4e885a9dc89f540c39" args="(dr_os_version_info_t *info)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool dr_get_os_version </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct__dr__os__version__info__t.html">dr_os_version_info_t</a> *&nbsp;</td>
          <td class="paramname"> <em>info</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Returns information about the version of the operating system. Returns whether successful. </p>

</div>
</div>
<a class="anchor" id="a11575b203a0558f5df50126ff04c4598"></a><!-- doxytag: member="dr_tools.h::dr_get_parent_id" ref="a11575b203a0558f5df50126ff04c4598" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">process_id_t dr_get_parent_id </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Returns the process id of the parent of the current process. </p>
<dl class="note"><dt><b>Note:</b></dt><dd>Linux only. </dd></dl>

</div>
</div>
<a class="anchor" id="a8da7923ecc4e020e31442bcc8d9f8d3e"></a><!-- doxytag: member="dr_tools.h::dr_get_proc_address" ref="a8da7923ecc4e020e31442bcc8d9f8d3e" args="(module_handle_t lib, const char *name)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">generic_func_t dr_get_proc_address </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="dr__tools_8h.html#ab855db7dce02dc18831280f19df840cf">module_handle_t</a>&nbsp;</td>
          <td class="paramname"> <em>lib</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>name</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Returns the entry point of the exported function with the given name in the module with the given base. Returns NULL on failure. </p>
<dl class="note"><dt><b>Note:</b></dt><dd>On Linux this ignores symbol preemption by other modules and only examines the specified module. </dd>
<dd>
On Linux, in order to handle indirect code objects, use <a class="el" href="dr__tools_8h.html#af1a068ad89408abbcfba026706810211">dr_get_proc_address_ex()</a>. </dd></dl>

</div>
</div>
<a class="anchor" id="af1a068ad89408abbcfba026706810211"></a><!-- doxytag: member="dr_tools.h::dr_get_proc_address_ex" ref="af1a068ad89408abbcfba026706810211" args="(module_handle_t lib, const char *name, dr_export_info_t *info OUT, size_t info_len)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool dr_get_proc_address_ex </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="dr__tools_8h.html#ab855db7dce02dc18831280f19df840cf">module_handle_t</a>&nbsp;</td>
          <td class="paramname"> <em>lib</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct__dr__export__info__t.html">dr_export_info_t</a> *info&nbsp;</td>
          <td class="paramname"> <em>OUT</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>info_len</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Returns information in <code>info</code> about the symbol <code>name</code> exported by the module <code>lib</code>. Returns false if the symbol is not found. </p>
<dl class="note"><dt><b>Note:</b></dt><dd>On Linux this ignores symbol preemption by other modules and only examines the specified module. </dd></dl>

</div>
</div>
<a class="anchor" id="a83b3658ca78e6b7adc81c57691f0fe50"></a><!-- doxytag: member="dr_tools.h::dr_get_process_id" ref="a83b3658ca78e6b7adc81c57691f0fe50" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">process_id_t dr_get_process_id </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Returns the process id of the current process. </p>

</div>
</div>
<a class="anchor" id="af3212441c8fd1642d6d1fb7850562106"></a><!-- doxytag: member="dr_tools.h::dr_get_random_seed" ref="af3212441c8fd1642d6d1fb7850562106" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint dr_get_random_seed </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Returns the seed used for <a class="el" href="dr__tools_8h.html#aeb3d12bdde33dd279f09bcb2a5bfd901">dr_get_random_value()</a>. </p>

</div>
</div>
<a class="anchor" id="aeb3d12bdde33dd279f09bcb2a5bfd901"></a><!-- doxytag: member="dr_tools.h::dr_get_random_value" ref="aeb3d12bdde33dd279f09bcb2a5bfd901" args="(uint max)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint dr_get_random_value </td>
          <td>(</td>
          <td class="paramtype">uint&nbsp;</td>
          <td class="paramname"> <em>max</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Returns a pseudo-random number in the range [0..max). The pseudo-random sequence can be repeated by passing the seed used during a run to the next run via the -prng_seed runtime option. </p>

</div>
</div>
<a class="anchor" id="a20dccb3e2b03e8f408b2a340c70a28e2"></a><!-- doxytag: member="dr_tools.h::dr_get_stderr_file" ref="a20dccb3e2b03e8f408b2a340c70a28e2" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">file_t dr_get_stderr_file </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Returns a handle to stderr. </p>

</div>
</div>
<a class="anchor" id="aed162d7ad949b05fe8232771eaeca6a9"></a><!-- doxytag: member="dr_tools.h::dr_get_stdin_file" ref="aed162d7ad949b05fe8232771eaeca6a9" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">file_t dr_get_stdin_file </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Returns a handle to stdin. </p>

</div>
</div>
<a class="anchor" id="a0353e78f517dc281de22539682d9e6d9"></a><!-- doxytag: member="dr_tools.h::dr_get_stdout_file" ref="a0353e78f517dc281de22539682d9e6d9" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">file_t dr_get_stdout_file </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Returns a handle to stdout. </p>

</div>
</div>
<a class="anchor" id="a3980d703cc13379a6b57396a7901b1d1"></a><!-- doxytag: member="dr_tools.h::dr_get_thread_id" ref="a3980d703cc13379a6b57396a7901b1d1" args="(void *drcontext)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">thread_id_t dr_get_thread_id </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>drcontext</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Returns the thread id of the thread with drcontext <code>drcontext</code>. </p>

</div>
</div>
<a class="anchor" id="ae517c4817d67af6ad92b8f1d7694080a"></a><!-- doxytag: member="dr_tools.h::dr_get_time" ref="ae517c4817d67af6ad92b8f1d7694080a" args="(dr_time_t *time)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dr_get_time </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdr__time__t.html">dr_time_t</a> *&nbsp;</td>
          <td class="paramname"> <em>time</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Retrieves the current time. </p>

</div>
</div>
<a class="anchor" id="a787aff5df1ded3de8a7ce9f3efef0594"></a><!-- doxytag: member="dr_tools.h::dr_get_tls_field" ref="a787aff5df1ded3de8a7ce9f3efef0594" args="(void *drcontext)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* dr_get_tls_field </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>drcontext</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Returns the user-controlled thread-local-storage field. To generate an instruction sequence that reads the drcontext field inline in the code cache, use <a class="el" href="dr__ir__utils_8h.html#a3831354cc7402d68719d8055fb3e9931">dr_insert_read_tls_field()</a>. </p>

</div>
</div>
<a class="anchor" id="a60faa40f7e8c819c34fd25cb367c5473"></a><!-- doxytag: member="dr_tools.h::dr_global_alloc" ref="a60faa40f7e8c819c34fd25cb367c5473" args="(size_t size)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* dr_global_alloc </td>
          <td>(</td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>size</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Allocates <code>size</code> bytes of memory from DR's global memory pool. </p>

</div>
</div>
<a class="anchor" id="ace8794210449c50fb4d411ad74a8dec1"></a><!-- doxytag: member="dr_tools.h::dr_global_free" ref="ace8794210449c50fb4d411ad74a8dec1" args="(void *mem, size_t size)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dr_global_free </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>mem</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>size</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Frees memory allocated by <a class="el" href="dr__tools_8h.html#a60faa40f7e8c819c34fd25cb367c5473">dr_global_alloc()</a>. <code>size</code> must be the same as that passed to <a class="el" href="dr__tools_8h.html#a60faa40f7e8c819c34fd25cb367c5473">dr_global_alloc()</a>. </p>

</div>
</div>
<a class="anchor" id="af91a810b83f1173a5720a955c3d0fd4a"></a><!-- doxytag: member="dr_tools.h::dr_is_notify_on" ref="af91a810b83f1173a5720a955c3d0fd4a" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool dr_is_notify_on </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Returns true iff the -stderr_mask runtime option is non-zero, indicating that the user wants notification messages printed to stderr. </p>

</div>
</div>
<a class="anchor" id="ac5804006579a63b49827169d3ffbebc8"></a><!-- doxytag: member="dr_tools.h::dr_is_wow64" ref="ac5804006579a63b49827169d3ffbebc8" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool dr_is_wow64 </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Returns true if this process is a 32-bit process operating on a 64-bit Windows kernel, known as Windows-On-Windows-64, or WOW64. Returns false otherwise. </p>

</div>
</div>
<a class="anchor" id="a94c8a2e52880f44d43402d6b0d686db2"></a><!-- doxytag: member="dr_tools.h::dr_load_aux_library" ref="a94c8a2e52880f44d43402d6b0d686db2" args="(const char *name, byte **lib_start, byte **lib_end)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="dr__tools_8h.html#ad4bb25312a86996379357f79a4c7c1c1">dr_auxlib_handle_t</a> dr_load_aux_library </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">byte **&nbsp;</td>
          <td class="paramname"> <em>lib_start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">byte **&nbsp;</td>
          <td class="paramname"> <em>lib_end</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Loads the library with the given path as an auxiliary client library. The library is not treated as an application module but as an extension of DR. The library will be included in <a class="el" href="dr__tools_8h.html#a2a67b03d64626f3d0a78b64bf096ed25">dr_memory_is_in_client()</a> and any faults in the library will be considered client faults. The bounds of the loaded library are returned in the optional out variables. On failure, returns NULL. </p>

</div>
</div>
<a class="anchor" id="a332a14861f12823994465e8c9b6a3015"></a><!-- doxytag: member="dr_tools.h::dr_log" ref="a332a14861f12823994465e8c9b6a3015" args="(void *drcontext, uint mask, uint level, const char *fmt,...)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dr_log </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>drcontext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&nbsp;</td>
          <td class="paramname"> <em>mask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&nbsp;</td>
          <td class="paramname"> <em>level</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>fmt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname"> <em>...</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Writes to DR's log file for the thread with drcontext <code>drcontext</code> if the current loglevel is &gt;= <code>level</code> and the current <code>logmask</code> &amp; <code>mask</code> != 0. The mask constants are below. Logging is disabled for the release build. If <code>drcontext</code> is NULL, writes to the main log file. </p>

</div>
</div>
<a class="anchor" id="a814a1a50cc288dc902f2a2dcef9812c6"></a><!-- doxytag: member="dr_tools.h::dr_lookup_aux_library_routine" ref="a814a1a50cc288dc902f2a2dcef9812c6" args="(dr_auxlib_handle_t lib, const char *name)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="dr__tools_8h.html#a9442b3e0a17431ef00a90ffc0c956224">dr_auxlib_routine_ptr_t</a> dr_lookup_aux_library_routine </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="dr__tools_8h.html#ad4bb25312a86996379357f79a4c7c1c1">dr_auxlib_handle_t</a>&nbsp;</td>
          <td class="paramname"> <em>lib</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>name</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Looks up the exported routine with the given name in the given client auxiliary library loaded by <a class="el" href="dr__tools_8h.html#a94c8a2e52880f44d43402d6b0d686db2">dr_load_aux_library()</a>. Returns NULL on failure. </p>

</div>
</div>
<a class="anchor" id="a4892d089da710e952a23055bd7db38af"></a><!-- doxytag: member="dr_tools.h::dr_lookup_module" ref="a4892d089da710e952a23055bd7db38af" args="(byte *pc)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct__module__data__t.html">module_data_t</a>* dr_lookup_module </td>
          <td>(</td>
          <td class="paramtype">byte *&nbsp;</td>
          <td class="paramname"> <em>pc</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Looks up the module containing <code>pc</code>. If a module containing <code>pc</code> is found returns a module_data_t describing that module else returns NULL. Can be used to obtain a module_handle_t for <a class="el" href="dr__tools_8h.html#ac520aa05555ecbf9e525de582d4baa8c">dr_lookup_module_section()</a>. </p>
<dl class="note"><dt><b>Note:</b></dt><dd>Returned module_data_t must be freed with <a class="el" href="dr__tools_8h.html#ad72ba1e8b98c8e01f2c28ef2e4d3e16e">dr_free_module_data()</a>. </dd></dl>

</div>
</div>
<a class="anchor" id="addd653edd3322cfb025ef8bdc6ae1060"></a><!-- doxytag: member="dr_tools.h::dr_lookup_module_by_name" ref="addd653edd3322cfb025ef8bdc6ae1060" args="(const char *name)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct__module__data__t.html">module_data_t</a>* dr_lookup_module_by_name </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>name</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Looks up the module with name <code>name</code> ignoring case. If an exact name match is found returns a module_data_t describing that module else returns NULL. User must call <a class="el" href="dr__tools_8h.html#ad72ba1e8b98c8e01f2c28ef2e4d3e16e">dr_free_module_data()</a> on the returned module_data_t once finished. Can be used to obtain a module_handle_t for <a class="el" href="dr__tools_8h.html#a8da7923ecc4e020e31442bcc8d9f8d3e">dr_get_proc_address()</a>. </p>
<dl class="note"><dt><b>Note:</b></dt><dd>Returned module_data_t must be freed with <a class="el" href="dr__tools_8h.html#ad72ba1e8b98c8e01f2c28ef2e4d3e16e">dr_free_module_data()</a>. </dd></dl>

</div>
</div>
<a class="anchor" id="ac520aa05555ecbf9e525de582d4baa8c"></a><!-- doxytag: member="dr_tools.h::dr_lookup_module_section" ref="ac520aa05555ecbf9e525de582d4baa8c" args="(module_handle_t lib, byte *pc, IMAGE_SECTION_HEADER *section_out)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool dr_lookup_module_section </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="dr__tools_8h.html#ab855db7dce02dc18831280f19df840cf">module_handle_t</a>&nbsp;</td>
          <td class="paramname"> <em>lib</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">byte *&nbsp;</td>
          <td class="paramname"> <em>pc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IMAGE_SECTION_HEADER *&nbsp;</td>
          <td class="paramname"> <em>section_out</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Returns whether <code>pc</code> is within a section within the module in <code>section_found</code> and information about that section in <code>section_out</code>. </p>
<dl class="note"><dt><b>Note:</b></dt><dd>Not yet available on Linux. </dd></dl>

</div>
</div>
<a class="anchor" id="af7d3a723c65e3762dd62b115577e0625"></a><!-- doxytag: member="dr_tools.h::dr_map_file" ref="af7d3a723c65e3762dd62b115577e0625" args="(file_t f, INOUT size_t *size, uint64 offs, app_pc addr, uint prot, uint flags)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* dr_map_file </td>
          <td>(</td>
          <td class="paramtype">file_t&nbsp;</td>
          <td class="paramname"> <em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">INOUT size_t *&nbsp;</td>
          <td class="paramname"> <em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64&nbsp;</td>
          <td class="paramname"> <em>offs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">app_pc&nbsp;</td>
          <td class="paramname"> <em>addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&nbsp;</td>
          <td class="paramname"> <em>prot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&nbsp;</td>
          <td class="paramname"> <em>flags</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Memory-maps <code>size</code> bytes starting at offset <code>offs</code> from the file <code>f</code> at address <code>addr</code> with privileges <code>prot</code>.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>f</em>&nbsp;</td><td>The file to map. </td></tr>
    <tr><td valign="top"><tt>[in,out]</tt>&nbsp;</td><td valign="top"><em>size</em>&nbsp;</td><td>The requested size to map. Upon successful return, contains the actual mapped size. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>offs</em>&nbsp;</td><td>The offset within the file at which to start the map. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>addr</em>&nbsp;</td><td>The requested start address of the map. Unless <code>fixed</code> is true, this is just a hint and may not be honored. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>prot</em>&nbsp;</td><td>The access privileges of the mapping, composed of the DR_MEMPROT_READ, DR_MEMPROT_WRITE, and DR_MEMPROT_EXEC bits. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>flags</em>&nbsp;</td><td>Optional DR_MAP_* flags.</td></tr>
  </table>
  </dd>
</dl>
<dl class="note"><dt><b>Note:</b></dt><dd>Mapping image files for execution is not supported.</dd></dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the start address of the mapping, or NULL if unsuccessful. </dd></dl>

</div>
</div>
<a class="anchor" id="a9e262e93823dbc5914eca34540afbc07"></a><!-- doxytag: member="dr_tools.h::dr_mark_trace_head" ref="a9e262e93823dbc5914eca34540afbc07" args="(void *drcontext, void *tag)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool dr_mark_trace_head </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>drcontext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>tag</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Marks the fragment associated with tag <code>tag</code> as a trace head. The fragment need not exist yet -- once it is created it will be marked as a trace head.</p>
<p>DR associates a counter with a trace head and once it passes the -hot_threshold parameter, DR begins building a trace. Before each fragment is added to the trace, DR calls the client's end_trace callback to determine whether to end the trace. (The callback will be called both for standard DR traces and for client-defined traces.)</p>
<dl class="note"><dt><b>Note:</b></dt><dd>Some fragments are unsuitable for trace heads. DR will ignore attempts to mark such fragments as trace heads and will return false. If the client marks a fragment that doesn't exist yet as a trace head and DR later determines that the fragment is unsuitable for a trace head it will unmark the fragment as a trace head without notifying the client.</dd>
<dd>
Some fragments' notion of trace heads is dependent on which previous block targets them. For these fragments, calling this routine will only mark as a trace head for targets from the same memory region.</dd></dl>
<p>Returns true if the target fragment is marked as a trace head. </p>

</div>
</div>
<a class="anchor" id="a813f98fcc06c0a1198262b744e98eced"></a><!-- doxytag: member="dr_tools.h::dr_memory_is_dr_internal" ref="a813f98fcc06c0a1198262b744e98eced" args="(const byte *pc)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool dr_memory_is_dr_internal </td>
          <td>(</td>
          <td class="paramtype">const byte *&nbsp;</td>
          <td class="paramname"> <em>pc</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Returns true iff pc is memory allocated by DR for its own purposes, and would not exist if the application were run natively. </p>

</div>
</div>
<a class="anchor" id="a2a67b03d64626f3d0a78b64bf096ed25"></a><!-- doxytag: member="dr_tools.h::dr_memory_is_in_client" ref="a2a67b03d64626f3d0a78b64bf096ed25" args="(const byte *pc)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool dr_memory_is_in_client </td>
          <td>(</td>
          <td class="paramtype">const byte *&nbsp;</td>
          <td class="paramname"> <em>pc</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Returns true iff pc is located inside a client library. </p>

</div>
</div>
<a class="anchor" id="aa1dd6ff985f0b21deada31ea33485737"></a><!-- doxytag: member="dr_tools.h::dr_memory_is_readable" ref="aa1dd6ff985f0b21deada31ea33485737" args="(const byte *pc, size_t size)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool dr_memory_is_readable </td>
          <td>(</td>
          <td class="paramtype">const byte *&nbsp;</td>
          <td class="paramname"> <em>pc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>size</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Checks to see that all bytes with addresses in the range [<code>pc</code>, <code>pc</code> + <code>size</code> - 1] are readable and that reading from that range won't generate an exception (see also <a class="el" href="dr__tools_8h.html#a6a94558696130c76f34dcdac0ce50c47">dr_safe_read()</a> and <a class="el" href="dr__tools_8h.html#adb9ba447c606e5e58400ac7b6ef719d1">DR_TRY_EXCEPT()</a>). </p>
<dl class="note"><dt><b>Note:</b></dt><dd>Nothing guarantees that the memory will stay readable for any length of time. </dd>
<dd>
On Linux, especially if the app is in the middle of loading a library and has not properly set up the .bss yet, a page that seems readable can still generate SIGBUS if beyond the end of an mmapped file. Use <a class="el" href="dr__tools_8h.html#a6a94558696130c76f34dcdac0ce50c47">dr_safe_read()</a> or <a class="el" href="dr__tools_8h.html#adb9ba447c606e5e58400ac7b6ef719d1">DR_TRY_EXCEPT()</a> to avoid such problems. </dd></dl>

</div>
</div>
<a class="anchor" id="a2c3a19a0dc146c1e5b6747e89bacfb55"></a><!-- doxytag: member="dr_tools.h::dr_memory_protect" ref="a2c3a19a0dc146c1e5b6747e89bacfb55" args="(void *base, size_t size, uint new_prot)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool dr_memory_protect </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&nbsp;</td>
          <td class="paramname"> <em>new_prot</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Modifies the memory protections of the region from <code>start</code> through <code>start</code> + <code>size</code>. Modification of memory allocated by DR or of the DR or client libraries themselves is allowed under the assumption that the client knows what it is doing. Modification of the ntdll.dll library on Windows is not allowed. Returns true if successful. </p>

</div>
</div>
<a class="anchor" id="ad444a204e7ca45f9965cfe973470375a"></a><!-- doxytag: member="dr_tools.h::dr_messagebox" ref="ad444a204e7ca45f9965cfe973470375a" args="(const char *fmt,...)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dr_messagebox </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>fmt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname"> <em>...</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Displays a message in a pop-up window. </p>
<dl class="note"><dt><b>Note:</b></dt><dd>Windows only. </dd>
<dd>
On Windows Vista most Windows services are unable to display message boxes. </dd></dl>

</div>
</div>
<a class="anchor" id="a1702cf25e24e722d9441f92c41fac33e"></a><!-- doxytag: member="dr_tools.h::dr_module_iterator_hasnext" ref="a1702cf25e24e722d9441f92c41fac33e" args="(dr_module_iterator_t *mi)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool dr_module_iterator_hasnext </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="dr__tools_8h.html#afd116a488df74505f27ff57cd49b9f88">dr_module_iterator_t</a> *&nbsp;</td>
          <td class="paramname"> <em>mi</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Returns true if there is another loaded module in the iterator. </p>

</div>
</div>
<a class="anchor" id="a9d49edb3a7b59f5d817afaa8fc0f1ef9"></a><!-- doxytag: member="dr_tools.h::dr_module_iterator_next" ref="a9d49edb3a7b59f5d817afaa8fc0f1ef9" args="(dr_module_iterator_t *mi)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct__module__data__t.html">module_data_t</a>* dr_module_iterator_next </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="dr__tools_8h.html#afd116a488df74505f27ff57cd49b9f88">dr_module_iterator_t</a> *&nbsp;</td>
          <td class="paramname"> <em>mi</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Retrieves the module_data_t for the next loaded module in the iterator. User must call <a class="el" href="dr__tools_8h.html#ad72ba1e8b98c8e01f2c28ef2e4d3e16e">dr_free_module_data()</a> on the returned module_data_t once finished. </p>
<dl class="note"><dt><b>Note:</b></dt><dd>Returned module_data_t must be freed with <a class="el" href="dr__tools_8h.html#ad72ba1e8b98c8e01f2c28ef2e4d3e16e">dr_free_module_data()</a>. </dd></dl>

</div>
</div>
<a class="anchor" id="a3310b1bfc22da285af72b1a4a9d10945"></a><!-- doxytag: member="dr_tools.h::dr_module_iterator_start" ref="a3310b1bfc22da285af72b1a4a9d10945" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="dr__tools_8h.html#afd116a488df74505f27ff57cd49b9f88">dr_module_iterator_t</a>* dr_module_iterator_start </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Initialize a new module iterator. The returned module iterator contains a snapshot of the modules loaded at the time it was created. Use <a class="el" href="dr__tools_8h.html#a1702cf25e24e722d9441f92c41fac33e">dr_module_iterator_hasnext()</a> and <a class="el" href="dr__tools_8h.html#a9d49edb3a7b59f5d817afaa8fc0f1ef9">dr_module_iterator_next()</a> to walk the loaded modules. Call <a class="el" href="dr__tools_8h.html#a15134844f1dd3e914c0da59c65cb3a8d">dr_module_iterator_stop()</a> when finished to release the iterator. </p>
<dl class="note"><dt><b>Note:</b></dt><dd>The iterator does not prevent modules from being loaded or unloaded while the iterator is being walked. </dd></dl>

</div>
</div>
<a class="anchor" id="a15134844f1dd3e914c0da59c65cb3a8d"></a><!-- doxytag: member="dr_tools.h::dr_module_iterator_stop" ref="a15134844f1dd3e914c0da59c65cb3a8d" args="(dr_module_iterator_t *mi)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dr_module_iterator_stop </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="dr__tools_8h.html#afd116a488df74505f27ff57cd49b9f88">dr_module_iterator_t</a> *&nbsp;</td>
          <td class="paramname"> <em>mi</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>User should call this routine to free the module iterator. </p>

</div>
</div>
<a class="anchor" id="a082fe71b00688310237fbc2e027c4388"></a><!-- doxytag: member="dr_tools.h::dr_module_preferred_name" ref="a082fe71b00688310237fbc2e027c4388" args="(const module_data_t *data)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* dr_module_preferred_name </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct__module__data__t.html">module_data_t</a> *&nbsp;</td>
          <td class="paramname"> <em>data</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Returns the preferred name for the module described by <code>data</code> from <code>data-&gt;module_names</code>. </p>

</div>
</div>
<a class="anchor" id="a55da3fd48670f25ec69ee5daf5975de5"></a><!-- doxytag: member="dr_tools.h::dr_mutex_create" ref="a55da3fd48670f25ec69ee5daf5975de5" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* dr_mutex_create </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Initializes a mutex.</p>
<p>Warning: there are restrictions on when DR-provided mutexes, and locks in general, can be held by a client: no lock should be held while application code is executing in the code cache. Locks can be used while inside client code reached from clean calls out of the code cache, but they must be released before returning to the cache. Failing to follow these restrictions can lead to deadlocks. </p>

</div>
</div>
<a class="anchor" id="aaab148b68bc8e1479a14c175cbf42fc0"></a><!-- doxytag: member="dr_tools.h::dr_mutex_destroy" ref="aaab148b68bc8e1479a14c175cbf42fc0" args="(void *mutex)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dr_mutex_destroy </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>mutex</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Deletes <code>mutex</code>. </p>

</div>
</div>
<a class="anchor" id="a04beaefb3e0be6bd0dac39f76398ec1e"></a><!-- doxytag: member="dr_tools.h::dr_mutex_lock" ref="a04beaefb3e0be6bd0dac39f76398ec1e" args="(void *mutex)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dr_mutex_lock </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>mutex</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Locks <code>mutex</code>. Waits until the mutex is successfully held. </p>

</div>
</div>
<a class="anchor" id="ae453a9c1ded7c8cd31d1a1aa2c8810af"></a><!-- doxytag: member="dr_tools.h::dr_mutex_self_owns" ref="ae453a9c1ded7c8cd31d1a1aa2c8810af" args="(void *mutex)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool dr_mutex_self_owns </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>mutex</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Returns true iff <code>mutex</code> is owned by the calling thread. This routine is only available in debug builds. In release builds it always returns true. </p>

</div>
</div>
<a class="anchor" id="a6b2ae4a29e2dc18dde2a6f01f26cbe79"></a><!-- doxytag: member="dr_tools.h::dr_mutex_trylock" ref="a6b2ae4a29e2dc18dde2a6f01f26cbe79" args="(void *mutex)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool dr_mutex_trylock </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>mutex</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Tries once to lock <code>mutex</code>, returns whether or not successful. </p>

</div>
</div>
<a class="anchor" id="a61a3a4ffffd0058a37211405fbb6ba51"></a><!-- doxytag: member="dr_tools.h::dr_mutex_unlock" ref="a61a3a4ffffd0058a37211405fbb6ba51" args="(void *mutex)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dr_mutex_unlock </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>mutex</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Unlocks <code>mutex</code>. Asserts that mutex is currently locked. </p>

</div>
</div>
<a class="anchor" id="ac32b5be072876c25a832d510efeba6e4"></a><!-- doxytag: member="dr_tools.h::dr_nonheap_alloc" ref="ac32b5be072876c25a832d510efeba6e4" args="(size_t size, uint prot)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* dr_nonheap_alloc </td>
          <td>(</td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&nbsp;</td>
          <td class="paramname"> <em>prot</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Allocates <code>size</code> bytes of memory as a separate allocation from DR's heap, allowing for separate protection. The <code>prot</code> protection should use the DR_MEMPROT_READ, DR_MEMPROT_WRITE, and DR_MEMPROT_EXEC bits. When creating a region to hold dynamically generated code, use this routine in order to create executable memory. </p>

</div>
</div>
<a class="anchor" id="a401b819525f805d04e0a9560fdcfdf89"></a><!-- doxytag: member="dr_tools.h::dr_nonheap_free" ref="a401b819525f805d04e0a9560fdcfdf89" args="(void *mem, size_t size)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dr_nonheap_free </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>mem</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>size</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Frees memory allocated by <a class="el" href="dr__tools_8h.html#ac32b5be072876c25a832d510efeba6e4">dr_nonheap_alloc()</a>. <code>size</code> must be the same as that passed to <a class="el" href="dr__tools_8h.html#ac32b5be072876c25a832d510efeba6e4">dr_nonheap_alloc()</a>. </p>

</div>
</div>
<a class="anchor" id="ae3ae2190774a204af207602791a32cb6"></a><!-- doxytag: member="dr_tools.h::dr_open_file" ref="ae3ae2190774a204af207602791a32cb6" args="(const char *fname, uint mode_flags)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">file_t dr_open_file </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>fname</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&nbsp;</td>
          <td class="paramname"> <em>mode_flags</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Opens the file <code>fname</code>. If no such file exists then one is created. The file access mode is set by the <code>mode_flags</code> argument which is drawn from the DR_FILE_* defines ORed together. Returns INVALID_FILE if unsuccessful.</p>
<p>On Windows, <code>fname</code> must be an absolute path (when using Windows system calls directly there is no such thing as a relative path. On Windows the notions of current directory and relative paths are limited to user space via the Win32 API. We may add limited support for using the same current directory via Issue 298.)</p>
<p>On Linux, the file descriptor will be marked as close-on-exec. The DR_FILE_CLOSE_ON_FORK flag can be used to automatically close a file on a fork.</p>
<dl class="note"><dt><b>Note:</b></dt><dd>No more then one write mode flag can be specified.</dd>
<dd>
On Linux, DR hides files opened by clients from the application by using file descriptors that are separate from the application's and preventing the application from closing client-opened files. </dd></dl>

</div>
</div>
<a class="anchor" id="aecb77c99028d913a72c6aaeef48db785"></a><!-- doxytag: member="dr_tools.h::dr_print_instr" ref="aecb77c99028d913a72c6aaeef48db785" args="(void *drcontext, file_t f, instr_t *instr, const char *msg)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dr_print_instr </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>drcontext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">file_t&nbsp;</td>
          <td class="paramname"> <em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structinstr__t.html">instr_t</a> *&nbsp;</td>
          <td class="paramname"> <em>instr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>msg</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Prints <code>msg</code> followed by the instruction <code>instr</code> to file <code>f</code>. </p>

</div>
</div>
<a class="anchor" id="a5902fa16202c9c42d96c755e9412d372"></a><!-- doxytag: member="dr_tools.h::dr_print_opnd" ref="a5902fa16202c9c42d96c755e9412d372" args="(void *drcontext, file_t f, opnd_t opnd, const char *msg)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dr_print_opnd </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>drcontext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">file_t&nbsp;</td>
          <td class="paramname"> <em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structopnd__t.html">opnd_t</a>&nbsp;</td>
          <td class="paramname"> <em>opnd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>msg</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Prints <code>msg</code> followed by the operand <code>opnd</code> to file <code>f</code>. </p>

</div>
</div>
<a class="anchor" id="abad2eddb3786e3e909ff36da39b7e31e"></a><!-- doxytag: member="dr_tools.h::dr_printf" ref="abad2eddb3786e3e909ff36da39b7e31e" args="(const char *fmt,...)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dr_printf </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>fmt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname"> <em>...</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Stdout printing that won't interfere with the application's own printing. Currently non-buffered. </p>
<dl class="note"><dt><b>Note:</b></dt><dd>On Windows, this routine is not able to print to the <code>cmd</code> window unless <a class="el" href="dr__tools_8h.html#a712de67b3f6adb6778ce302925009753">dr_enable_console_printing()</a> is called ahead of time, and even then there are limitations: see <a class="el" href="dr__tools_8h.html#a712de67b3f6adb6778ce302925009753">dr_enable_console_printing()</a>. </dd>
<dd>
On Windows, this routine does not support printing floating point values. Use <a class="el" href="dr__tools_8h.html#ab0c5f2529d9c076b5b0b0e92a70834b7">dr_snprintf()</a> instead. </dd>
<dd>
If the data to be printed is large it will be truncated to an internal buffer size. Use <a class="el" href="dr__tools_8h.html#ab0c5f2529d9c076b5b0b0e92a70834b7">dr_snprintf()</a> and <a class="el" href="dr__tools_8h.html#aeddf708cc2271dc50209b3e78e1d23fb">dr_write_file()</a> for large output. </dd></dl>

</div>
</div>
<a class="anchor" id="ad158d2822dd8bb9caa9604d84b666bfa"></a><!-- doxytag: member="dr_tools.h::dr_query_memory" ref="ad158d2822dd8bb9caa9604d84b666bfa" args="(const byte *pc, byte **base_pc, size_t *size, uint *prot)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool dr_query_memory </td>
          <td>(</td>
          <td class="paramtype">const byte *&nbsp;</td>
          <td class="paramname"> <em>pc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">byte **&nbsp;</td>
          <td class="paramname"> <em>base_pc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&nbsp;</td>
          <td class="paramname"> <em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint *&nbsp;</td>
          <td class="paramname"> <em>prot</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>An os neutral method for querying a memory address. Returns true iff a memory region containing <code>pc</code> is found. If found additional information about the memory region is returned in the optional out arguments <code>base_pc</code>, <code>size</code>, and <code>prot</code> where <code>base_pc</code> is the start address of the memory region continaing <code>pc</code>, <code>size</code> is the size of said memory region and <code>prot</code> is an ORed combination of DR_MEMPROT_* flags describing its current protection.</p>
<dl class="note"><dt><b>Note:</b></dt><dd>To examine only application memory, skip memory for which <a class="el" href="dr__tools_8h.html#a813f98fcc06c0a1198262b744e98eced">dr_memory_is_dr_internal()</a> or <a class="el" href="dr__tools_8h.html#a2a67b03d64626f3d0a78b64bf096ed25">dr_memory_is_in_client()</a> returns true. </dd></dl>

</div>
</div>
<a class="anchor" id="a5a6e4049f8accbc73ec5dbaf0deb25a7"></a><!-- doxytag: member="dr_tools.h::dr_query_memory_ex" ref="a5a6e4049f8accbc73ec5dbaf0deb25a7" args="(const byte *pc, OUT dr_mem_info_t *info)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool dr_query_memory_ex </td>
          <td>(</td>
          <td class="paramtype">const byte *&nbsp;</td>
          <td class="paramname"> <em>pc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OUT <a class="el" href="struct__dr__mem__info__t.html">dr_mem_info_t</a> *&nbsp;</td>
          <td class="paramname"> <em>info</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Provides additional information beyond <a class="el" href="dr__tools_8h.html#ad158d2822dd8bb9caa9604d84b666bfa">dr_query_memory()</a>. Returns true if it was able to obtain information (including about free regions) and sets the fields of <code>info</code>. This routine can be used to iterate over the entire address space. Returns false on failure.</p>
<dl class="note"><dt><b>Note:</b></dt><dd>To examine only application memory, skip memory for which <a class="el" href="dr__tools_8h.html#a813f98fcc06c0a1198262b744e98eced">dr_memory_is_dr_internal()</a> returns true. </dd></dl>

</div>
</div>
<a class="anchor" id="a95b53d79cae021a473c39f3b2662323f"></a><!-- doxytag: member="dr_tools.h::dr_raw_tls_calloc" ref="a95b53d79cae021a473c39f3b2662323f" args="(OUT reg_id_t *segment_register, OUT uint *offset, IN uint num_slots, IN uint alignment)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool dr_raw_tls_calloc </td>
          <td>(</td>
          <td class="paramtype">OUT reg_id_t *&nbsp;</td>
          <td class="paramname"> <em>segment_register</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OUT uint *&nbsp;</td>
          <td class="paramname"> <em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IN uint&nbsp;</td>
          <td class="paramname"> <em>num_slots</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IN uint&nbsp;</td>
          <td class="paramname"> <em>alignment</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Allocates <code>num_slots</code> contiguous thread-local storage slots that can be directly accessed via an offset from <code>segment_register</code>. These slots will be initialized to 0 for each new thread. The slot offsets are [<code>offset</code> .. <code>offset</code> + (num_slots - 1)]. These slots are disjoint from the <a class="el" href="dr__ir__utils_8h.html#a89a6b714ff24d91d78589877047a29b9">dr_spill_slot_t</a> register spill slots and the client tls field (<a class="el" href="dr__tools_8h.html#a787aff5df1ded3de8a7ce9f3efef0594">dr_get_tls_field()</a>). Returns whether or not the slots were successfully obtained. The segment base pointed at <code>segment_register</code> can be obtained using <a class="el" href="dr__tools_8h.html#a8d753cde7a82c612fcb0e1cdbc65fdf0">dr_get_dr_segment_base</a>.</p>
<dl class="note"><dt><b>Note:</b></dt><dd>These slots are useful for thread-shared code caches. With thread-private caches, DR's memory pools are guaranteed to be reachable via absolute or rip-relative accesses from the code cache and client libraries.</dd>
<dd>
These slots are a limited resource. On Windows the slots are shared with the application and reserving even one slot can result in failure to initialize for certain applications. On Linux they are more plentiful and transparent but currently DR limits clients to no more than 64 slots. </dd></dl>

</div>
</div>
<a class="anchor" id="afc53219d019078a38c80ffa80d71829e"></a><!-- doxytag: member="dr_tools.h::dr_raw_tls_cfree" ref="afc53219d019078a38c80ffa80d71829e" args="(uint offset, uint num_slots)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool dr_raw_tls_cfree </td>
          <td>(</td>
          <td class="paramtype">uint&nbsp;</td>
          <td class="paramname"> <em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&nbsp;</td>
          <td class="paramname"> <em>num_slots</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Frees <code>num_slots</code> raw thread-local storage slots starting at offset <code>offset</code> that were allocated with <a class="el" href="dr__tools_8h.html#a95b53d79cae021a473c39f3b2662323f">dr_raw_tls_calloc()</a>. Returns whether or not the slots were successfully freed. </p>

</div>
</div>
<a class="anchor" id="a71f6940085912cdce608f317a27fc397"></a><!-- doxytag: member="dr_tools.h::dr_read_file" ref="a71f6940085912cdce608f317a27fc397" args="(file_t f, void *buf, size_t count)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ssize_t dr_read_file </td>
          <td>(</td>
          <td class="paramtype">file_t&nbsp;</td>
          <td class="paramname"> <em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>count</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Reads up to <code>count</code> bytes from file <code>f</code> into <code>buf</code>. Returns the actual number read. </p>

</div>
</div>
<a class="anchor" id="a5563eff378a7e2ea61b7dd7fcd777a36"></a><!-- doxytag: member="dr_tools.h::dr_recurlock_create" ref="a5563eff378a7e2ea61b7dd7fcd777a36" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* dr_recurlock_create </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Creates and initializes a recursive lock. A recursive lock allows the same thread to acquire it multiple times. The lock restrictions for mutexes apply (see <a class="el" href="dr__tools_8h.html#a55da3fd48670f25ec69ee5daf5975de5">dr_mutex_create()</a>). </p>

</div>
</div>
<a class="anchor" id="af7a203f4a8ebcc35d50e51ed31a51b1f"></a><!-- doxytag: member="dr_tools.h::dr_recurlock_destroy" ref="af7a203f4a8ebcc35d50e51ed31a51b1f" args="(void *reclock)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dr_recurlock_destroy </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>reclock</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Deletes <code>reclock</code>. </p>

</div>
</div>
<a class="anchor" id="abf5a80009a8f667b86acb529fbc75ac4"></a><!-- doxytag: member="dr_tools.h::dr_recurlock_lock" ref="abf5a80009a8f667b86acb529fbc75ac4" args="(void *reclock)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dr_recurlock_lock </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>reclock</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Acquires <code>reclock</code>, or increments the ownership count if already owned. </p>

</div>
</div>
<a class="anchor" id="ac33bd56345cfb4286a05e0c3eab6b3a0"></a><!-- doxytag: member="dr_tools.h::dr_recurlock_self_owns" ref="ac33bd56345cfb4286a05e0c3eab6b3a0" args="(void *reclock)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool dr_recurlock_self_owns </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>reclock</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Returns whether the calling thread owns <code>reclock</code>. </p>

</div>
</div>
<a class="anchor" id="a16d473debdc03a782d8aa5032fb3dd97"></a><!-- doxytag: member="dr_tools.h::dr_recurlock_trylock" ref="a16d473debdc03a782d8aa5032fb3dd97" args="(void *reclock)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool dr_recurlock_trylock </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>reclock</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Tries once to acquire <code>reclock</code> and returns whether successful. </p>

</div>
</div>
<a class="anchor" id="a7d36a11978be634e28116da9dd408030"></a><!-- doxytag: member="dr_tools.h::dr_recurlock_unlock" ref="a7d36a11978be634e28116da9dd408030" args="(void *reclock)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dr_recurlock_unlock </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>reclock</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Decrements the ownership count of <code>reclock</code> and releases if zero. </p>

</div>
</div>
<a class="anchor" id="ab23dff0c2d6d045cd938fc5f2c77a1ff"></a><!-- doxytag: member="dr_tools.h::dr_rename_file" ref="ab23dff0c2d6d045cd938fc5f2c77a1ff" args="(const char *src, const char *dst, bool replace)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool dr_rename_file </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>replace</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Renames the file <code>src</code> to <code>dst</code>, replacing an existing file named <code>dst</code> if <code>replace</code> is true. Atomic if <code>src</code> and <code>dst</code> are on the same filesystem. Returns true if successful. </p>

</div>
</div>
<a class="anchor" id="a5421c0abd69da94ed3e7fb898d5bb132"></a><!-- doxytag: member="dr_tools.h::dr_replace_fragment" ref="a5421c0abd69da94ed3e7fb898d5bb132" args="(void *drcontext, void *tag, instrlist_t *ilist)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool dr_replace_fragment </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>drcontext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>tag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">instrlist_t *&nbsp;</td>
          <td class="paramname"> <em>ilist</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Replaces the fragment with tag <code>tag</code> with the instructions in <code>ilist</code>. This routine is only valid with the -thread_private option; it replaces the fragment for the current thread only. After replacement, the existing fragment is allowed to complete if currently executing. For example, a clean call replacing the currently executing fragment will safely return to the existing code. Subsequent executions will use the new instructions.</p>
<dl class="note"><dt><b>Note:</b></dt><dd>The routine takes control of <code>ilist</code> and all responsibility for deleting it. The client should not keep, use, or reference, the instrlist or any of the instrs it contains after passing.</dd>
<dd>
This routine supports replacement for the current thread only. <code>drcontext</code> must be from the current thread and must be the drcontext used to create the instruction list.</dd></dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>false if the fragment does not exist and true otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="a902bfca468a7a2cc3dbc45b4bd127444"></a><!-- doxytag: member="dr_tools.h::dr_request_synchronized_exit" ref="a902bfca468a7a2cc3dbc45b4bd127444" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dr_request_synchronized_exit </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000006">Deprecated:</a></b></dt><dd>Replaced by <a class="el" href="dr__events_8h.html#acede43748af42c6334a19fc30e48c5f4">dr_set_process_exit_behavior()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a1193842150b09442a1b3c91f4e02d280"></a><!-- doxytag: member="dr_tools.h::dr_resume_all_other_threads" ref="a1193842150b09442a1b3c91f4e02d280" args="(IN void **drcontexts, IN uint num_suspended)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool dr_resume_all_other_threads </td>
          <td>(</td>
          <td class="paramtype">IN void **&nbsp;</td>
          <td class="paramname"> <em>drcontexts</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IN uint&nbsp;</td>
          <td class="paramname"> <em>num_suspended</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>May only be used after invoking <a class="el" href="dr__tools_8h.html#a01fbe357fcc8352ba63c9a1a23e0c207">dr_suspend_all_other_threads()</a>. This routine resumes the threads that were suspended by <a class="el" href="dr__tools_8h.html#a01fbe357fcc8352ba63c9a1a23e0c207">dr_suspend_all_other_threads()</a> and must be passed the same array and count of suspended threads that were returned by <a class="el" href="dr__tools_8h.html#a01fbe357fcc8352ba63c9a1a23e0c207">dr_suspend_all_other_threads()</a>. It also frees the <code>drcontexts</code> array and releases the locks acquired by <a class="el" href="dr__tools_8h.html#a01fbe357fcc8352ba63c9a1a23e0c207">dr_suspend_all_other_threads()</a>. The return value indicates whether all resumption attempts were successful. </p>

</div>
</div>
<a class="anchor" id="a536222ea450d92cabebd3b24fe08098e"></a><!-- doxytag: member="dr_tools.h::dr_rwlock_create" ref="a536222ea450d92cabebd3b24fe08098e" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* dr_rwlock_create </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Creates and initializes a read-write lock. A read-write lock allows multiple readers or alternatively a single writer. The lock restrictions for mutexes apply (see <a class="el" href="dr__tools_8h.html#a55da3fd48670f25ec69ee5daf5975de5">dr_mutex_create()</a>). </p>

</div>
</div>
<a class="anchor" id="aba97c3f8aea471718852b424e6bce35d"></a><!-- doxytag: member="dr_tools.h::dr_rwlock_destroy" ref="aba97c3f8aea471718852b424e6bce35d" args="(void *rwlock)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dr_rwlock_destroy </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>rwlock</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Deletes <code>rwlock</code>. </p>

</div>
</div>
<a class="anchor" id="a96d7cd454ca96a0c2d1e701ab78cbcd8"></a><!-- doxytag: member="dr_tools.h::dr_rwlock_read_lock" ref="a96d7cd454ca96a0c2d1e701ab78cbcd8" args="(void *rwlock)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dr_rwlock_read_lock </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>rwlock</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Acquires a read lock on <code>rwlock</code>. </p>

</div>
</div>
<a class="anchor" id="a3acf4f252a71dc5034aa0d99a59103a8"></a><!-- doxytag: member="dr_tools.h::dr_rwlock_read_unlock" ref="a3acf4f252a71dc5034aa0d99a59103a8" args="(void *rwlock)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dr_rwlock_read_unlock </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>rwlock</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Releases a read lock on <code>rwlock</code>. </p>

</div>
</div>
<a class="anchor" id="aeb9b30addf3e5bf910109061159aef01"></a><!-- doxytag: member="dr_tools.h::dr_rwlock_self_owns_write_lock" ref="aeb9b30addf3e5bf910109061159aef01" args="(void *rwlock)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool dr_rwlock_self_owns_write_lock </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>rwlock</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Returns whether the calling thread owns the write lock on <code>rwlock</code>. </p>

</div>
</div>
<a class="anchor" id="afcb402769c7bc443876c00ad1f9cdbf9"></a><!-- doxytag: member="dr_tools.h::dr_rwlock_write_lock" ref="afcb402769c7bc443876c00ad1f9cdbf9" args="(void *rwlock)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dr_rwlock_write_lock </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>rwlock</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Acquires a write lock on <code>rwlock</code>. </p>

</div>
</div>
<a class="anchor" id="ac7e812e134e71ea3b844387a75bfc273"></a><!-- doxytag: member="dr_tools.h::dr_rwlock_write_trylock" ref="ac7e812e134e71ea3b844387a75bfc273" args="(void *rwlock)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool dr_rwlock_write_trylock </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>rwlock</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Tries once to acquire a write lock on <code>rwlock</code> and returns whether successful. </p>

</div>
</div>
<a class="anchor" id="adfb241b0d90ee47cc3885d2c24c70d94"></a><!-- doxytag: member="dr_tools.h::dr_rwlock_write_unlock" ref="adfb241b0d90ee47cc3885d2c24c70d94" args="(void *rwlock)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dr_rwlock_write_unlock </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>rwlock</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Releases a write lock on <code>rwlock</code>. </p>

</div>
</div>
<a class="anchor" id="a6a94558696130c76f34dcdac0ce50c47"></a><!-- doxytag: member="dr_tools.h::dr_safe_read" ref="a6a94558696130c76f34dcdac0ce50c47" args="(const void *base, size_t size, void *out_buf, size_t *bytes_read)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool dr_safe_read </td>
          <td>(</td>
          <td class="paramtype">const void *&nbsp;</td>
          <td class="paramname"> <em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>out_buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&nbsp;</td>
          <td class="paramname"> <em>bytes_read</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Safely reads <code>size</code> bytes from address <code>base</code> into buffer <code>out_buf</code>. Reading is done without the possibility of an exception occurring. Optionally returns the actual number of bytes copied into <code>bytes_read</code>. Returns true if successful. </p>
<dl class="note"><dt><b>Note:</b></dt><dd>See also <a class="el" href="dr__tools_8h.html#adb9ba447c606e5e58400ac7b6ef719d1">DR_TRY_EXCEPT()</a>. </dd></dl>

</div>
</div>
<a class="anchor" id="ab94f47b693cc7dd9eecba07d8cfd1bc8"></a><!-- doxytag: member="dr_tools.h::dr_safe_write" ref="ab94f47b693cc7dd9eecba07d8cfd1bc8" args="(void *base, size_t size, const void *in_buf, size_t *bytes_written)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool dr_safe_write </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&nbsp;</td>
          <td class="paramname"> <em>in_buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&nbsp;</td>
          <td class="paramname"> <em>bytes_written</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Safely writes <code>size</code> bytes from buffer <code>in_buf</code> to address <code>base</code>. Writing is done without the possibility of an exception occurring. Optionally returns the actual number of bytes copied into <code>bytes_written</code>. Returns true if successful. </p>
<dl class="note"><dt><b>Note:</b></dt><dd>See also <a class="el" href="dr__tools_8h.html#adb9ba447c606e5e58400ac7b6ef719d1">DR_TRY_EXCEPT()</a>. </dd></dl>

</div>
</div>
<a class="anchor" id="a9191c67a267070ed51289d7192f986aa"></a><!-- doxytag: member="dr_tools.h::dr_set_itimer" ref="a9191c67a267070ed51289d7192f986aa" args="(int which, uint millisec, void(*func)(void *drcontext, dr_mcontext_t *mcontext))" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool dr_set_itimer </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>which</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&nbsp;</td>
          <td class="paramname"> <em>millisec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(*)(void *drcontext, <a class="el" href="struct__dr__mcontext__t.html">dr_mcontext_t</a> *mcontext)&nbsp;</td>
          <td class="paramname"> <em>func</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Installs an interval timer in the itimer sharing group that contains the calling thread.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>which</em>&nbsp;</td><td>Must be one of ITIMER_REAL, ITIMER_VIRTUAL, or ITIMER_PROF </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>millisec</em>&nbsp;</td><td>The frequency of the timer, in milliseconds. Passing 0 disables the timer. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>func</em>&nbsp;</td><td>The function that will be called each time the timer fires. It will be passed the context of the thread that received the itimer signal and its machine context, which has not been translated and so may contain raw code cache values. The function will be called from a signal handler that may have interrupted a lock holder or other critical code, so it must be careful in its operations: keep it as simple as possible, and avoid lock usage or I/O operations. If a general timer that does not interrupt client code is required, the client should create a separate thread via <a class="el" href="dr__tools_8h.html#ac6b80b83502ff13d4674b13e7b30b555">dr_create_client_thread()</a> (which is guaranteed to have a private itimer) and set the itimer there, where the callback function can perform more operations safely if that new thread never acquires locks in its normal operation.</td></tr>
  </table>
  </dd>
</dl>
<p>Itimer sharing varies by kernel. Prior to 2.6.12 itimers were thread-private; after 2.6.12 they are shared across a thread group, though there could be multiple thread groups in one address space. The <a class="el" href="dr__tools_8h.html#ab5cd85ea911bd99dedbd8d05796260bc">dr_get_itimer()</a> function can be used to see whether a thread already has an itimer in its group to avoid re-setting an itimer set by an earlier thread. A client thread created by <a class="el" href="dr__tools_8h.html#ac6b80b83502ff13d4674b13e7b30b555">dr_create_client_thread()</a> is guaranteed to not share its itimers with application threads.</p>
<p>The itimer will operate successfully in the presence of an application itimer of the same type.</p>
<p>The return value indicates whether the timer was successfully installed (or uninstalled if 0 was passed for <code>millisec</code>).</p>
<dl class="note"><dt><b>Note:</b></dt><dd>Linux-only. </dd></dl>

</div>
</div>
<a class="anchor" id="a53bfa41e85c457ff39452a68eaf2281b"></a><!-- doxytag: member="dr_tools.h::dr_set_random_seed" ref="a53bfa41e85c457ff39452a68eaf2281b" args="(uint seed)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dr_set_random_seed </td>
          <td>(</td>
          <td class="paramtype">uint&nbsp;</td>
          <td class="paramname"> <em>seed</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Sets the seed used for <a class="el" href="dr__tools_8h.html#aeb3d12bdde33dd279f09bcb2a5bfd901">dr_get_random_value()</a>. Generally this would only be called during client initialization. </p>

</div>
</div>
<a class="anchor" id="a05b499c8a3115e9ceb4c45dbee660738"></a><!-- doxytag: member="dr_tools.h::dr_set_tls_field" ref="a05b499c8a3115e9ceb4c45dbee660738" args="(void *drcontext, void *value)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dr_set_tls_field </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>drcontext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>value</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Sets the user-controlled thread-local-storage field. To generate an instruction sequence that reads the drcontext field inline in the code cache, use <a class="el" href="dr__ir__utils_8h.html#a982089284bd51339f448ec4b3928d3b4">dr_insert_write_tls_field()</a>. </p>

</div>
</div>
<a class="anchor" id="af154e498d8b185931ef970676cb65351"></a><!-- doxytag: member="dr_tools.h::dr_sleep" ref="af154e498d8b185931ef970676cb65351" args="(int time_ms)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dr_sleep </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>time_ms</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Current thread sleeps for <code>time_ms</code> milliseconds. </p>

</div>
</div>
<a class="anchor" id="ab0c5f2529d9c076b5b0b0e92a70834b7"></a><!-- doxytag: member="dr_tools.h::dr_snprintf" ref="ab0c5f2529d9c076b5b0b0e92a70834b7" args="(char *buf, size_t max, const char *fmt,...)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int dr_snprintf </td>
          <td>(</td>
          <td class="paramtype">char *&nbsp;</td>
          <td class="paramname"> <em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>max</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>fmt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname"> <em>...</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Utility routine to print a formatted message to a string. Will not print more than max characters. If successful, returns the number of characters printed, not including the terminating null character. If the number of characters to write equals max, then the caller is responsible for supplying a terminating null character. If the number of characters to write exceeds max, then max characters are written and -1 is returned. If an error occurs, a negative value is returned. </p>
<dl class="note"><dt><b>Note:</b></dt><dd>This routine does not support printing wide characters. On Windows you can use _snprintf() instead (though _snprintf() does not support printing floating point values). </dd>
<dd>
If the data to be printed is large it will be truncated to an internal buffer size. </dd>
<dd>
When printing floating-point values, the caller's code should use <a class="el" href="dr__proc_8h.html#a4a11c9d5d127ce126562ad35b4d165dd">proc_save_fpstate()</a> or be inside a clean call that has requested to preserve the floating-point state. </dd></dl>

</div>
</div>
<a class="anchor" id="af63184f56cc0508e2840f64e84b1c48d"></a><!-- doxytag: member="dr_tools.h::dr_standalone_init" ref="af63184f56cc0508e2840f64e84b1c48d" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* dr_standalone_init </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Creates a DR context that can be used in a standalone program. </p>
<dl class="warning"><dt><b>Warning:</b></dt><dd>This context cannot be used as the drcontext for a thread running under DR control! It is only for standalone programs that wish to use DR as a library of disassembly, etc. routines. </dd></dl>

</div>
</div>
<a class="anchor" id="a01fbe357fcc8352ba63c9a1a23e0c207"></a><!-- doxytag: member="dr_tools.h::dr_suspend_all_other_threads" ref="a01fbe357fcc8352ba63c9a1a23e0c207" args="(OUT void ***drcontexts, OUT uint *num_suspended, OUT uint *num_unsuspended)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool dr_suspend_all_other_threads </td>
          <td>(</td>
          <td class="paramtype">OUT void ***&nbsp;</td>
          <td class="paramname"> <em>drcontexts</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OUT uint *&nbsp;</td>
          <td class="paramname"> <em>num_suspended</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OUT uint *&nbsp;</td>
          <td class="paramname"> <em>num_unsuspended</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Suspends all other threads in the process and returns an array of contexts in <code>drcontexts</code> with one context per successfully suspended threads. The contexts can be passed to routines like <a class="el" href="dr__tools_8h.html#a3980d703cc13379a6b57396a7901b1d1">dr_get_thread_id()</a> or <a class="el" href="dr__ir__utils_8h.html#a91ffde2808c16e07f323c34affa72209">dr_get_mcontext()</a>. However, the contexts may not be modified: <a class="el" href="dr__ir__utils_8h.html#a56568d24667f5d64264d0bad398727b3">dr_set_mcontext()</a> is not supported. <a class="el" href="dr__ir__utils_8h.html#a91ffde2808c16e07f323c34affa72209">dr_get_mcontext()</a> can be called on the caller of this routine, unless in a Windows nudge callback.</p>
<p>The number of successfully suspended threads, which is also the length of the <code>drcontexts</code> array, is returned in <code>num_suspended</code>, which is a required parameter. The number of un-successfully suspended threads, if any, is returned in the optional parameter <code>num_unsuspended</code>. The calling thread is not considered in either count. DR can fail to suspend a thread for privilege reasons (e.g., on Windows in a low-privilege process where another process injected a thread). This function returns true iff all threads were suspended, in which case <code>num_unsuspended</code> will be 0.</p>
<p>The caller must invoke <a class="el" href="dr__tools_8h.html#a1193842150b09442a1b3c91f4e02d280">dr_resume_all_other_threads()</a> in order to resume the suspended threads, free the <code>drcontexts</code> array, and release coarse-grain locks that prevent new threads from being created.</p>
<p>This routine may not be called from any registered event callback other than the nudge event or the pre- or post-system call event. It may be called from clean calls out of the cache. This routine may not be called while any locks are held that could block a thread processing a registered event callback or cache callout.</p>
<dl class="note"><dt><b>Note:</b></dt><dd>A client wishing to invoke this routine from an event callback can queue up a nudge via <a class="el" href="dr__events_8h.html#a9d11fb8fbffdcb0cb6e7b87f804cb459">dr_nudge_client()</a> and invoke this routine from the nudge callback. </dd></dl>

</div>
</div>
<a class="anchor" id="aa2944aa54d591a236f5334a35bfb41bf"></a><!-- doxytag: member="dr_tools.h::dr_switch_to_app_state" ref="aa2944aa54d591a236f5334a35bfb41bf" args="(void *drcontext)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dr_switch_to_app_state </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>drcontext</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Swaps to the application version of any system state for the given thread. This is meant to be used prior to examining application memory, when private libraries are in use and there are two versions of system state. Invoking non-DR library routines while the application state is in place can lead to unpredictable results: call <a class="el" href="dr__tools_8h.html#a97ba972c50a47e7121c98652b461ae8e">dr_switch_to_dr_state()</a> before doing so. </p>

</div>
</div>
<a class="anchor" id="a97ba972c50a47e7121c98652b461ae8e"></a><!-- doxytag: member="dr_tools.h::dr_switch_to_dr_state" ref="a97ba972c50a47e7121c98652b461ae8e" args="(void *drcontext)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dr_switch_to_dr_state </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>drcontext</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Should only be called after calling <a class="el" href="dr__tools_8h.html#aa2944aa54d591a236f5334a35bfb41bf">dr_switch_to_app_state()</a>. Swaps from the application version of system state for the given thread back to the DR and client version. </p>

</div>
</div>
<a class="anchor" id="a1e01fe123ecc9908ada9c9fccbf3f6ab"></a><!-- doxytag: member="dr_tools.h::dr_syscall_get_param" ref="a1e01fe123ecc9908ada9c9fccbf3f6ab" args="(void *drcontext, int param_num)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">reg_t dr_syscall_get_param </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>drcontext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>param_num</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Usable only from a pre-syscall (<a class="el" href="dr__events_8h.html#aa37d61a7f9dde4663b8dd4c3a44732f4">dr_register_pre_syscall_event()</a>) event. Returns the value of system call parameter number <code>param_num</code>. </p>

</div>
</div>
<a class="anchor" id="ad12463724bf63a891e991891c72e6a4b"></a><!-- doxytag: member="dr_tools.h::dr_syscall_get_result" ref="ad12463724bf63a891e991891c72e6a4b" args="(void *drcontext)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">reg_t dr_syscall_get_result </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>drcontext</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Usable only from a post-syscall (<a class="el" href="dr__events_8h.html#a099441f8d147404355c66178e3b19f0f">dr_register_post_syscall_event()</a>) event. Returns the return value of the system call that will be presented to the application. </p>

</div>
</div>
<a class="anchor" id="a76797a9310bf67ebeb820d80e11764b8"></a><!-- doxytag: member="dr_tools.h::dr_syscall_invoke_another" ref="a76797a9310bf67ebeb820d80e11764b8" args="(void *drcontext)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dr_syscall_invoke_another </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>drcontext</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Usable only from a post-syscall (<a class="el" href="dr__events_8h.html#a099441f8d147404355c66178e3b19f0f">dr_register_post_syscall_event()</a>) event. An additional system call will be invoked immediately, using the current values of the parameters, which can be set with <a class="el" href="dr__tools_8h.html#ac21a83f1812443112303ef3ea8b76de2">dr_syscall_set_param()</a>. The system call to be invoked should be specified with <a class="el" href="dr__tools_8h.html#abc80dfdf8bff3c3feb486aacd69aba7c">dr_syscall_set_sysnum()</a>.</p>
<p>Use this routine with caution. Especially on Windows, care must be taken if the application is expected to continue afterward. When system call parameters are stored on the stack, modifying them can result in incorrect application behavior, particularly when setting more parameters than were present in the original system call, which will result in corruption of the application stack.</p>
<p>On Windows, when the first system call is interruptible (alertable), the additional system call may be delayed.</p>
<p>DR will set key registers such as r10 for 64-bit or xdx for sysenter or WOW64 system calls. However, DR will not set ecx for WOW64; that is up to the client. </p>

</div>
</div>
<a class="anchor" id="ac21a83f1812443112303ef3ea8b76de2"></a><!-- doxytag: member="dr_tools.h::dr_syscall_set_param" ref="ac21a83f1812443112303ef3ea8b76de2" args="(void *drcontext, int param_num, reg_t new_value)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dr_syscall_set_param </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>drcontext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>param_num</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">reg_t&nbsp;</td>
          <td class="paramname"> <em>new_value</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Usable only from a pre-syscall (<a class="el" href="dr__events_8h.html#aa37d61a7f9dde4663b8dd4c3a44732f4">dr_register_pre_syscall_event()</a>) event, or from a post-syscall (<a class="el" href="dr__events_8h.html#a099441f8d147404355c66178e3b19f0f">dr_register_post_syscall_event()</a>) event when also using <a class="el" href="dr__tools_8h.html#a76797a9310bf67ebeb820d80e11764b8">dr_syscall_invoke_another()</a>. Sets the value of system call parameter number <code>param_num</code> to <code>new_value</code>. </p>

</div>
</div>
<a class="anchor" id="a601cd2b724ac627aef0756a4c4eee637"></a><!-- doxytag: member="dr_tools.h::dr_syscall_set_result" ref="a601cd2b724ac627aef0756a4c4eee637" args="(void *drcontext, reg_t value)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dr_syscall_set_result </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>drcontext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">reg_t&nbsp;</td>
          <td class="paramname"> <em>value</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Usable only from a pre-syscall (<a class="el" href="dr__events_8h.html#aa37d61a7f9dde4663b8dd4c3a44732f4">dr_register_pre_syscall_event()</a>) or post-syscall (<a class="el" href="dr__events_8h.html#a099441f8d147404355c66178e3b19f0f">dr_register_post_syscall_event()</a>) event. For pre-syscall, should only be used when skipping the system call. This sets the return value of the system call that the application sees to <code>value</code>. </p>

</div>
</div>
<a class="anchor" id="abc80dfdf8bff3c3feb486aacd69aba7c"></a><!-- doxytag: member="dr_tools.h::dr_syscall_set_sysnum" ref="abc80dfdf8bff3c3feb486aacd69aba7c" args="(void *drcontext, int new_num)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dr_syscall_set_sysnum </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>drcontext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>new_num</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Usable only from a pre-syscall (<a class="el" href="dr__events_8h.html#aa37d61a7f9dde4663b8dd4c3a44732f4">dr_register_pre_syscall_event()</a>) event, or from a post-syscall (<a class="el" href="dr__events_8h.html#a099441f8d147404355c66178e3b19f0f">dr_register_post_syscall_event()</a>) event when also using <a class="el" href="dr__tools_8h.html#a76797a9310bf67ebeb820d80e11764b8">dr_syscall_invoke_another()</a>. Sets the system call number of the system call about to be invoked to <code>new_num</code>. </p>

</div>
</div>
<a class="anchor" id="a4274226adda06339e247e4a311abdd9b"></a><!-- doxytag: member="dr_tools.h::dr_thread_alloc" ref="a4274226adda06339e247e4a311abdd9b" args="(void *drcontext, size_t size)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* dr_thread_alloc </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>drcontext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>size</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Allocates <code>size</code> bytes of memory from DR's memory pool specific to the thread associated with <code>drcontext</code>. </p>

</div>
</div>
<a class="anchor" id="a3f1f3862009f52182e9ca1f943fa6f14"></a><!-- doxytag: member="dr_tools.h::dr_thread_free" ref="a3f1f3862009f52182e9ca1f943fa6f14" args="(void *drcontext, void *mem, size_t size)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dr_thread_free </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>drcontext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>mem</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>size</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Frees thread-specific memory allocated by <a class="el" href="dr__tools_8h.html#a4274226adda06339e247e4a311abdd9b">dr_thread_alloc()</a>. <code>size</code> must be the same as that passed to <a class="el" href="dr__tools_8h.html#a4274226adda06339e247e4a311abdd9b">dr_thread_alloc()</a>. </p>

</div>
</div>
<a class="anchor" id="ac262422c1e5e487113176bd4193c387f"></a><!-- doxytag: member="dr_tools.h::dr_thread_yield" ref="ac262422c1e5e487113176bd4193c387f" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dr_thread_yield </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Current thread gives up its time quantum. </p>

</div>
</div>
<a class="anchor" id="a1d4c9a29f1c962457c123322aa3e1931"></a><!-- doxytag: member="dr_tools.h::dr_trace_exists_at" ref="a1d4c9a29f1c962457c123322aa3e1931" args="(void *drcontext, void *tag)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool dr_trace_exists_at </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>drcontext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>tag</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Checks to see that if there is a trace in the code cache at tag <code>tag</code>. </p>

</div>
</div>
<a class="anchor" id="a1e3f7e4e3e4048021966c04a4b00fbc9"></a><!-- doxytag: member="dr_tools.h::dr_trace_head_at" ref="a1e3f7e4e3e4048021966c04a4b00fbc9" args="(void *drcontext, void *tag)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool dr_trace_head_at </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>drcontext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>tag</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Checks to see if the fragment (or future fragment) with tag <code>tag</code> is marked as a trace head. </p>

</div>
</div>
<a class="anchor" id="aef746f843b3270add2c763ab71457e5d"></a><!-- doxytag: member="dr_tools.h::dr_try_setup" ref="aef746f843b3270add2c763ab71457e5d" args="(void *drcontext, void **try_cxt)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dr_try_setup </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>drcontext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void **&nbsp;</td>
          <td class="paramname"> <em>try_cxt</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Do not call this directly: use the DR_TRY_EXCEPT macro instead. </p>

</div>
</div>
<a class="anchor" id="aa59cdd4f9fa2884b5d236f0fedc5bda3"></a><!-- doxytag: member="dr_tools.h::dr_try_start" ref="aa59cdd4f9fa2884b5d236f0fedc5bda3" args="(void *buf)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int dr_try_start </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>buf</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Do not call this directly: use the DR_TRY_EXCEPT macro instead. </p>

</div>
</div>
<a class="anchor" id="afde42618a83e7e1abdc58961a084e774"></a><!-- doxytag: member="dr_tools.h::dr_try_stop" ref="afde42618a83e7e1abdc58961a084e774" args="(void *drcontext, void *try_cxt)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dr_try_stop </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>drcontext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>try_cxt</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Do not call this directly: use the DR_TRY_EXCEPT macro instead. </p>

</div>
</div>
<a class="anchor" id="a56909cf76e4a71fca13731053ef48928"></a><!-- doxytag: member="dr_tools.h::dr_unlink_flush_region" ref="a56909cf76e4a71fca13731053ef48928" args="(app_pc start, size_t size)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool dr_unlink_flush_region </td>
          <td>(</td>
          <td class="paramtype">app_pc&nbsp;</td>
          <td class="paramname"> <em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>size</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Flush all fragments containing any code from the region [<code>start</code>, <code>start</code> + <code>size</code>). Control will not enter a fragment containing code from the region after this returns, but a thread already in such a fragment will finish out the fragment. This includes the current thread if this is called from a clean call that returns to the cache. This routine may only be called during a clean call from the cache, from a nudge event handler, or from a pre- or post-system call event handler. It may not be called from any other event callback. No locks can be held when calling this routine. Returns true if successful.</p>
<dl class="note"><dt><b>Note:</b></dt><dd>This routine may not be called from any registered event callback other than the nudge event or the pre- or post-system call event; clean calls out of the cache may call this routine. </dd>
<dd>
This routine may not be called while any locks are held that could block a thread processing a registered event callback or cache callout. </dd>
<dd>
<a class="el" href="dr__tools_8h.html#afa5ea6649e644074ca55f456c89264e8">dr_delay_flush_region()</a> has fewer restrictions on use, but is less synchronous. </dd>
<dd>
Use <code>size</code> == 1 to flush fragments containing the instruction at address <code>start</code>. A flush of <code>size</code> == 0 is not allowed. </dd>
<dd>
This routine is only available with either the -thread_private or -enable_full_api options. It is not available when -opt_memory is specified. </dd></dl>

</div>
</div>
<a class="anchor" id="a552563b1ccb84e3708041b276404d577"></a><!-- doxytag: member="dr_tools.h::dr_unload_aux_library" ref="a552563b1ccb84e3708041b276404d577" args="(dr_auxlib_handle_t lib)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool dr_unload_aux_library </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="dr__tools_8h.html#ad4bb25312a86996379357f79a4c7c1c1">dr_auxlib_handle_t</a>&nbsp;</td>
          <td class="paramname"> <em>lib</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Unloads the given library, which must have been loaded by <a class="el" href="dr__tools_8h.html#a94c8a2e52880f44d43402d6b0d686db2">dr_load_aux_library()</a>. Returns whether successful. </p>

</div>
</div>
<a class="anchor" id="ae7f36900cafd048db5b8d34cf92faa45"></a><!-- doxytag: member="dr_tools.h::dr_unmap_file" ref="ae7f36900cafd048db5b8d34cf92faa45" args="(void *map, size_t size)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool dr_unmap_file </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>map</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>size</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Unmaps a portion of a file mapping previously created by <a class="el" href="dr__tools_8h.html#af7d3a723c65e3762dd62b115577e0625">dr_map_file()</a>. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>whether successful. </dd></dl>

</div>
</div>
<a class="anchor" id="a54934632c814904bd9e0ce9c83980466"></a><!-- doxytag: member="dr_tools.h::dr_using_all_private_caches" ref="a54934632c814904bd9e0ce9c83980466" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool dr_using_all_private_caches </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Returns true if all DynamoRIO caches are thread private. </p>

</div>
</div>
<a class="anchor" id="a7ed94a2b046bb9ee777afe4f3ef1237f"></a><!-- doxytag: member="dr_tools.h::dr_using_app_state" ref="a7ed94a2b046bb9ee777afe4f3ef1237f" args="(void *drcontext)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool dr_using_app_state </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>drcontext</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Returns whether the given thread indicated by <code>drcontext</code> is currently using the application version of its system state. </p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="dr__tools_8h.html#a97ba972c50a47e7121c98652b461ae8e">dr_switch_to_dr_state()</a>, <a class="el" href="dr__tools_8h.html#aa2944aa54d591a236f5334a35bfb41bf">dr_switch_to_app_state()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a505318c1ece53cdaff85f387dc6bf758"></a><!-- doxytag: member="dr_tools.h::dr_using_console" ref="a505318c1ece53cdaff85f387dc6bf758" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool dr_using_console </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Returns true if the current standard error handle belongs to a console window (viz., <code>cmd</code>). DR's <a class="el" href="dr__tools_8h.html#abad2eddb3786e3e909ff36da39b7e31e">dr_printf()</a> and <a class="el" href="dr__tools_8h.html#afe7ede5b10890505021ac03e8f9ba97f">dr_fprintf()</a> do not work with such console windows unless <a class="el" href="dr__tools_8h.html#a712de67b3f6adb6778ce302925009753">dr_enable_console_printing()</a> is called ahead of time, and even then there are limitations detailed in <a class="el" href="dr__tools_8h.html#a712de67b3f6adb6778ce302925009753">dr_enable_console_printing()</a>. This routine may result in loading a private copy of kernel32.dll. </p>

</div>
</div>
<a class="anchor" id="a55ca77553e86a0656dc186ae3fc8222f"></a><!-- doxytag: member="dr_tools.h::dr_virtual_query" ref="a55ca77553e86a0656dc186ae3fc8222f" args="(const byte *pc, MEMORY_BASIC_INFORMATION *mbi, size_t mbi_size)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t dr_virtual_query </td>
          <td>(</td>
          <td class="paramtype">const byte *&nbsp;</td>
          <td class="paramname"> <em>pc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MEMORY_BASIC_INFORMATION *&nbsp;</td>
          <td class="paramname"> <em>mbi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>mbi_size</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Equivalent to the win32 API function VirtualQuery(). See that routine for a description of arguments and return values. </p>
<dl class="note"><dt><b>Note:</b></dt><dd>Windows-only. </dd></dl>

</div>
</div>
<a class="anchor" id="ad6b928d8cbc48fdf7d1d82c4fa95e40e"></a><!-- doxytag: member="dr_tools.h::dr_vsnprintf" ref="ad6b928d8cbc48fdf7d1d82c4fa95e40e" args="(char *buf, size_t max, const char *fmt, va_list ap)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int dr_vsnprintf </td>
          <td>(</td>
          <td class="paramtype">char *&nbsp;</td>
          <td class="paramname"> <em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>max</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>fmt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">va_list&nbsp;</td>
          <td class="paramname"> <em>ap</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Identical to <a class="el" href="dr__tools_8h.html#ab0c5f2529d9c076b5b0b0e92a70834b7">dr_snprintf()</a> but exposes va_list. </p>

</div>
</div>
<a class="anchor" id="aeddf708cc2271dc50209b3e78e1d23fb"></a><!-- doxytag: member="dr_tools.h::dr_write_file" ref="aeddf708cc2271dc50209b3e78e1d23fb" args="(file_t f, const void *buf, size_t count)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ssize_t dr_write_file </td>
          <td>(</td>
          <td class="paramtype">file_t&nbsp;</td>
          <td class="paramname"> <em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&nbsp;</td>
          <td class="paramname"> <em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>count</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Writes <code>count</code> bytes from <code>buf</code> to file <code>f</code>. Returns the actual number written. </p>

</div>
</div>
</div>
<hr size="1"><address style="text-align: center;"><small>
<img border=0 src="favicon.png"> &nbsp; DynamoRIO API version 3.2.0 --- Wed Mar 28 12:55:33 2012 
&nbsp; <img border=0 src="favicon.png">
</body>
</html>
