<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>DynamoRIO API: dr_ir_instrlist.h File Reference</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
<link rel="shortcut icon" type="image/x-icon" href="favicon.ico" />
</head><body>
<!-- Generated by Doxygen 1.6.3 -->
<div class="contents">
<h1>dr_ir_instrlist.h File Reference</h1>
<p>Functions to create and manipulate lists of instructions.  
<a href="#_details">More...</a></p>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td colspan="2"><h2>Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">instrlist_t *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__instrlist_8h.html#a53470097e44fe65dd02df98e154df0fe">instrlist_create</a> (void *drcontext)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__instrlist_8h.html#a58f6c047c08e09d681dfcc6e35a0ef19">instrlist_init</a> (instrlist_t *ilist)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__instrlist_8h.html#ad2cf3084b7f2147bf17f007b8fead468">instrlist_destroy</a> (void *drcontext, instrlist_t *ilist)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__instrlist_8h.html#a718a7c4da5397acc68fa87c7aaff63cc">instrlist_clear</a> (void *drcontext, instrlist_t *ilist)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__instrlist_8h.html#aeee3af7ee64fce9115e03ca55fa80a0f">instrlist_clear_and_destroy</a> (void *drcontext, instrlist_t *ilist)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__instrlist_8h.html#ae0f71aa213fbbf097e13a67042af52f0">instrlist_set_translation_target</a> (instrlist_t *ilist, app_pc pc)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">app_pc&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__instrlist_8h.html#a18ae2e4d759afc814d47a52073bea348">instrlist_get_translation_target</a> (instrlist_t *ilist)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structinstr__t.html">instr_t</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__instrlist_8h.html#ac9a47c1b7376ca06d8dcb4b3094e5a67">instrlist_first</a> (instrlist_t *ilist)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structinstr__t.html">instr_t</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__instrlist_8h.html#ae2f37fe5e485b5aed7a196a5a1348d4a">instrlist_last</a> (instrlist_t *ilist)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__instrlist_8h.html#a5b665b4bd8c54359b2a57e0f2e46ff5d">instrlist_append</a> (instrlist_t *ilist, <a class="el" href="structinstr__t.html">instr_t</a> *instr)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__instrlist_8h.html#a26415c0663dede10a65a6111110206ab">instrlist_prepend</a> (instrlist_t *ilist, <a class="el" href="structinstr__t.html">instr_t</a> *instr)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">instrlist_t *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__instrlist_8h.html#a97153b3ccbb7282beb3a7c16622f40fa">instrlist_clone</a> (void *drcontext, instrlist_t *old)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__instrlist_8h.html#a9c82c8b76c549a10ae88fa63eb85aa5b">instrlist_preinsert</a> (instrlist_t *ilist, <a class="el" href="structinstr__t.html">instr_t</a> *where, <a class="el" href="structinstr__t.html">instr_t</a> *instr)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__instrlist_8h.html#ab98cd7319abad8ff223b00fb6f5c5bf8">instrlist_postinsert</a> (instrlist_t *ilist, <a class="el" href="structinstr__t.html">instr_t</a> *where, <a class="el" href="structinstr__t.html">instr_t</a> *instr)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structinstr__t.html">instr_t</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__instrlist_8h.html#a9bd1a00391f4ad909f67a31ea9163962">instrlist_replace</a> (instrlist_t *ilist, <a class="el" href="structinstr__t.html">instr_t</a> *oldinst, <a class="el" href="structinstr__t.html">instr_t</a> *newinst)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__instrlist_8h.html#a2bad28eed64877354dcf984ff672c7d9">instrlist_remove</a> (instrlist_t *ilist, <a class="el" href="structinstr__t.html">instr_t</a> *instr)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__instrlist_8h.html#a24c81467322f6eb86a8652ab1000fd2a">instrlist_set_fall_through_target</a> (instrlist_t *bb, app_pc tgt)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__instrlist_8h.html#a71b0819b01546ec1b69063ba189a613e">instrlist_set_return_target</a> (instrlist_t *bb, app_pc tgt)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__instrlist_8h.html#ae8313ff5985340de519dfe4cc7555c60">instrlist_disassemble</a> (void *drcontext, app_pc tag, instrlist_t *ilist, file_t outfile)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">byte *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__instrlist_8h.html#aaac5ae2bc9af179b56bbbe5efc14e8b5">instrlist_encode</a> (void *drcontext, instrlist_t *ilist, byte *pc, bool has_instr_jmp_targets)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">byte *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__instrlist_8h.html#a8ae48a113e137b95cd3499f9fa57f5ea">instrlist_encode_to_copy</a> (void *drcontext, instrlist_t *ilist, byte *copy_pc, byte *final_pc, byte *max_pc, bool has_instr_jmp_targets)</td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<p>Functions to create and manipulate lists of instructions. </p>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="a5b665b4bd8c54359b2a57e0f2e46ff5d"></a><!-- doxytag: member="dr_ir_instrlist.h::instrlist_append" ref="a5b665b4bd8c54359b2a57e0f2e46ff5d" args="(instrlist_t *ilist, instr_t *instr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void instrlist_append </td>
          <td>(</td>
          <td class="paramtype">instrlist_t *&nbsp;</td>
          <td class="paramname"> <em>ilist</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structinstr__t.html">instr_t</a> *&nbsp;</td>
          <td class="paramname"> <em>instr</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Adds <code>instr</code> to the end of <code>ilist</code>. </p>

</div>
</div>
<a class="anchor" id="a718a7c4da5397acc68fa87c7aaff63cc"></a><!-- doxytag: member="dr_ir_instrlist.h::instrlist_clear" ref="a718a7c4da5397acc68fa87c7aaff63cc" args="(void *drcontext, instrlist_t *ilist)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void instrlist_clear </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>drcontext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">instrlist_t *&nbsp;</td>
          <td class="paramname"> <em>ilist</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Frees the instructions in <code>ilist</code>. </p>

</div>
</div>
<a class="anchor" id="aeee3af7ee64fce9115e03ca55fa80a0f"></a><!-- doxytag: member="dr_ir_instrlist.h::instrlist_clear_and_destroy" ref="aeee3af7ee64fce9115e03ca55fa80a0f" args="(void *drcontext, instrlist_t *ilist)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void instrlist_clear_and_destroy </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>drcontext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">instrlist_t *&nbsp;</td>
          <td class="paramname"> <em>ilist</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Destroys the instructions in <code>ilist</code> and destroys the instrlist_t object itself. </p>

</div>
</div>
<a class="anchor" id="a97153b3ccbb7282beb3a7c16622f40fa"></a><!-- doxytag: member="dr_ir_instrlist.h::instrlist_clone" ref="a97153b3ccbb7282beb3a7c16622f40fa" args="(void *drcontext, instrlist_t *old)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">instrlist_t* instrlist_clone </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>drcontext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">instrlist_t *&nbsp;</td>
          <td class="paramname"> <em>old</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Allocates a new instrlist_t and for each <a class="el" href="structinstr__t.html">instr_t</a> in <code>old</code> allocates a new <a class="el" href="structinstr__t.html">instr_t</a> using instr_clone to produce a complete copy of <code>old</code>. Each operand that is <a class="el" href="dr__ir__opnd_8h.html#a6a2eacd53cecf009a189db1543e85a29">opnd_is_instr()</a> has its target updated to point to the corresponding <a class="el" href="structinstr__t.html">instr_t</a> in the new instrlist_t (this routine assumes that all such targets are contained within <code>old</code>, and may fault otherwise). </p>

</div>
</div>
<a class="anchor" id="a53470097e44fe65dd02df98e154df0fe"></a><!-- doxytag: member="dr_ir_instrlist.h::instrlist_create" ref="a53470097e44fe65dd02df98e154df0fe" args="(void *drcontext)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">instrlist_t* instrlist_create </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>drcontext</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Returns an initialized instrlist_t allocated on the thread-local heap. </p>

</div>
</div>
<a class="anchor" id="ad2cf3084b7f2147bf17f007b8fead468"></a><!-- doxytag: member="dr_ir_instrlist.h::instrlist_destroy" ref="ad2cf3084b7f2147bf17f007b8fead468" args="(void *drcontext, instrlist_t *ilist)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void instrlist_destroy </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>drcontext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">instrlist_t *&nbsp;</td>
          <td class="paramname"> <em>ilist</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Deallocates the thread-local heap storage for <code>ilist</code>. </p>

</div>
</div>
<a class="anchor" id="ae8313ff5985340de519dfe4cc7555c60"></a><!-- doxytag: member="dr_ir_instrlist.h::instrlist_disassemble" ref="ae8313ff5985340de519dfe4cc7555c60" args="(void *drcontext, app_pc tag, instrlist_t *ilist, file_t outfile)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void instrlist_disassemble </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>drcontext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">app_pc&nbsp;</td>
          <td class="paramname"> <em>tag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">instrlist_t *&nbsp;</td>
          <td class="paramname"> <em>ilist</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">file_t&nbsp;</td>
          <td class="paramname"> <em>outfile</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Prints each instruction in <code>ilist</code> in sequence to <code>outfile</code>. The default is to use AT&amp;T-style syntax, unless the <a class="el" href="using.html#op_syntax_intel">-syntax_intel</a> runtime option is specified. </p>

</div>
</div>
<a class="anchor" id="aaac5ae2bc9af179b56bbbe5efc14e8b5"></a><!-- doxytag: member="dr_ir_instrlist.h::instrlist_encode" ref="aaac5ae2bc9af179b56bbbe5efc14e8b5" args="(void *drcontext, instrlist_t *ilist, byte *pc, bool has_instr_jmp_targets)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">byte* instrlist_encode </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>drcontext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">instrlist_t *&nbsp;</td>
          <td class="paramname"> <em>ilist</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">byte *&nbsp;</td>
          <td class="paramname"> <em>pc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>has_instr_jmp_targets</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Encodes each instruction in <code>ilist</code> in turn in contiguous memory starting at <code>pc</code>. Returns the pc after all of the encodings, or NULL if any one of the encodings failed. Uses the x86/x64 mode stored in each instr, not the mode of the current thread. In order for <a class="el" href="structinstr__t.html">instr_t</a> operands to be encoded properly, <code>has_instr_jmp_targets</code> must be true. If <code>has_instr_jmp_targets</code> is true, the note field of each <a class="el" href="structinstr__t.html">instr_t</a> in ilist will be overwritten, and if any <a class="el" href="structinstr__t.html">instr_t</a> targets are not in <code>ilist</code>, they must have their note fields set with their offsets relative to pc. x86 instructions can occupy up to 17 bytes each, so the caller should ensure the target location has enough room to avoid overflow. </p>

</div>
</div>
<a class="anchor" id="a8ae48a113e137b95cd3499f9fa57f5ea"></a><!-- doxytag: member="dr_ir_instrlist.h::instrlist_encode_to_copy" ref="a8ae48a113e137b95cd3499f9fa57f5ea" args="(void *drcontext, instrlist_t *ilist, byte *copy_pc, byte *final_pc, byte *max_pc, bool has_instr_jmp_targets)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">byte* instrlist_encode_to_copy </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>drcontext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">instrlist_t *&nbsp;</td>
          <td class="paramname"> <em>ilist</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">byte *&nbsp;</td>
          <td class="paramname"> <em>copy_pc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">byte *&nbsp;</td>
          <td class="paramname"> <em>final_pc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">byte *&nbsp;</td>
          <td class="paramname"> <em>max_pc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>has_instr_jmp_targets</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Encodes each instruction in <code>ilist</code> in turn in contiguous memory starting <code>copy_pc</code> in preparation for copying to <code>final_pc</code>. Any pc-relative instruction is encoded as though the instruction list were located at <code>final_pc</code>. This allows for direct copying of the encoded bytes to <code>final_pc</code> without re-relativization.</p>
<p>Returns the pc after all of the encodings, or NULL if any one of the encodings failed.</p>
<p>Uses the x86/x64 mode stored in each instr, not the mode of the current thread.</p>
<p>In order for <a class="el" href="structinstr__t.html">instr_t</a> operands to be encoded properly, <code>has_instr_jmp_targets</code> must be true. If <code>has_instr_jmp_targets</code> is true, the note field of each <a class="el" href="structinstr__t.html">instr_t</a> in ilist will be overwritten, and if any <a class="el" href="structinstr__t.html">instr_t</a> targets are not in <code>ilist</code>, they must have their note fields set with their offsets relative to pc.</p>
<p>If <code>max_pc</code> is non-NULL, computes the total size required to encode the instruction liast before performing any encoding. If the whole list will not fit starting at <code>copy_pc</code> without exceeding <code>max_pc</code>, returns NULL without encoding anything. Otherwise encodes as normal. Note that x86 instructions can occupy up to 17 bytes each, so if <code>max_pc</code> is NULL, the caller should ensure the target location has enough room to avoid overflow. </p>

</div>
</div>
<a class="anchor" id="ac9a47c1b7376ca06d8dcb4b3094e5a67"></a><!-- doxytag: member="dr_ir_instrlist.h::instrlist_first" ref="ac9a47c1b7376ca06d8dcb4b3094e5a67" args="(instrlist_t *ilist)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structinstr__t.html">instr_t</a>* instrlist_first </td>
          <td>(</td>
          <td class="paramtype">instrlist_t *&nbsp;</td>
          <td class="paramname"> <em>ilist</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Returns the first <a class="el" href="structinstr__t.html">instr_t</a> in <code>ilist</code>. </p>

</div>
</div>
<a class="anchor" id="a18ae2e4d759afc814d47a52073bea348"></a><!-- doxytag: member="dr_ir_instrlist.h::instrlist_get_translation_target" ref="a18ae2e4d759afc814d47a52073bea348" args="(instrlist_t *ilist)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">app_pc instrlist_get_translation_target </td>
          <td>(</td>
          <td class="paramtype">instrlist_t *&nbsp;</td>
          <td class="paramname"> <em>ilist</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Returns the translation target, or NULL if none is set. </p>

</div>
</div>
<a class="anchor" id="a58f6c047c08e09d681dfcc6e35a0ef19"></a><!-- doxytag: member="dr_ir_instrlist.h::instrlist_init" ref="a58f6c047c08e09d681dfcc6e35a0ef19" args="(instrlist_t *ilist)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void instrlist_init </td>
          <td>(</td>
          <td class="paramtype">instrlist_t *&nbsp;</td>
          <td class="paramname"> <em>ilist</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Initializes <code>ilist</code>. </p>

</div>
</div>
<a class="anchor" id="ae2f37fe5e485b5aed7a196a5a1348d4a"></a><!-- doxytag: member="dr_ir_instrlist.h::instrlist_last" ref="ae2f37fe5e485b5aed7a196a5a1348d4a" args="(instrlist_t *ilist)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structinstr__t.html">instr_t</a>* instrlist_last </td>
          <td>(</td>
          <td class="paramtype">instrlist_t *&nbsp;</td>
          <td class="paramname"> <em>ilist</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Returns the last <a class="el" href="structinstr__t.html">instr_t</a> in <code>ilist</code>. </p>

</div>
</div>
<a class="anchor" id="ab98cd7319abad8ff223b00fb6f5c5bf8"></a><!-- doxytag: member="dr_ir_instrlist.h::instrlist_postinsert" ref="ab98cd7319abad8ff223b00fb6f5c5bf8" args="(instrlist_t *ilist, instr_t *where, instr_t *instr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void instrlist_postinsert </td>
          <td>(</td>
          <td class="paramtype">instrlist_t *&nbsp;</td>
          <td class="paramname"> <em>ilist</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structinstr__t.html">instr_t</a> *&nbsp;</td>
          <td class="paramname"> <em>where</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structinstr__t.html">instr_t</a> *&nbsp;</td>
          <td class="paramname"> <em>instr</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Inserts <code>instr</code> into <code>ilist</code> after <code>where</code>. </p>

</div>
</div>
<a class="anchor" id="a9c82c8b76c549a10ae88fa63eb85aa5b"></a><!-- doxytag: member="dr_ir_instrlist.h::instrlist_preinsert" ref="a9c82c8b76c549a10ae88fa63eb85aa5b" args="(instrlist_t *ilist, instr_t *where, instr_t *instr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void instrlist_preinsert </td>
          <td>(</td>
          <td class="paramtype">instrlist_t *&nbsp;</td>
          <td class="paramname"> <em>ilist</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structinstr__t.html">instr_t</a> *&nbsp;</td>
          <td class="paramname"> <em>where</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structinstr__t.html">instr_t</a> *&nbsp;</td>
          <td class="paramname"> <em>instr</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Inserts <code>instr</code> into <code>ilist</code> prior to <code>where</code>. </p>

</div>
</div>
<a class="anchor" id="a26415c0663dede10a65a6111110206ab"></a><!-- doxytag: member="dr_ir_instrlist.h::instrlist_prepend" ref="a26415c0663dede10a65a6111110206ab" args="(instrlist_t *ilist, instr_t *instr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void instrlist_prepend </td>
          <td>(</td>
          <td class="paramtype">instrlist_t *&nbsp;</td>
          <td class="paramname"> <em>ilist</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structinstr__t.html">instr_t</a> *&nbsp;</td>
          <td class="paramname"> <em>instr</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Adds <code>instr</code> to the front of <code>ilist</code>. </p>

</div>
</div>
<a class="anchor" id="a2bad28eed64877354dcf984ff672c7d9"></a><!-- doxytag: member="dr_ir_instrlist.h::instrlist_remove" ref="a2bad28eed64877354dcf984ff672c7d9" args="(instrlist_t *ilist, instr_t *instr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void instrlist_remove </td>
          <td>(</td>
          <td class="paramtype">instrlist_t *&nbsp;</td>
          <td class="paramname"> <em>ilist</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structinstr__t.html">instr_t</a> *&nbsp;</td>
          <td class="paramname"> <em>instr</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Removes (does not destroy) <code>instr</code> from <code>ilist</code>. </p>

</div>
</div>
<a class="anchor" id="a9bd1a00391f4ad909f67a31ea9163962"></a><!-- doxytag: member="dr_ir_instrlist.h::instrlist_replace" ref="a9bd1a00391f4ad909f67a31ea9163962" args="(instrlist_t *ilist, instr_t *oldinst, instr_t *newinst)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structinstr__t.html">instr_t</a>* instrlist_replace </td>
          <td>(</td>
          <td class="paramtype">instrlist_t *&nbsp;</td>
          <td class="paramname"> <em>ilist</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structinstr__t.html">instr_t</a> *&nbsp;</td>
          <td class="paramname"> <em>oldinst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structinstr__t.html">instr_t</a> *&nbsp;</td>
          <td class="paramname"> <em>newinst</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Replaces <code>oldinst</code> with <code>newinst</code> in <code>ilist</code> (does not destroy <code>oldinst</code>). </p>

</div>
</div>
<a class="anchor" id="a24c81467322f6eb86a8652ab1000fd2a"></a><!-- doxytag: member="dr_ir_instrlist.h::instrlist_set_fall_through_target" ref="a24c81467322f6eb86a8652ab1000fd2a" args="(instrlist_t *bb, app_pc tgt)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool instrlist_set_fall_through_target </td>
          <td>(</td>
          <td class="paramtype">instrlist_t *&nbsp;</td>
          <td class="paramname"> <em>bb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">app_pc&nbsp;</td>
          <td class="paramname"> <em>tgt</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Specifies the fall-through target of a basic block if its last instruction is a conditional branch instruction. It can only be called in basic block building event callbacks when the <code>for_trace</code> parameter is false, and has NO EFFECT in other cases. </p>

</div>
</div>
<a class="anchor" id="a71b0819b01546ec1b69063ba189a613e"></a><!-- doxytag: member="dr_ir_instrlist.h::instrlist_set_return_target" ref="a71b0819b01546ec1b69063ba189a613e" args="(instrlist_t *bb, app_pc tgt)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool instrlist_set_return_target </td>
          <td>(</td>
          <td class="paramtype">instrlist_t *&nbsp;</td>
          <td class="paramname"> <em>bb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">app_pc&nbsp;</td>
          <td class="paramname"> <em>tgt</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Specifies the return target of a basic block if its last instruction is a call instruction. It can only be called in basic block building event callbacks when the <code>for_trace</code> parameter is false, and has NO EFFECT in other cases. </p>

</div>
</div>
<a class="anchor" id="ae0f71aa213fbbf097e13a67042af52f0"></a><!-- doxytag: member="dr_ir_instrlist.h::instrlist_set_translation_target" ref="ae0f71aa213fbbf097e13a67042af52f0" args="(instrlist_t *ilist, app_pc pc)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void instrlist_set_translation_target </td>
          <td>(</td>
          <td class="paramtype">instrlist_t *&nbsp;</td>
          <td class="paramname"> <em>ilist</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">app_pc&nbsp;</td>
          <td class="paramname"> <em>pc</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>All future instructions inserted into <code>ilist</code> that do not have raw bits will have <a class="el" href="dr__ir__instr_8h.html#af1beda2d570ba04d74ca9cbd7c31bb1d">instr_set_translation()</a> called with <code>pc</code> as the target. This is a convenience routine to make it easy to have the same code generate non-translation and translation instructions, and it does not try to enforce that all instructions have translations (e.g., some could be inserted via <a class="el" href="dr__ir__instr_8h.html#ab0528e8567588400c3941b38b77f05af">instr_set_next()</a>). </p>

</div>
</div>
</div>
<hr size="1"><address style="text-align: center;"><small>
<img border=0 src="favicon.png"> &nbsp; DynamoRIO API version 3.2.0 --- Wed Mar 28 12:55:32 2012 
&nbsp; <img border=0 src="favicon.png">
</body>
</html>
