<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>DynamoRIO API: Function Wrapping and Replacing</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
<link rel="shortcut icon" type="image/x-icon" href="favicon.ico" />
</head><body>
<!-- Generated by Doxygen 1.6.3 -->
<div class="contents">
<h1>Function Wrapping and Replacing</h1><table border="0" cellpadding="0" cellspacing="0">
<tr><td colspan="2"><h2>Defines</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__drwrap.html#ga925e96b9b70bcf935279bfd79dbe6c7f">DRMGR_PRIORITY_NAME_DRWRAP</a>&nbsp;&nbsp;&nbsp;&quot;drwrap&quot;</td></tr>
<tr><td colspan="2"><h2>Enumerations</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom">{ <br/>
&nbsp;&nbsp;<a class="el" href="group__drwrap.html#gga4caf8d8f829279fba122163d961608a4a556c6bce97b9c415e089261848536c14">DRMGR_PRIORITY_APP2APP_DRWRAP</a> =  -500, 
<br/>
&nbsp;&nbsp;<a class="el" href="group__drwrap.html#gga4caf8d8f829279fba122163d961608a4ada17e11e67b93129fede7890e032bbbd">DRMGR_PRIORITY_INSERT_DRWRAP</a> =  500
<br/>
 }</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__drwrap.html#ga16cc419209fcb0024d010599bb82aa76">drwrap_wrap_flags_t</a> { <a class="el" href="group__drwrap.html#gga16cc419209fcb0024d010599bb82aa76aaee35c5aabcb42793293b905c448e1c6">DRWRAP_UNWIND_ON_EXCEPTION</a> =  0x01
 }</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__drwrap.html#gab82c71baab4fe0c5f9962383818b9c92">drwrap_global_flags_t</a> { <br/>
&nbsp;&nbsp;<a class="el" href="group__drwrap.html#ggab82c71baab4fe0c5f9962383818b9c92af1b2f3860316577a15e3430942febc8a">DRWRAP_SAFE_READ_RETADDR</a> =  0x01, 
<br/>
&nbsp;&nbsp;<a class="el" href="group__drwrap.html#ggab82c71baab4fe0c5f9962383818b9c92ab7a628a50b1344c943a703a72e5cfce9">DRWRAP_SAFE_READ_ARGS</a> =  0x02, 
<br/>
&nbsp;&nbsp;<a class="el" href="group__drwrap.html#ggab82c71baab4fe0c5f9962383818b9c92aeb299993e17993cb86912f93391f6b86">DRWRAP_NO_FRILLS</a> =  0x04, 
<br/>
&nbsp;&nbsp;<a class="el" href="group__drwrap.html#ggab82c71baab4fe0c5f9962383818b9c92add150e3e7ba4ee203a045b936f872b4b">DRWRAP_FAST_CLEANCALLS</a> =  0x08
<br/>
 }</td></tr>
<tr><td colspan="2"><h2>Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">DR_EXPORT bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__drwrap.html#ga23837833101ebc340ac7de6e8340bb4a">drwrap_init</a> (void)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">DR_EXPORT void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__drwrap.html#ga0e58babc53301c4ade4027dc1e09a088">drwrap_exit</a> (void)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">DR_EXPORT bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__drwrap.html#ga488a6566cd760a3919bdd2f49a6d672f">drwrap_replace</a> (app_pc original, app_pc replacement, bool override)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">DR_EXPORT bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__drwrap.html#ga4c004987daae07af15f2146c2d7d4b09">drwrap_wrap</a> (app_pc func, void(*pre_func_cb)(void *wrapcxt, OUT void **user_data), void(*post_func_cb)(void *wrapcxt, void *user_data))</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">DR_EXPORT bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__drwrap.html#gaff6f66f7ec021cea150eb753f5db2b75">drwrap_wrap_ex</a> (app_pc func, void(*pre_func_cb)(void *wrapcxt, INOUT void **user_data), void(*post_func_cb)(void *wrapcxt, void *user_data), void *user_data, <a class="el" href="group__drwrap.html#ga16cc419209fcb0024d010599bb82aa76">drwrap_wrap_flags_t</a> flags)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">DR_EXPORT bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__drwrap.html#ga27894370f3da794ff3f31cb8d7ec079b">drwrap_unwrap</a> (app_pc func, void(*pre_func_cb)(void *wrapcxt, OUT void **user_data), void(*post_func_cb)(void *wrapcxt, void *user_data))</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">DR_EXPORT app_pc&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__drwrap.html#ga92584c3e1980ac0c467de7d14d2bc2a2">drwrap_get_drcontext</a> (void *wrapcxt)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">DR_EXPORT app_pc&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__drwrap.html#ga106eb283e97c560a0118b8da211b7f1a">drwrap_get_func</a> (void *wrapcxt)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">DR_EXPORT <a class="el" href="struct__dr__mcontext__t.html">dr_mcontext_t</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__drwrap.html#ga9a33b1049986dd8975e94827f5c0e759">drwrap_get_mcontext</a> (void *wrapcxt)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">DR_EXPORT <a class="el" href="struct__dr__mcontext__t.html">dr_mcontext_t</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__drwrap.html#gac3a79cf043d8c21dc190721d9fb105de">drwrap_get_mcontext_ex</a> (void *wrapcxt, <a class="el" href="dr__defines_8h.html#af0434595b47158e7512c2bf5f0e43ae4">dr_mcontext_flags_t</a> flags)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">DR_EXPORT bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__drwrap.html#gae4a50709cf98fca89860c09543176fa6">drwrap_set_mcontext</a> (void *wrapcxt)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">DR_EXPORT app_pc&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__drwrap.html#ga2da9c1f9ef091b6856a98c6ce5e2a3f5">drwrap_get_retaddr</a> (void *wrapcxt)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">DR_EXPORT void *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__drwrap.html#ga3d0864daf1ec37a91640a739f8928b83">drwrap_get_arg</a> (void *wrapcxt, int arg)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">DR_EXPORT bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__drwrap.html#ga17937b1d8ff7e391814e4e6e6df5c807">drwrap_set_arg</a> (void *wrapcxt, int arg, void *val)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">DR_EXPORT void *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__drwrap.html#gae993f55e025cf80ae67ed398b35a1b61">drwrap_get_retval</a> (void *wrapcxt)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">DR_EXPORT bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__drwrap.html#gafd31e6725143df904e766dbfa508db05">drwrap_set_retval</a> (void *wrapcxt, void *val)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">DR_EXPORT bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__drwrap.html#gae539b1092ba0c1a3e86172964a671805">drwrap_skip_call</a> (void *wrapcxt, void *retval, size_t stdcall_args_size)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">DR_EXPORT bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__drwrap.html#ga0f84bd239ed2f9f3550d66b75fb9b392">drwrap_register_post_call_notify</a> (void(*cb)(app_pc pc))</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">DR_EXPORT bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__drwrap.html#ga1b4b6da75fceb5977ff1f82bf3ffd8c9">drwrap_unregister_post_call_notify</a> (void(*cb)(app_pc pc))</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">DR_EXPORT bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__drwrap.html#ga61b97c33203c704dd8ff1b9d31b3d2a9">drwrap_mark_as_post_call</a> (app_pc pc)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">DR_EXPORT bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__drwrap.html#gae2cc2affaf879182ba4d92299704c65f">drwrap_set_global_flags</a> (<a class="el" href="group__drwrap.html#gab82c71baab4fe0c5f9962383818b9c92">drwrap_global_flags_t</a> flags)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">DR_EXPORT bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__drwrap.html#ga01e56e9bac8f584fe25e806a24769d50">drwrap_is_wrapped</a> (app_pc func, void(*pre_func_cb)(void *wrapcxt, OUT void **user_data), void(*post_func_cb)(void *wrapcxt, void *user_data))</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">DR_EXPORT bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__drwrap.html#ga16fc2d260f5ebead724d5eb98bf13ac2">drwrap_is_post_wrap</a> (app_pc pc)</td></tr>
</table>
<hr/><h2>Define Documentation</h2>
<a class="anchor" id="ga925e96b9b70bcf935279bfd79dbe6c7f"></a><!-- doxytag: member="drwrap.h::DRMGR_PRIORITY_NAME_DRWRAP" ref="ga925e96b9b70bcf935279bfd79dbe6c7f" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define DRMGR_PRIORITY_NAME_DRWRAP&nbsp;&nbsp;&nbsp;&quot;drwrap&quot;</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Name of drmgr instrumentation pass priorities for both app2app and insert </p>

</div>
</div>
<hr/><h2>Enumeration Type Documentation</h2>
<a class="anchor" id="ga4caf8d8f829279fba122163d961608a4"></a><!-- doxytag: member="drwrap.h::@33" ref="ga4caf8d8f829279fba122163d961608a4" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">anonymous enum</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Priorities of drmgr instrumentation passes used by drwrap. Users of drwrap can use the name DRMGR_PRIORITY_NAME_DRWRAP in the <a class="el" href="struct__drmgr__priority__t.html#ac73be551eedc5f37043fb752b30eec32">drmgr_priority_t.before</a> field or can use these numeric priorities in the <a class="el" href="struct__drmgr__priority__t.html#a2e46fa4cbefc2dc32f3bc73e8bd82d3e">drmgr_priority_t.priority</a> field to ensure proper instrumentation pass ordering. </p>
<dl><dt><b>Enumerator: </b></dt><dd><table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" id="gga4caf8d8f829279fba122163d961608a4a556c6bce97b9c415e089261848536c14"></a><!-- doxytag: member="DRMGR_PRIORITY_APP2APP_DRWRAP" ref="gga4caf8d8f829279fba122163d961608a4a556c6bce97b9c415e089261848536c14" args="" -->DRMGR_PRIORITY_APP2APP_DRWRAP</em>&nbsp;</td><td>
<p>Priority of drwap_replace() </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="gga4caf8d8f829279fba122163d961608a4ada17e11e67b93129fede7890e032bbbd"></a><!-- doxytag: member="DRMGR_PRIORITY_INSERT_DRWRAP" ref="gga4caf8d8f829279fba122163d961608a4ada17e11e67b93129fede7890e032bbbd" args="" -->DRMGR_PRIORITY_INSERT_DRWRAP</em>&nbsp;</td><td>
<p>Priority of <a class="el" href="group__drwrap.html#ga4c004987daae07af15f2146c2d7d4b09">drwrap_wrap()</a> </p>
</td></tr>
</table>
</dd>
</dl>

</div>
</div>
<a class="anchor" id="gab82c71baab4fe0c5f9962383818b9c92"></a><!-- doxytag: member="drwrap.h::drwrap_global_flags_t" ref="gab82c71baab4fe0c5f9962383818b9c92" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__drwrap.html#gab82c71baab4fe0c5f9962383818b9c92">drwrap_global_flags_t</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Values for the flags parameter to <a class="el" href="group__drwrap.html#gae2cc2affaf879182ba4d92299704c65f">drwrap_set_global_flags()</a> </p>
<dl><dt><b>Enumerator: </b></dt><dd><table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" id="ggab82c71baab4fe0c5f9962383818b9c92af1b2f3860316577a15e3430942febc8a"></a><!-- doxytag: member="DRWRAP_SAFE_READ_RETADDR" ref="ggab82c71baab4fe0c5f9962383818b9c92af1b2f3860316577a15e3430942febc8a" args="" -->DRWRAP_SAFE_READ_RETADDR</em>&nbsp;</td><td>
<p>By default the return address is read directly. A more conservative and safe approach would use a safe read to avoid crashing when the stack is unsafe to access. This flag will cause the return address to be read safely. If any call to <a class="el" href="group__drwrap.html#gae2cc2affaf879182ba4d92299704c65f">drwrap_set_global_flags()</a> sets this flag, no later call can remove it. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ggab82c71baab4fe0c5f9962383818b9c92ab7a628a50b1344c943a703a72e5cfce9"></a><!-- doxytag: member="DRWRAP_SAFE_READ_ARGS" ref="ggab82c71baab4fe0c5f9962383818b9c92ab7a628a50b1344c943a703a72e5cfce9" args="" -->DRWRAP_SAFE_READ_ARGS</em>&nbsp;</td><td>
<p>By default function arguments stored in memory are read and written directly. A more conservative and safe approach would use a safe read or write to avoid crashing when the stack is unsafe to access. This flag will cause all arguments in memory to be read and written safely. If any call to <a class="el" href="group__drwrap.html#gae2cc2affaf879182ba4d92299704c65f">drwrap_set_global_flags()</a> sets this flag, no later call can remove it. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ggab82c71baab4fe0c5f9962383818b9c92aeb299993e17993cb86912f93391f6b86"></a><!-- doxytag: member="DRWRAP_NO_FRILLS" ref="ggab82c71baab4fe0c5f9962383818b9c92aeb299993e17993cb86912f93391f6b86" args="" -->DRWRAP_NO_FRILLS</em>&nbsp;</td><td>
<p>If this flag is set, then a leaner wrapping mechanism is used with lower overhead. However, several features are not supported with this flag:</p>
<ul>
<li>Only one wrap request per address is allowed. A second request will fail, even if an earlier request was unwrapped, unless the same pre and post callback functions are used.</li>
<li>Wrapping should occur prior to any execution (e.g., at startup or module load time). A new wrap request that occurs between the pre and post wrap points may have its post callback called even though its pre callback was never called.</li>
<li>Unwrapping should only happen on module unload. It is not supported between a pre and post callback. Only set this flag if you are certain that all uses of wrapping in your client and all libraries it uses can abide the above restrictions. Once set, this flag cannot be unset. </li>
</ul>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ggab82c71baab4fe0c5f9962383818b9c92add150e3e7ba4ee203a045b936f872b4b"></a><!-- doxytag: member="DRWRAP_FAST_CLEANCALLS" ref="ggab82c71baab4fe0c5f9962383818b9c92add150e3e7ba4ee203a045b936f872b4b" args="" -->DRWRAP_FAST_CLEANCALLS</em>&nbsp;</td><td>
<p>If this flag is set, then a leaner clean call is used to invoke wrap pre callbacks. This clean call assumes that all wrap requests are for function entrance points and that standard ABI calling conventions are used for those functions. This means that caller-saved registers may not be saved and thus will have invalid values in <a class="el" href="group__drwrap.html#ga9a33b1049986dd8975e94827f5c0e759">drwrap_get_mcontext()</a>. When using this setting and skipping a function via <a class="el" href="group__drwrap.html#gae539b1092ba0c1a3e86172964a671805">drwrap_skip_call()</a> (or calling <a class="el" href="dr__ir__utils_8h.html#a9f612cf9d0ca2025b23d30b6f5bb0231">dr_redirect_execution()</a> directly), setting xmm registers (in particular those used as return values) will work correctly (of course, be sure to retrieve the existing xmm values via <a class="el" href="group__drwrap.html#ga9a33b1049986dd8975e94827f5c0e759">drwrap_get_mcontext()</a> or drwrap_get_mcontext_ex(DR_MC_ALL) first).</p>
<p>Only set this flag if you are certain that all uses of wrapping in your client and all libraries it uses can abide the above restrictions. Once set, this flag cannot be unset. </p>
</td></tr>
</table>
</dd>
</dl>

</div>
</div>
<a class="anchor" id="ga16cc419209fcb0024d010599bb82aa76"></a><!-- doxytag: member="drwrap.h::drwrap_wrap_flags_t" ref="ga16cc419209fcb0024d010599bb82aa76" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__drwrap.html#ga16cc419209fcb0024d010599bb82aa76">drwrap_wrap_flags_t</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Values for the flags parameter to <a class="el" href="group__drwrap.html#gaff6f66f7ec021cea150eb753f5db2b75">drwrap_wrap_ex()</a> </p>
<dl><dt><b>Enumerator: </b></dt><dd><table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" id="gga16cc419209fcb0024d010599bb82aa76aaee35c5aabcb42793293b905c448e1c6"></a><!-- doxytag: member="DRWRAP_UNWIND_ON_EXCEPTION" ref="gga16cc419209fcb0024d010599bb82aa76aaee35c5aabcb42793293b905c448e1c6" args="" -->DRWRAP_UNWIND_ON_EXCEPTION</em>&nbsp;</td><td>
<p>If this flag is set, then when a Windows exception occurs, all post-call callbacks for all live wrapped functions on the wrap stack for which <code>unwind_on_exception</code> is true are called. If this flag is not set (the default), each post-call callback will still be called if drwrap's heuristics later detect that that particular callback has been bypassed, but those heuristics are not guaranteed. </p>
</td></tr>
</table>
</dd>
</dl>

</div>
</div>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="ga0e58babc53301c4ade4027dc1e09a088"></a><!-- doxytag: member="drwrap.h::drwrap_exit" ref="ga0e58babc53301c4ade4027dc1e09a088" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DR_EXPORT void drwrap_exit </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Cleans up the drwrap extension. </p>

</div>
</div>
<a class="anchor" id="ga3d0864daf1ec37a91640a739f8928b83"></a><!-- doxytag: member="drwrap.h::drwrap_get_arg" ref="ga3d0864daf1ec37a91640a739f8928b83" args="(void *wrapcxt, int arg)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DR_EXPORT void* drwrap_get_arg </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>wrapcxt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>arg</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Returns the value of the <code>arg-th</code> argument (0-based) to the wrapped function represented by <code>wrapcxt</code>. Assumes the regular C calling convention (i.e., no fastcall). May only be called from a <code>drwrap_wrap</code> pre-function callback. To access argument values in a post-function callback, store them in the <code>user_data</code> parameter passed between the pre and post functions.</p>
<p>This routine may de-reference application memory directly, so the caller should wrap in DR_TRY_EXCEPT if crashes must be avoided. </p>

</div>
</div>
<a class="anchor" id="ga92584c3e1980ac0c467de7d14d2bc2a2"></a><!-- doxytag: member="drwrap.h::drwrap_get_drcontext" ref="ga92584c3e1980ac0c467de7d14d2bc2a2" args="(void *wrapcxt)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DR_EXPORT app_pc drwrap_get_drcontext </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>wrapcxt</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Returns the DynamoRIO context. This routine can be faster than <a class="el" href="dr__tools_8h.html#a13217cc252506b06184c7c72adedf26c">dr_get_current_drcontext()</a> but should return the same result. </p>

</div>
</div>
<a class="anchor" id="ga106eb283e97c560a0118b8da211b7f1a"></a><!-- doxytag: member="drwrap.h::drwrap_get_func" ref="ga106eb283e97c560a0118b8da211b7f1a" args="(void *wrapcxt)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DR_EXPORT app_pc drwrap_get_func </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>wrapcxt</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Returns the address of the wrapped function represented by <code>wrapcxt</code>. </p>

</div>
</div>
<a class="anchor" id="ga9a33b1049986dd8975e94827f5c0e759"></a><!-- doxytag: member="drwrap.h::drwrap_get_mcontext" ref="ga9a33b1049986dd8975e94827f5c0e759" args="(void *wrapcxt)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DR_EXPORT <a class="el" href="struct__dr__mcontext__t.html">dr_mcontext_t</a>* drwrap_get_mcontext </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>wrapcxt</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Returns the machine context of the wrapped function represented by <code>wrapcxt</code> corresponding to the application state at the time of the pre-function or post-function wrap callback. In order for any changes to the returned context to take effect, <a class="el" href="group__drwrap.html#gae4a50709cf98fca89860c09543176fa6">drwrap_set_mcontext()</a> must be called.</p>
<dl class="note"><dt><b>Note:</b></dt><dd>if the <a class="el" href="group__drwrap.html#ggab82c71baab4fe0c5f9962383818b9c92add150e3e7ba4ee203a045b936f872b4b">DRWRAP_FAST_CLEANCALLS</a> flag is set, caller-saved register values in the fields controlled by <a class="el" href="dr__defines_8h.html#af0434595b47158e7512c2bf5f0e43ae4af3780bef723b8bf1a34eb75125f7f122">DR_MC_MULTIMEDIA</a> will not contain valid values. </dd></dl>

</div>
</div>
<a class="anchor" id="gac3a79cf043d8c21dc190721d9fb105de"></a><!-- doxytag: member="drwrap.h::drwrap_get_mcontext_ex" ref="gac3a79cf043d8c21dc190721d9fb105de" args="(void *wrapcxt, dr_mcontext_flags_t flags)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DR_EXPORT <a class="el" href="struct__dr__mcontext__t.html">dr_mcontext_t</a>* drwrap_get_mcontext_ex </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>wrapcxt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="dr__defines_8h.html#af0434595b47158e7512c2bf5f0e43ae4">dr_mcontext_flags_t</a>&nbsp;</td>
          <td class="paramname"> <em>flags</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Identical to <a class="el" href="group__drwrap.html#ga9a33b1049986dd8975e94827f5c0e759">drwrap_get_mcontext()</a> but only fills in the state indicated by <code>flags</code>. </p>

</div>
</div>
<a class="anchor" id="ga2da9c1f9ef091b6856a98c6ce5e2a3f5"></a><!-- doxytag: member="drwrap.h::drwrap_get_retaddr" ref="ga2da9c1f9ef091b6856a98c6ce5e2a3f5" args="(void *wrapcxt)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DR_EXPORT app_pc drwrap_get_retaddr </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>wrapcxt</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Returns the return address of the wrapped function represented by <code>wrapcxt</code>.</p>
<p>This routine may de-reference application memory directly, so the caller should wrap in DR_TRY_EXCEPT if crashes must be avoided. </p>

</div>
</div>
<a class="anchor" id="gae993f55e025cf80ae67ed398b35a1b61"></a><!-- doxytag: member="drwrap.h::drwrap_get_retval" ref="gae993f55e025cf80ae67ed398b35a1b61" args="(void *wrapcxt)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DR_EXPORT void* drwrap_get_retval </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>wrapcxt</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Returns the return value of the wrapped function represented by <code>wrapcxt</code>. Assumes a pointer-sized return value. May only be called from a <code>drwrap_wrap</code> post-function callback. </p>

</div>
</div>
<a class="anchor" id="ga23837833101ebc340ac7de6e8340bb4a"></a><!-- doxytag: member="drwrap.h::drwrap_init" ref="ga23837833101ebc340ac7de6e8340bb4a" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DR_EXPORT bool drwrap_init </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Initializes the drwrap extension. Must be called prior to any of the other routines, and should only be called once.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>whether successful. Will return false if called a second time. </dd></dl>

</div>
</div>
<a class="anchor" id="ga16fc2d260f5ebead724d5eb98bf13ac2"></a><!-- doxytag: member="drwrap.h::drwrap_is_post_wrap" ref="ga16fc2d260f5ebead724d5eb98bf13ac2" args="(app_pc pc)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DR_EXPORT bool drwrap_is_post_wrap </td>
          <td>(</td>
          <td class="paramtype">app_pc&nbsp;</td>
          <td class="paramname"> <em>pc</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl class="return"><dt><b>Returns:</b></dt><dd>whether <code>pc</code> is currently considered a post-wrap point, for any wrap request. </dd></dl>

</div>
</div>
<a class="anchor" id="ga01e56e9bac8f584fe25e806a24769d50"></a><!-- doxytag: member="drwrap.h::drwrap_is_wrapped" ref="ga01e56e9bac8f584fe25e806a24769d50" args="(app_pc func, void(*pre_func_cb)(void *wrapcxt, OUT void **user_data), void(*post_func_cb)(void *wrapcxt, void *user_data))" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DR_EXPORT bool drwrap_is_wrapped </td>
          <td>(</td>
          <td class="paramtype">app_pc&nbsp;</td>
          <td class="paramname"> <em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(*)(void *wrapcxt, OUT void **user_data)&nbsp;</td>
          <td class="paramname"> <em>pre_func_cb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(*)(void *wrapcxt, void *user_data)&nbsp;</td>
          <td class="paramname"> <em>post_func_cb</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl class="return"><dt><b>Returns:</b></dt><dd>whether <code>func</code> is currently wrapped with <code>pre_func_cb</code> and <code>post_func_cb</code>. </dd></dl>

</div>
</div>
<a class="anchor" id="ga61b97c33203c704dd8ff1b9d31b3d2a9"></a><!-- doxytag: member="drwrap.h::drwrap_mark_as_post_call" ref="ga61b97c33203c704dd8ff1b9d31b3d2a9" args="(app_pc pc)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DR_EXPORT bool drwrap_mark_as_post_call </td>
          <td>(</td>
          <td class="paramtype">app_pc&nbsp;</td>
          <td class="paramname"> <em>pc</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Records the address <code>pc</code> as a post-call address for instrumentation for post-call function wrapping purposes.</p>
<dl class="note"><dt><b>Note:</b></dt><dd>Only call this when the code leading up to <code>pc</code> is legitimate, as that code will be stored for consistency purposes and the post-call entry will be invalidated if it changes. This means that when using this routine for the performance purposes described in the <a class="el" href="group__drwrap.html#ga0f84bd239ed2f9f3550d66b75fb9b392">drwrap_register_post_call_notify()</a> documentation, the tool should wait for a newly loaded module to be relocated before calling this routine. A good approach is to wait for the first execution of code from the new module.</dd></dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>whether successful. </dd></dl>

</div>
</div>
<a class="anchor" id="ga0f84bd239ed2f9f3550d66b75fb9b392"></a><!-- doxytag: member="drwrap.h::drwrap_register_post_call_notify" ref="ga0f84bd239ed2f9f3550d66b75fb9b392" args="(void(*cb)(app_pc pc))" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DR_EXPORT bool drwrap_register_post_call_notify </td>
          <td>(</td>
          <td class="paramtype">void(*)(app_pc pc)&nbsp;</td>
          <td class="paramname"> <em>cb</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Registers a callback <code>cb</code> to be called every time a new post-call address is encountered. The intended use is for tools that want faster start-up time by avoiding flushes for inserting wrap instrumentation at post-call sites. A tool can use this callback to record all of the post-call addresses to disk, and use <a class="el" href="group__drwrap.html#ga61b97c33203c704dd8ff1b9d31b3d2a9">drwrap_mark_as_post_call()</a> during module load of the next execution. It is up to the tool to verify that the module has not changed since its addresses were recorded.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>whether successful. </dd></dl>

</div>
</div>
<a class="anchor" id="ga488a6566cd760a3919bdd2f49a6d672f"></a><!-- doxytag: member="drwrap.h::drwrap_replace" ref="ga488a6566cd760a3919bdd2f49a6d672f" args="(app_pc original, app_pc replacement, bool override)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DR_EXPORT bool drwrap_replace </td>
          <td>(</td>
          <td class="paramtype">app_pc&nbsp;</td>
          <td class="paramname"> <em>original</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">app_pc&nbsp;</td>
          <td class="paramname"> <em>replacement</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>override</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Replaces the application function that starts at the address <code>original</code> with the code at the address <code>replacement</code>.</p>
<p>Only one replacement is supported per target address. If a replacement already exists for <code>original</code>, this function fails unless <code>override</code> is true, in which case it replaces the prior replacement. To remove a replacement, pass NULL for <code>replacement</code> and <b>true</b> for <code>override</code>. When removing or replacing a prior replacement, existing replaced code in the code cache will be flushed lazily: i.e., there may be some execution in other threads after this call is made.</p>
<p>When replacing a function, it is up to the user to ensure that the replacement mirrors the calling convention and other semantics of the original function. The replacement code will be executed as application code, NOT as client code.</p>
<dl class="note"><dt><b>Note:</b></dt><dd>The priority of the app2app pass used here is DRMGR_PRIORITY_APP2APP_DRWRAP and its name is DRMGR_PRIORITY_NAME_DRWRAP.</dd></dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>whether successful. </dd></dl>

</div>
</div>
<a class="anchor" id="ga17937b1d8ff7e391814e4e6e6df5c807"></a><!-- doxytag: member="drwrap.h::drwrap_set_arg" ref="ga17937b1d8ff7e391814e4e6e6df5c807" args="(void *wrapcxt, int arg, void *val)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DR_EXPORT bool drwrap_set_arg </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>wrapcxt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>arg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>val</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Sets the the <code>arg-th</code> argument (0-based) to the wrapped function represented by <code>wrapcxt</code> to <code>val</code>. Assumes the regular C calling convention (i.e., no fastcall). May only be called from a <code>drwrap_wrap</code> pre-function callback. To access argument values in a post-function callback, store them in the <code>user_data</code> parameter passed between the pre and post functions.</p>
<p>This routine may write to application memory directly, so the caller should wrap in DR_TRY_EXCEPT if crashes must be avoided. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>whether successful. </dd></dl>

</div>
</div>
<a class="anchor" id="gae2cc2affaf879182ba4d92299704c65f"></a><!-- doxytag: member="drwrap.h::drwrap_set_global_flags" ref="gae2cc2affaf879182ba4d92299704c65f" args="(drwrap_global_flags_t flags)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DR_EXPORT bool drwrap_set_global_flags </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__drwrap.html#gab82c71baab4fe0c5f9962383818b9c92">drwrap_global_flags_t</a>&nbsp;</td>
          <td class="paramname"> <em>flags</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Sets flags that affect the global behavior of the drwrap module. This can be called at any time and it will affect future behavior. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>whether the flags were changed. </dd></dl>

</div>
</div>
<a class="anchor" id="gae4a50709cf98fca89860c09543176fa6"></a><!-- doxytag: member="drwrap.h::drwrap_set_mcontext" ref="gae4a50709cf98fca89860c09543176fa6" args="(void *wrapcxt)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DR_EXPORT bool drwrap_set_mcontext </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>wrapcxt</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Propagates any changes made to the dr_mcontext_t pointed by <a class="el" href="group__drwrap.html#ga9a33b1049986dd8975e94827f5c0e759">drwrap_get_mcontext()</a> back to the application.</p>
<dl class="note"><dt><b>Note:</b></dt><dd>if the <a class="el" href="group__drwrap.html#ggab82c71baab4fe0c5f9962383818b9c92add150e3e7ba4ee203a045b936f872b4b">DRWRAP_FAST_CLEANCALLS</a> flag is set, caller-saved register values in the fields controlled by <a class="el" href="dr__defines_8h.html#af0434595b47158e7512c2bf5f0e43ae4af3780bef723b8bf1a34eb75125f7f122">DR_MC_MULTIMEDIA</a> will not contain valid values, but this should be fine because their values were scratch according to the ABI at the wrap point.. </dd></dl>

</div>
</div>
<a class="anchor" id="gafd31e6725143df904e766dbfa508db05"></a><!-- doxytag: member="drwrap.h::drwrap_set_retval" ref="gafd31e6725143df904e766dbfa508db05" args="(void *wrapcxt, void *val)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DR_EXPORT bool drwrap_set_retval </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>wrapcxt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>val</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Sets the return value of the wrapped function represented by <code>wrapcxt</code> to <code>val</code>. Assumes a pointer-sized return value. May only be called from a <code>drwrap_wrap</code> post-function callback. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>whether successful. </dd></dl>

</div>
</div>
<a class="anchor" id="gae539b1092ba0c1a3e86172964a671805"></a><!-- doxytag: member="drwrap.h::drwrap_skip_call" ref="gae539b1092ba0c1a3e86172964a671805" args="(void *wrapcxt, void *retval, size_t stdcall_args_size)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DR_EXPORT bool drwrap_skip_call </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>wrapcxt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>retval</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>stdcall_args_size</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>May only be called from a <code>drwrap_wrap</code> pre-function callback. Skips execution of the original function and returns to the function's caller with a return value of <code>retval</code>. The post-function callback will not be invoked; nor will any pre-function callbacks (if multiple were registered) that have not yet been called. If the original function uses the <code>stdcall</code> calling convention, the total size of its arguments must be supplied. The return value is set regardless of whether the original function officially returns a value or not. Further state changes may be made with <a class="el" href="group__drwrap.html#ga9a33b1049986dd8975e94827f5c0e759">drwrap_get_mcontext()</a> and <a class="el" href="group__drwrap.html#gae4a50709cf98fca89860c09543176fa6">drwrap_set_mcontext()</a> prior to calling this function.</p>
<dl class="note"><dt><b>Note:</b></dt><dd>It is up to the client to ensure that the application behaves as desired when the original function is skipped.</dd></dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>whether successful. </dd></dl>

</div>
</div>
<a class="anchor" id="ga1b4b6da75fceb5977ff1f82bf3ffd8c9"></a><!-- doxytag: member="drwrap.h::drwrap_unregister_post_call_notify" ref="ga1b4b6da75fceb5977ff1f82bf3ffd8c9" args="(void(*cb)(app_pc pc))" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DR_EXPORT bool drwrap_unregister_post_call_notify </td>
          <td>(</td>
          <td class="paramtype">void(*)(app_pc pc)&nbsp;</td>
          <td class="paramname"> <em>cb</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Unregisters a callback registered with <a class="el" href="group__drwrap.html#ga0f84bd239ed2f9f3550d66b75fb9b392">drwrap_register_post_call_notify()</a>. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>whether successful. </dd></dl>

</div>
</div>
<a class="anchor" id="ga27894370f3da794ff3f31cb8d7ec079b"></a><!-- doxytag: member="drwrap.h::drwrap_unwrap" ref="ga27894370f3da794ff3f31cb8d7ec079b" args="(app_pc func, void(*pre_func_cb)(void *wrapcxt, OUT void **user_data), void(*post_func_cb)(void *wrapcxt, void *user_data))" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DR_EXPORT bool drwrap_unwrap </td>
          <td>(</td>
          <td class="paramtype">app_pc&nbsp;</td>
          <td class="paramname"> <em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(*)(void *wrapcxt, OUT void **user_data)&nbsp;</td>
          <td class="paramname"> <em>pre_func_cb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(*)(void *wrapcxt, void *user_data)&nbsp;</td>
          <td class="paramname"> <em>post_func_cb</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Removes a previously-requested wrap for the function <code>func</code> and the callback pair <code>pre_func_cb</code> and <code>post_func_cb</code>. This must be the same pair that was passed to <code>dr_wrap</code>.</p>
<p>This routine can be called from <code>pre_func_cb</code> or <code>post_func_cb</code>.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>whether successful. </dd></dl>

</div>
</div>
<a class="anchor" id="ga4c004987daae07af15f2146c2d7d4b09"></a><!-- doxytag: member="drwrap.h::drwrap_wrap" ref="ga4c004987daae07af15f2146c2d7d4b09" args="(app_pc func, void(*pre_func_cb)(void *wrapcxt, OUT void **user_data), void(*post_func_cb)(void *wrapcxt, void *user_data))" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DR_EXPORT bool drwrap_wrap </td>
          <td>(</td>
          <td class="paramtype">app_pc&nbsp;</td>
          <td class="paramname"> <em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(*)(void *wrapcxt, OUT void **user_data)&nbsp;</td>
          <td class="paramname"> <em>pre_func_cb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(*)(void *wrapcxt, void *user_data)&nbsp;</td>
          <td class="paramname"> <em>post_func_cb</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Wraps the application function that starts at the address <code>original</code> by calling <code>pre_func_cb</code> prior to every invocation of <code>original</code> and calling <code>post_func_cb</code> after every invocation of <code>original</code>. One of the callbacks can be NULL, but not both.</p>
<p>Multiple wrap requests are allowed for one <code>original</code> function (unless <a class="el" href="group__drwrap.html#ggab82c71baab4fe0c5f9962383818b9c92aeb299993e17993cb86912f93391f6b86">DRWRAP_NO_FRILLS</a> is set). Their callbacks are called sequentially in the reverse order of registration.</p>
<p>The <code>pre_func_cb</code> can examine (<a class="el" href="group__drwrap.html#ga3d0864daf1ec37a91640a739f8928b83">drwrap_get_arg()</a>) and set (<a class="el" href="group__drwrap.html#ga17937b1d8ff7e391814e4e6e6df5c807">drwrap_set_arg()</a>) the arguments to <code>original</code> and can skip the call to <code>original</code> (<a class="el" href="group__drwrap.html#gae539b1092ba0c1a3e86172964a671805">drwrap_skip_call()</a>). The <code>post_func_cb</code> can examine (<a class="el" href="group__drwrap.html#gae993f55e025cf80ae67ed398b35a1b61">drwrap_get_retval()</a>) and set (<a class="el" href="group__drwrap.html#gafd31e6725143df904e766dbfa508db05">drwrap_set_retval()</a>) <code>original's</code> return value. The opaque pointer <code>wrapcxt</code> passed to each callback should be passed to these routines.</p>
<p>When an abnormal stack unwind, such as longjmp or a Windows exception, occurs, drwrap does its best to detect it. All post-calls that would be missed will still be invoked, but with <code>wrapcxt</code> set to NULL. Since there is no post-call environment, it does not make sense to query the return value or arguments. The call is invoked to allow for cleanup of state allocated in <code>pre_func_cb</code>. However, detection of a stack unwind is not guaranteed. When wrapping a series of functions that do not themselves contain exception handlers, pass the DRWRAP_UNWIND_ON_EXCEPTION flag to <a class="el" href="group__drwrap.html#gaff6f66f7ec021cea150eb753f5db2b75">drwrap_wrap_ex()</a> to ensure that all post-call callbacks will be called on an exception.</p>
<dl class="note"><dt><b>Note:</b></dt><dd>The priority of the app2app pass used here is DRMGR_PRIORITY_INSERT_DRWRAP and its name is DRMGR_PRIORITY_NAME_DRWRAP.</dd></dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>whether successful. </dd></dl>

</div>
</div>
<a class="anchor" id="gaff6f66f7ec021cea150eb753f5db2b75"></a><!-- doxytag: member="drwrap.h::drwrap_wrap_ex" ref="gaff6f66f7ec021cea150eb753f5db2b75" args="(app_pc func, void(*pre_func_cb)(void *wrapcxt, INOUT void **user_data), void(*post_func_cb)(void *wrapcxt, void *user_data), void *user_data, drwrap_wrap_flags_t flags)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DR_EXPORT bool drwrap_wrap_ex </td>
          <td>(</td>
          <td class="paramtype">app_pc&nbsp;</td>
          <td class="paramname"> <em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(*)(void *wrapcxt, INOUT void **user_data)&nbsp;</td>
          <td class="paramname"> <em>pre_func_cb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(*)(void *wrapcxt, void *user_data)&nbsp;</td>
          <td class="paramname"> <em>post_func_cb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>user_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__drwrap.html#ga16cc419209fcb0024d010599bb82aa76">drwrap_wrap_flags_t</a>&nbsp;</td>
          <td class="paramname"> <em>flags</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Identical to <a class="el" href="group__drwrap.html#ga4c004987daae07af15f2146c2d7d4b09">drwrap_wrap()</a> except for two additional parameters: <code>user_data</code>, which is passed as the initial value of *user_data to <code>pre_func_cb</code>, and <code>flags</code>. </p>

</div>
</div>
</div>
<hr size="1"><address style="text-align: center;"><small>
<img border=0 src="favicon.png"> &nbsp; DynamoRIO API version 3.2.0 --- Wed Mar 28 12:55:33 2012 
&nbsp; <img border=0 src="favicon.png">
</body>
</html>
