<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>DynamoRIO API: Multi-Instrumentation Manager</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
<link rel="shortcut icon" type="image/x-icon" href="favicon.ico" />
</head><body>
<!-- Generated by Doxygen 1.6.3 -->
<div class="contents">


<h1><a class="anchor" id="page_drmgr">Multi-Instrumentation Manager </a></h1><p>The <code>drmgr</code> DynamoRIO Extension provides a mediator for combining and coordinating multiple instrumentation passes. It replaces certain DynamoRIO events and API routines with its own versions that mediate among multiple components, typically several libraries and one client, though it is also useful for splitting a client up into modules. <code>drmgr</code> facilitates developing instrumentation frameworks and libraries that can be composed and combined.</p>
<ul>
<li><a class="el" href="page__drmgr.html#sec_drmgr_setup">Setup</a></li>
<li><a class="el" href="page__drmgr.html#sec_drmgr_stages">Instrumentation Stages</a></li>
<li><a class="el" href="page__drmgr.html#sec_drmgr_tls">Thread-Local and Callback-Local Storage</a></li>
<li><a class="el" href="page__drmgr.html#sec_drmgr_notes">Instruction Note Fields</a></li>
</ul>
<h2><a class="anchor" id="sec_drmgr_setup">
Setup</a></h2>
<p>To use <code>drmgr</code> with your client simply include this line in your client's <code>CMakeLists.txt</code> file:</p>
<div class="fragment"><pre class="fragment"> use_DynamoRIO_extension(clientname drmgr) 
</pre></div><p>That will automatically set up the include path and library dependence.</p>
<p>The <code><a class="el" href="group__drmgr.html#ga07ab03a2182247922f756778d18bb3fd">drmgr_init()</a></code> function must be called only once, so typically a library that uses <code>drmgr</code> will not invoke it and will require that the end user (the client) invoke it prior to the library's initialization routine.</p>
<h2><a class="anchor" id="sec_drmgr_stages">
Instrumentation Stages</a></h2>
<p><code>drmgr</code> divides code changes into three types:</p>
<ol type="1">
<li>Application-to-application transformations: changes to the application code itself that are meant to affect application behavior or application performance</li>
<li>Instrumentation insertion: monitoring code added between the application instructions</li>
<li>Instrumentation-to-instrumentation transformations: typically, optimizations applied to the full set of inserted instrumentation</li>
</ol>
<p>Instrumentation insertion is split into two pieces: analysis of the full application code (after any changes from its original form), followed by insertion of instrumentation, one instruction at a time. The result is four separate, sequential stages:</p>
<ol type="1">
<li>Application-to-application transformations</li>
<li>Application code analysis</li>
<li>Instrumentation insertion, one instruction at a time</li>
<li>Instrumentation-to-instrumentation transformations</li>
</ol>
<p>Each component that registers with <code>drmgr</code> can register for some or all of the four stages. In each stage, each registered compoment's callback is invoked. This groups the different types of changes together and allows them to assume that no later change will invalidate their analysis or actions. The instrumentation insertion is performed in one forward pass: for each instruction, each registered component is invoked. This simplifies register allocation (register allocation is provided by a separate Extension <code>drreg</code>).</p>
<h3><a class="anchor" id="sec_drmgr_ordering">
Ordering</a></h3>
<p>The proper ordering of instrumentation passes depends on the particulars of what each pass is doing. <code>drmgr</code> supports naming each pass and specifying relative ordering by requesting that one pass occur before and/or after another named pass. Numeric priorities are also supported for resolving order among identical placement once named ordering is resolved.</p>
<p>Some ordering rules do apply. For example, function replacing should occur before most other application transformations. Ordering of instrumentation insertion and especially instrumentation-to-instrumentation transformations can be highly dependent on exact transformations involved. Care should be taken when ordering passes within each stage.</p>
<h3><a class="anchor" id="sec_drmgr_traces">
Traces</a></h3>
<p><code>drmgr</code> does not mediate trace instrumentation. Those interested in hot code should use the <code>drmgr</code> basic block events and act only when the <code>for_trace</code> parameter is set. Those wanting to optimize the longer code sequences in traces are on their own for register allocation, and must be careful to handle instrumentation that has already been added from the basic block events.</p>
<h2><a class="anchor" id="sec_drmgr_tls">
Thread-Local and Callback-Local Storage</a></h2>
<p><code>drmgr</code> also coordinates sharing of the thread-local-storage field among multiple components and provides automated support for callback-private fields on Windows. It replaces the single <a class="el" href="dr__tools_8h.html#a787aff5df1ded3de8a7ce9f3efef0594">dr_get_tls_field()</a> pointer with two separate arrays of pointers: one for callback-shared fields, and one for callback-private fields. When a field is requested, an integer index is returned to the caller for use in retrieving the appropriate pointer.</p>
<h3><a class="anchor" id="sec_drmgr_cls">
Callback-local Storage</a></h3>
<p>On Windows, events such as keypresses or mouse movements are delivered to applications as <em>callbacks</em>. These callbacks interrupt a thread's execution in order to handle the event. The interrupted context is saved and a new context entered. When the event handling is finished, the interrupted context is resumed. Callbacks can interrupt other callbacks, resulting in a stack of contexts.</p>
<p>When a tool maintains state across application execution, it must handle callback contexts. Thread-local storage (tls) is per-thread and is thus callback-shared. Callbacks interrupt thread execution to execute arbitrary amounts of code in a new context before returning to the interrupted context. Thread-local storage fields that persist across application execution can be overwritten during callback execution, resulting in incorrect values when returning to the original context. Callback-local storage, rather than thread-local storage, should be used for any fields that store information specific to the application's execution.</p>
<p>Callbacks are Windows-specific. The cls interfaces are not marked for Windows-only, however, to facilitate cross-platform code. We recommend that cross-plaform code be written using cls fields on both platforms; the fields on Linux will never be stacked and will function as tls fields. Technically the same context interruption can occur with a Linux signal, but Linux signals typically execute small amounts of code and avoid making stateful changes; furthermore, there is no guaranteed end point to a signal. The <a class="el" href="group__drmgr.html#gae2a70abba090ee410babc6a1548bb21d">drmgr_push_cls()</a> and <a class="el" href="group__drmgr.html#ga4ac55faa0a4274ab5d8ac1cbd247b569">drmgr_pop_cls()</a> interface can be used to provide a stack of contexts on Linux, or to provide a stack of contexts for any other purpose such as layered wrapped functions. These push and pop functions are automatically called on Windows callback entry and exit.</p>
<h2><a class="anchor" id="sec_drmgr_notes">
Instruction Note Fields</a></h2>
<p>Instrumentation passes often need to mark instructions with information for later passes. One method of doing this is to use the <code>note</code> field built in to the <code><a class="el" href="structinstr__t.html">instr_t</a></code> type. For example, labels can be inserted with <code>note</code> field corresponding to pre-defined constants to indicate insertion points. In order to avoid these <code>note</code> constants from overlapping and conflicting among different passes, <code>drmgr</code> provides mediation of the </p>
<dl class="note"><dt><b>Note:</b></dt><dd>namespace.</dd></dl>
<p><code>drmgr</code> does not make use of its <code>note</code> mediation mandatory and does not override <a class="el" href="dr__ir__instr_8h.html#aba91124bada4c62004f5837c0d52af83">instr_set_note()</a> or <a class="el" href="dr__ir__instr_8h.html#ad5e7b4a1ecf29b3a311b684e8efc322a">instr_get_note()</a>. Instrumentation passes should feel free to use pointer values in the <code>note</code> field. The <code>note</code> constant value mediation is intended for small constants that will note be confused with pointer values. </p>
</div>
<hr size="1"><address style="text-align: center;"><small>
<img border=0 src="favicon.png"> &nbsp; DynamoRIO API version 3.2.0 --- Wed Mar 28 12:55:33 2012 
&nbsp; <img border=0 src="favicon.png">
</body>
</html>
