<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>DynamoRIO API: dr_ir_utils.h File Reference</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
<link rel="shortcut icon" type="image/x-icon" href="favicon.ico" />
</head><body>
<!-- Generated by Doxygen 1.6.3 -->
<div class="contents">
<h1>dr_ir_utils.h File Reference</h1>
<p>Code transformation utilities.  
<a href="#_details">More...</a></p>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td colspan="2"><h2>Enumerations</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__utils_8h.html#a89a6b714ff24d91d78589877047a29b9">dr_spill_slot_t</a> { , <br/>
&nbsp;&nbsp;<a class="el" href="dr__ir__utils_8h.html#a89a6b714ff24d91d78589877047a29b9ae4cd78beccb2525acc61f2536ba1ea71">SPILL_SLOT_2</a> =  1, 
<br/>
&nbsp;&nbsp;<a class="el" href="dr__ir__utils_8h.html#a89a6b714ff24d91d78589877047a29b9a446ae7a7df24d2c3abae567a17289566">SPILL_SLOT_3</a> =  2, 
<br/>
&nbsp;&nbsp;<a class="el" href="dr__ir__utils_8h.html#a89a6b714ff24d91d78589877047a29b9ab1b97fb0822126941b211160965034e4">SPILL_SLOT_4</a> =  3, 
<br/>
&nbsp;&nbsp;<a class="el" href="dr__ir__utils_8h.html#a89a6b714ff24d91d78589877047a29b9a57734b157aa48d5db278cb1aa372cd56">SPILL_SLOT_5</a> =  4, 
<br/>
&nbsp;&nbsp;<a class="el" href="dr__ir__utils_8h.html#a89a6b714ff24d91d78589877047a29b9ac4c22f3fdbacb7b37b55484b5577f1e0">SPILL_SLOT_6</a> =  5, 
<br/>
&nbsp;&nbsp;<a class="el" href="dr__ir__utils_8h.html#a89a6b714ff24d91d78589877047a29b9abbff886ccbde7dc9ce9bd4e379eb7ac3">SPILL_SLOT_7</a> =  6, 
<br/>
&nbsp;&nbsp;<a class="el" href="dr__ir__utils_8h.html#a89a6b714ff24d91d78589877047a29b9a6bbd68ecb5a36a22f247c5806fa5fec9">SPILL_SLOT_8</a> =  7, 
<br/>
&nbsp;&nbsp;<a class="el" href="dr__ir__utils_8h.html#a89a6b714ff24d91d78589877047a29b9aa1bffc7b66f58d71b52284c0f49d5a53">SPILL_SLOT_9</a> =  8, 
<br/>
&nbsp;&nbsp;<a class="el" href="dr__ir__utils_8h.html#a89a6b714ff24d91d78589877047a29b9a44005b876b8364b0433f880f5b9b1a68">SPILL_SLOT_10</a> =  9, 
<br/>
&nbsp;&nbsp;<a class="el" href="dr__ir__utils_8h.html#a89a6b714ff24d91d78589877047a29b9a78ba623c508dc9db382bd16205e862c5">SPILL_SLOT_11</a> =  10, 
<br/>
&nbsp;&nbsp;<a class="el" href="dr__ir__utils_8h.html#a89a6b714ff24d91d78589877047a29b9a3bd3a0c1a09dd08a8cf3cdc99902767a">SPILL_SLOT_12</a> =  11, 
<br/>
&nbsp;&nbsp;<a class="el" href="dr__ir__utils_8h.html#a89a6b714ff24d91d78589877047a29b9a2a009fac1a98d5546313cb17b0a026a7">SPILL_SLOT_13</a> =  12, 
<br/>
&nbsp;&nbsp;<a class="el" href="dr__ir__utils_8h.html#a89a6b714ff24d91d78589877047a29b9ace6bda60e6d81dc4914384f28d2e159e">SPILL_SLOT_14</a> =  13, 
<br/>
&nbsp;&nbsp;<a class="el" href="dr__ir__utils_8h.html#a89a6b714ff24d91d78589877047a29b9a529c3a41f0f3324929310b94915de96e">SPILL_SLOT_15</a> =  14, 
<br/>
&nbsp;&nbsp;<a class="el" href="dr__ir__utils_8h.html#a89a6b714ff24d91d78589877047a29b9a3d4436b445175a7088cd958a7e81f9b8">SPILL_SLOT_16</a> =  15, 
<br/>
&nbsp;&nbsp;<a class="el" href="dr__ir__utils_8h.html#a89a6b714ff24d91d78589877047a29b9a8483a4f53a6c380d0356a0596745ce09">SPILL_SLOT_17</a> =  16, 
<br/>
&nbsp;&nbsp;<a class="el" href="dr__ir__utils_8h.html#a89a6b714ff24d91d78589877047a29b9a794503b196c55da22002fc15549916fa">SPILL_SLOT_MAX</a> =  SPILL_SLOT_17
<br/>
 }</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__utils_8h.html#af1b1bc23c42ffb7452568176b09b1212">dr_cleancall_save_t</a> { <br/>
&nbsp;&nbsp;<a class="el" href="dr__ir__utils_8h.html#af1b1bc23c42ffb7452568176b09b1212ac04fbaff072a9ec162172cdd8305080d">DR_CLEANCALL_SAVE_FLOAT</a> =  0x0001, 
<br/>
&nbsp;&nbsp;<a class="el" href="dr__ir__utils_8h.html#af1b1bc23c42ffb7452568176b09b1212a2b03fe8506703bdcc4c24c49f6f16915">DR_CLEANCALL_NOSAVE_FLAGS</a> =  0x0002, 
<br/>
&nbsp;&nbsp;<a class="el" href="dr__ir__utils_8h.html#af1b1bc23c42ffb7452568176b09b1212abde57f92afb00d994bc1ea596ba31306">DR_CLEANCALL_NOSAVE_XMM</a> =  0x0004, 
<br/>
&nbsp;&nbsp;<a class="el" href="dr__ir__utils_8h.html#af1b1bc23c42ffb7452568176b09b1212a04d3bcbf34926384e13d48d45aa42d2a">DR_CLEANCALL_NOSAVE_XMM_NONPARAM</a> =  0x0008, 
<br/>
&nbsp;&nbsp;<a class="el" href="dr__ir__utils_8h.html#af1b1bc23c42ffb7452568176b09b1212a658cc567c0e4c91c0a065a17cb7ba5ed">DR_CLEANCALL_NOSAVE_XMM_NONRET</a> =  0x0010
<br/>
 }</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__utils_8h.html#a4c1e2fa2049719870ad0c1007b00d4e3">dr_disasm_flags_t</a> { <br/>
&nbsp;&nbsp;<a class="el" href="dr__ir__utils_8h.html#a4c1e2fa2049719870ad0c1007b00d4e3a83d3ece1134b8dabc7f0fd2f84185f11">DR_DISASM_ATT</a> =  0, 
<br/>
&nbsp;&nbsp;<a class="el" href="dr__ir__utils_8h.html#a4c1e2fa2049719870ad0c1007b00d4e3a406704bf086c0d17c5bfade619533835">DR_DISASM_INTEL</a> =  1
<br/>
 }</td></tr>
<tr><td colspan="2"><h2>Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__utils_8h.html#adf9a4f63eafc7f9725f7d5bf1725ab5c">set_x86_mode</a> (void *drcontext, bool x86)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__utils_8h.html#aa18c8ca0720c97403a0fa9371ae792e5">get_x86_mode</a> (void *drcontext)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__utils_8h.html#af294ac021c84f5ec47230ee7df0e6c02">dr_save_reg</a> (void *drcontext, instrlist_t *ilist, <a class="el" href="structinstr__t.html">instr_t</a> *where, reg_id_t reg, <a class="el" href="dr__ir__utils_8h.html#a89a6b714ff24d91d78589877047a29b9">dr_spill_slot_t</a> slot)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__utils_8h.html#a453bc3ecddb4298ffdc1c429f30881b8">dr_restore_reg</a> (void *drcontext, instrlist_t *ilist, <a class="el" href="structinstr__t.html">instr_t</a> *where, reg_id_t reg, <a class="el" href="dr__ir__utils_8h.html#a89a6b714ff24d91d78589877047a29b9">dr_spill_slot_t</a> slot)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="dr__ir__utils_8h.html#a89a6b714ff24d91d78589877047a29b9">dr_spill_slot_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__utils_8h.html#a762389f8ae9d809fd7b8f1418cdbd5ae">dr_max_opnd_accessible_spill_slot</a> (void)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structopnd__t.html">opnd_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__utils_8h.html#a5eab608c134db044f2d9453a8407d470">dr_reg_spill_slot_opnd</a> (void *drcontext, <a class="el" href="dr__ir__utils_8h.html#a89a6b714ff24d91d78589877047a29b9">dr_spill_slot_t</a> slot)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">reg_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__utils_8h.html#abb63ecfaa5256688bab9a2921fc19227">dr_read_saved_reg</a> (void *drcontext, <a class="el" href="dr__ir__utils_8h.html#a89a6b714ff24d91d78589877047a29b9">dr_spill_slot_t</a> slot)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__utils_8h.html#abf8d50d718883a1caf6a2de0fb3dbce3">dr_write_saved_reg</a> (void *drcontext, <a class="el" href="dr__ir__utils_8h.html#a89a6b714ff24d91d78589877047a29b9">dr_spill_slot_t</a> slot, reg_t value)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__utils_8h.html#a44636ca6809a9fb22cf817701de9ee09">dr_save_arith_flags</a> (void *drcontext, instrlist_t *ilist, <a class="el" href="structinstr__t.html">instr_t</a> *where, <a class="el" href="dr__ir__utils_8h.html#a89a6b714ff24d91d78589877047a29b9">dr_spill_slot_t</a> slot)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__utils_8h.html#a563b0de37a51cb2e84337deef30a57cf">dr_restore_arith_flags</a> (void *drcontext, instrlist_t *ilist, <a class="el" href="structinstr__t.html">instr_t</a> *where, <a class="el" href="dr__ir__utils_8h.html#a89a6b714ff24d91d78589877047a29b9">dr_spill_slot_t</a> slot)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__utils_8h.html#a3831354cc7402d68719d8055fb3e9931">dr_insert_read_tls_field</a> (void *drcontext, instrlist_t *ilist, <a class="el" href="structinstr__t.html">instr_t</a> *where, reg_id_t reg)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__utils_8h.html#a982089284bd51339f448ec4b3928d3b4">dr_insert_write_tls_field</a> (void *drcontext, instrlist_t *ilist, <a class="el" href="structinstr__t.html">instr_t</a> *where, reg_id_t reg)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__utils_8h.html#a3b0b7e9e09a9a85ca1a707da3ded6f69">instrlist_meta_preinsert</a> (instrlist_t *ilist, <a class="el" href="structinstr__t.html">instr_t</a> *where, <a class="el" href="structinstr__t.html">instr_t</a> *instr)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__utils_8h.html#a98218650e1f61b58c5478cf68e25d9da">instrlist_meta_postinsert</a> (instrlist_t *ilist, <a class="el" href="structinstr__t.html">instr_t</a> *where, <a class="el" href="structinstr__t.html">instr_t</a> *instr)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__utils_8h.html#a824eaa9075a7aaf443b4cc4180eec81e">instrlist_meta_append</a> (instrlist_t *ilist, <a class="el" href="structinstr__t.html">instr_t</a> *instr)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__utils_8h.html#affe811040a2962e5c6920a3c523212ab">instrlist_meta_fault_preinsert</a> (instrlist_t *ilist, <a class="el" href="structinstr__t.html">instr_t</a> *where, <a class="el" href="structinstr__t.html">instr_t</a> *instr)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__utils_8h.html#a6ea095671bab4239c659d17d4a9cda56">instrlist_meta_fault_postinsert</a> (instrlist_t *ilist, <a class="el" href="structinstr__t.html">instr_t</a> *where, <a class="el" href="structinstr__t.html">instr_t</a> *instr)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__utils_8h.html#a94a1526c7b520c9aefbd775adfc57108">instrlist_meta_fault_append</a> (instrlist_t *ilist, <a class="el" href="structinstr__t.html">instr_t</a> *instr)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__utils_8h.html#ae7b7bd1e750b8a24ebf401fb6a6d6d5e">dr_insert_clean_call</a> (void *drcontext, instrlist_t *ilist, <a class="el" href="structinstr__t.html">instr_t</a> *where, void *callee, bool save_fpstate, uint num_args,...)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__utils_8h.html#af2a3575059c29dae25ab02c9eb1d0ce9">dr_insert_call</a> (void *drcontext, instrlist_t *ilist, <a class="el" href="structinstr__t.html">instr_t</a> *where, void *callee, uint num_args,...)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">uint&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__utils_8h.html#a4608ec2db2a288aa5e2a53bb6d19054d">dr_prepare_for_call</a> (void *drcontext, instrlist_t *ilist, <a class="el" href="structinstr__t.html">instr_t</a> *instr)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__utils_8h.html#a466c814771a85f9b53e6681f4dc5c957">dr_cleanup_after_call</a> (void *drcontext, instrlist_t *ilist, <a class="el" href="structinstr__t.html">instr_t</a> *where, uint sizeof_param_area)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__utils_8h.html#a9647e1300201596bc818ca33c95d4cc6">dr_swap_to_clean_stack</a> (void *drcontext, instrlist_t *ilist, <a class="el" href="structinstr__t.html">instr_t</a> *where)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__utils_8h.html#a9a2c851eeeee7e669f3e6a7b877977d1">dr_restore_app_stack</a> (void *drcontext, instrlist_t *ilist, <a class="el" href="structinstr__t.html">instr_t</a> *where)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__utils_8h.html#a359744bc2776333fbf8f057931ca8eeb">dr_insert_call_instrumentation</a> (void *drcontext, instrlist_t *ilist, <a class="el" href="structinstr__t.html">instr_t</a> *instr, void *callee)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__utils_8h.html#a919e2106df67eaaa5bc6c49d736543b5">dr_insert_mbr_instrumentation</a> (void *drcontext, instrlist_t *ilist, <a class="el" href="structinstr__t.html">instr_t</a> *instr, void *callee, <a class="el" href="dr__ir__utils_8h.html#a89a6b714ff24d91d78589877047a29b9">dr_spill_slot_t</a> scratch_slot)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__utils_8h.html#abe09a1a1ca19b343279a65141c20f0a1">dr_insert_cbr_instrumentation</a> (void *drcontext, instrlist_t *ilist, <a class="el" href="structinstr__t.html">instr_t</a> *instr, void *callee)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__utils_8h.html#a3647b439211a8cd70c40478a4113e128">dr_insert_ubr_instrumentation</a> (void *drcontext, instrlist_t *ilist, <a class="el" href="structinstr__t.html">instr_t</a> *instr, void *callee)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__utils_8h.html#a5921c4f301ea05885f305f9a30b3c0b0">dr_mcontext_xmm_fields_valid</a> (void)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__utils_8h.html#a91ffde2808c16e07f323c34affa72209">dr_get_mcontext</a> (void *drcontext, <a class="el" href="struct__dr__mcontext__t.html">dr_mcontext_t</a> *context)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__utils_8h.html#a56568d24667f5d64264d0bad398727b3">dr_set_mcontext</a> (void *drcontext, <a class="el" href="struct__dr__mcontext__t.html">dr_mcontext_t</a> *context)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__utils_8h.html#a9f612cf9d0ca2025b23d30b6f5bb0231">dr_redirect_execution</a> (<a class="el" href="struct__dr__mcontext__t.html">dr_mcontext_t</a> *context)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">app_pc&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__utils_8h.html#ae30dfcf7ed64d1923b9f4e101cc983cb">decode_memory_reference_size</a> (void *drcontext, app_pc pc, uint *size_in_bytes)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">byte *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__utils_8h.html#aa9055369e97457b8656fc8c3c0d6d49d">decode_eflags_usage</a> (void *drcontext, byte *pc, uint *usage)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">byte *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__utils_8h.html#a6f62065c2b7e764fe9fb0f46557e2264">decode</a> (void *drcontext, byte *pc, <a class="el" href="structinstr__t.html">instr_t</a> *instr)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">byte *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__utils_8h.html#aad81737da9662a4e6bf697757cb25ddf">decode_from_copy</a> (void *drcontext, byte *copy_pc, byte *orig_pc, <a class="el" href="structinstr__t.html">instr_t</a> *instr)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">instrlist_t *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__utils_8h.html#a1321b3d18f45de750edfe2ff6ba151d2">decode_as_bb</a> (void *drcontext, byte *start_pc)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">instrlist_t *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__utils_8h.html#adbe7afa4c8654b0ee88ccd88d1f2d698">decode_trace</a> (void *drcontext, void *tag)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">byte&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__utils_8h.html#a4946f4ab326ef4695fce55eb434c2cde">decode_first_opcode_byte</a> (int opcode)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const char *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__utils_8h.html#a3952e7614f4bf8e62f360f08683ad8a0">decode_opcode_name</a> (int opcode)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__utils_8h.html#a2a8b8756bdc063a88d206f17cc5e3e2c">decode_sizeof</a> (void *drcontext, byte *pc, int *num_prefixes _IF_X64(uint *rip_rel_pos))</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">byte *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__utils_8h.html#a813105fc7196a85e73580d1adfb8d336">decode_next_pc</a> (void *drcontext, byte *pc)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__utils_8h.html#a3082c5db55039c72ae30e3276f622aae">disassemble_set_syntax</a> (<a class="el" href="dr__ir__utils_8h.html#a4c1e2fa2049719870ad0c1007b00d4e3">dr_disasm_flags_t</a> flags)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">byte *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__utils_8h.html#a526fc9f23e78b5f1321891dc8f81b1b7">disassemble</a> (void *drcontext, byte *pc, file_t outfile)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">byte *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__utils_8h.html#a2c491ac5c40069f120b0ef512ccc7166">disassemble_with_info</a> (void *drcontext, byte *pc, file_t outfile, bool show_pc, bool show_bytes)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">byte *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__utils_8h.html#a2e6a5d44647c481f50ee5208281617ba">disassemble_from_copy</a> (void *drcontext, byte *copy_pc, byte *orig_pc, file_t outfile, bool show_pc, bool show_bytes)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">byte *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__utils_8h.html#a3978e8cb7ba406cf7c9fed00b9c4a9bf">disassemble_to_buffer</a> (void *drcontext, byte *pc, byte *orig_pc, bool show_pc, bool show_bytes, char *buf, size_t bufsz, int *printed OUT)</td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<p>Code transformation utilities. </p>
<hr/><h2>Enumeration Type Documentation</h2>
<a class="anchor" id="af1b1bc23c42ffb7452568176b09b1212"></a><!-- doxytag: member="dr_ir_utils.h::dr_cleancall_save_t" ref="af1b1bc23c42ffb7452568176b09b1212" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="dr__ir__utils_8h.html#af1b1bc23c42ffb7452568176b09b1212">dr_cleancall_save_t</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Flags to request non-default preservation of state in a clean call </p>
<dl><dt><b>Enumerator: </b></dt><dd><table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" id="af1b1bc23c42ffb7452568176b09b1212ac04fbaff072a9ec162172cdd8305080d"></a><!-- doxytag: member="DR_CLEANCALL_SAVE_FLOAT" ref="af1b1bc23c42ffb7452568176b09b1212ac04fbaff072a9ec162172cdd8305080d" args="" -->DR_CLEANCALL_SAVE_FLOAT</em>&nbsp;</td><td>
<p>Save floating-point state. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="af1b1bc23c42ffb7452568176b09b1212a2b03fe8506703bdcc4c24c49f6f16915"></a><!-- doxytag: member="DR_CLEANCALL_NOSAVE_FLAGS" ref="af1b1bc23c42ffb7452568176b09b1212a2b03fe8506703bdcc4c24c49f6f16915" args="" -->DR_CLEANCALL_NOSAVE_FLAGS</em>&nbsp;</td><td>
<p>Skip saving the flags and skip clearing the flags (including DF) for client execution. Note that this can cause problems if <a class="el" href="dr__ir__utils_8h.html#a9f612cf9d0ca2025b23d30b6f5bb0231">dr_redirect_execution()</a> is called from a clean call, as an uninitialized flags value can cause subtle errors. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="af1b1bc23c42ffb7452568176b09b1212abde57f92afb00d994bc1ea596ba31306"></a><!-- doxytag: member="DR_CLEANCALL_NOSAVE_XMM" ref="af1b1bc23c42ffb7452568176b09b1212abde57f92afb00d994bc1ea596ba31306" args="" -->DR_CLEANCALL_NOSAVE_XMM</em>&nbsp;</td><td>
<p>Skip saving any XMM or YMM registers. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="af1b1bc23c42ffb7452568176b09b1212a04d3bcbf34926384e13d48d45aa42d2a"></a><!-- doxytag: member="DR_CLEANCALL_NOSAVE_XMM_NONPARAM" ref="af1b1bc23c42ffb7452568176b09b1212a04d3bcbf34926384e13d48d45aa42d2a" args="" -->DR_CLEANCALL_NOSAVE_XMM_NONPARAM</em>&nbsp;</td><td>
<p>Skip saving any XMM or YMM registers that are never used as parameters. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="af1b1bc23c42ffb7452568176b09b1212a658cc567c0e4c91c0a065a17cb7ba5ed"></a><!-- doxytag: member="DR_CLEANCALL_NOSAVE_XMM_NONRET" ref="af1b1bc23c42ffb7452568176b09b1212a658cc567c0e4c91c0a065a17cb7ba5ed" args="" -->DR_CLEANCALL_NOSAVE_XMM_NONRET</em>&nbsp;</td><td>
<p>Skip saving any XMM or YMM registers that are never used as return values. </p>
</td></tr>
</table>
</dd>
</dl>

</div>
</div>
<a class="anchor" id="a4c1e2fa2049719870ad0c1007b00d4e3"></a><!-- doxytag: member="dr_ir_utils.h::dr_disasm_flags_t" ref="a4c1e2fa2049719870ad0c1007b00d4e3" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="dr__ir__utils_8h.html#a4c1e2fa2049719870ad0c1007b00d4e3">dr_disasm_flags_t</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Flags controlling disassembly style </p>
<dl><dt><b>Enumerator: </b></dt><dd><table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" id="a4c1e2fa2049719870ad0c1007b00d4e3a83d3ece1134b8dabc7f0fd2f84185f11"></a><!-- doxytag: member="DR_DISASM_ATT" ref="a4c1e2fa2049719870ad0c1007b00d4e3a83d3ece1134b8dabc7f0fd2f84185f11" args="" -->DR_DISASM_ATT</em>&nbsp;</td><td>
<p>AT&amp;T syntax </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a4c1e2fa2049719870ad0c1007b00d4e3a406704bf086c0d17c5bfade619533835"></a><!-- doxytag: member="DR_DISASM_INTEL" ref="a4c1e2fa2049719870ad0c1007b00d4e3a406704bf086c0d17c5bfade619533835" args="" -->DR_DISASM_INTEL</em>&nbsp;</td><td>
<p>Intel syntax </p>
</td></tr>
</table>
</dd>
</dl>

</div>
</div>
<a class="anchor" id="a89a6b714ff24d91d78589877047a29b9"></a><!-- doxytag: member="dr_ir_utils.h::dr_spill_slot_t" ref="a89a6b714ff24d91d78589877047a29b9" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="dr__ir__utils_8h.html#a89a6b714ff24d91d78589877047a29b9">dr_spill_slot_t</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>An enum of spill slots to use with <a class="el" href="dr__ir__utils_8h.html#af294ac021c84f5ec47230ee7df0e6c02">dr_save_reg()</a>, <a class="el" href="dr__ir__utils_8h.html#a453bc3ecddb4298ffdc1c429f30881b8">dr_restore_reg()</a>, <a class="el" href="dr__ir__utils_8h.html#a44636ca6809a9fb22cf817701de9ee09">dr_save_arith_flags()</a>, <a class="el" href="dr__ir__utils_8h.html#a563b0de37a51cb2e84337deef30a57cf">dr_restore_arith_flags()</a> and <a class="el" href="dr__ir__utils_8h.html#a919e2106df67eaaa5bc6c49d736543b5">dr_insert_mbr_instrumentation()</a>. Values stored in spill slots remain valid only until the next non-meta (i.e. application) instruction. Spill slots can be accessed/modifed during clean calls and restore_state_events (see <a class="el" href="dr__events_8h.html#ae7a179ac7a2d01157e1ab2852f50c902">dr_register_restore_state_event()</a>) with <a class="el" href="dr__ir__utils_8h.html#abb63ecfaa5256688bab9a2921fc19227">dr_read_saved_reg()</a> and <a class="el" href="dr__ir__utils_8h.html#abf8d50d718883a1caf6a2de0fb3dbce3">dr_write_saved_reg()</a>.</p>
<p>Spill slots &lt;= <a class="el" href="dr__ir__utils_8h.html#a762389f8ae9d809fd7b8f1418cdbd5ae">dr_max_opnd_accessible_spill_slot()</a> can be directly accessed from client inserted instructions with <a class="el" href="dr__ir__utils_8h.html#a5eab608c134db044f2d9453a8407d470">dr_reg_spill_slot_opnd()</a>.</p>
<dl class="note"><dt><b>Note:</b></dt><dd>Some spill slots may be faster to access than others. Currently spill slots 1-3 are significantly faster to access than the others when running without -thread_private. When running with -thread_private all spill slots are expected to have similar performance. This is subject to change in future releases, but clients may assume that smaller numbered spill slots are faster or the same cost to access as larger numbered spill slots.</dd>
<dd>
The number of spill slots may change in future releases. </dd></dl>
<dl><dt><b>Enumerator: </b></dt><dd><table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" id="a89a6b714ff24d91d78589877047a29b9ae4cd78beccb2525acc61f2536ba1ea71"></a><!-- doxytag: member="SPILL_SLOT_2" ref="a89a6b714ff24d91d78589877047a29b9ae4cd78beccb2525acc61f2536ba1ea71" args="" -->SPILL_SLOT_2</em>&nbsp;</td><td>
<p>spill slot for register save/restore routines </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a89a6b714ff24d91d78589877047a29b9a446ae7a7df24d2c3abae567a17289566"></a><!-- doxytag: member="SPILL_SLOT_3" ref="a89a6b714ff24d91d78589877047a29b9a446ae7a7df24d2c3abae567a17289566" args="" -->SPILL_SLOT_3</em>&nbsp;</td><td>
<p>spill slot for register save/restore routines </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a89a6b714ff24d91d78589877047a29b9ab1b97fb0822126941b211160965034e4"></a><!-- doxytag: member="SPILL_SLOT_4" ref="a89a6b714ff24d91d78589877047a29b9ab1b97fb0822126941b211160965034e4" args="" -->SPILL_SLOT_4</em>&nbsp;</td><td>
<p>spill slot for register save/restore routines </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a89a6b714ff24d91d78589877047a29b9a57734b157aa48d5db278cb1aa372cd56"></a><!-- doxytag: member="SPILL_SLOT_5" ref="a89a6b714ff24d91d78589877047a29b9a57734b157aa48d5db278cb1aa372cd56" args="" -->SPILL_SLOT_5</em>&nbsp;</td><td>
<p>spill slot for register save/restore routines </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a89a6b714ff24d91d78589877047a29b9ac4c22f3fdbacb7b37b55484b5577f1e0"></a><!-- doxytag: member="SPILL_SLOT_6" ref="a89a6b714ff24d91d78589877047a29b9ac4c22f3fdbacb7b37b55484b5577f1e0" args="" -->SPILL_SLOT_6</em>&nbsp;</td><td>
<p>spill slot for register save/restore routines </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a89a6b714ff24d91d78589877047a29b9abbff886ccbde7dc9ce9bd4e379eb7ac3"></a><!-- doxytag: member="SPILL_SLOT_7" ref="a89a6b714ff24d91d78589877047a29b9abbff886ccbde7dc9ce9bd4e379eb7ac3" args="" -->SPILL_SLOT_7</em>&nbsp;</td><td>
<p>spill slot for register save/restore routines </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a89a6b714ff24d91d78589877047a29b9a6bbd68ecb5a36a22f247c5806fa5fec9"></a><!-- doxytag: member="SPILL_SLOT_8" ref="a89a6b714ff24d91d78589877047a29b9a6bbd68ecb5a36a22f247c5806fa5fec9" args="" -->SPILL_SLOT_8</em>&nbsp;</td><td>
<p>spill slot for register save/restore routines </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a89a6b714ff24d91d78589877047a29b9aa1bffc7b66f58d71b52284c0f49d5a53"></a><!-- doxytag: member="SPILL_SLOT_9" ref="a89a6b714ff24d91d78589877047a29b9aa1bffc7b66f58d71b52284c0f49d5a53" args="" -->SPILL_SLOT_9</em>&nbsp;</td><td>
<p>spill slot for register save/restore routines </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a89a6b714ff24d91d78589877047a29b9a44005b876b8364b0433f880f5b9b1a68"></a><!-- doxytag: member="SPILL_SLOT_10" ref="a89a6b714ff24d91d78589877047a29b9a44005b876b8364b0433f880f5b9b1a68" args="" -->SPILL_SLOT_10</em>&nbsp;</td><td>
<p>spill slot for register save/restore routines </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a89a6b714ff24d91d78589877047a29b9a78ba623c508dc9db382bd16205e862c5"></a><!-- doxytag: member="SPILL_SLOT_11" ref="a89a6b714ff24d91d78589877047a29b9a78ba623c508dc9db382bd16205e862c5" args="" -->SPILL_SLOT_11</em>&nbsp;</td><td>
<p>spill slot for register save/restore routines </p>
<dl class="note"><dt><b>Note:</b></dt><dd>x64 only </dd></dl>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a89a6b714ff24d91d78589877047a29b9a3bd3a0c1a09dd08a8cf3cdc99902767a"></a><!-- doxytag: member="SPILL_SLOT_12" ref="a89a6b714ff24d91d78589877047a29b9a3bd3a0c1a09dd08a8cf3cdc99902767a" args="" -->SPILL_SLOT_12</em>&nbsp;</td><td>
<p>spill slot for register save/restore routines </p>
<dl class="note"><dt><b>Note:</b></dt><dd>x64 only </dd></dl>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a89a6b714ff24d91d78589877047a29b9a2a009fac1a98d5546313cb17b0a026a7"></a><!-- doxytag: member="SPILL_SLOT_13" ref="a89a6b714ff24d91d78589877047a29b9a2a009fac1a98d5546313cb17b0a026a7" args="" -->SPILL_SLOT_13</em>&nbsp;</td><td>
<p>spill slot for register save/restore routines </p>
<dl class="note"><dt><b>Note:</b></dt><dd>x64 only </dd></dl>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a89a6b714ff24d91d78589877047a29b9ace6bda60e6d81dc4914384f28d2e159e"></a><!-- doxytag: member="SPILL_SLOT_14" ref="a89a6b714ff24d91d78589877047a29b9ace6bda60e6d81dc4914384f28d2e159e" args="" -->SPILL_SLOT_14</em>&nbsp;</td><td>
<p>spill slot for register save/restore routines </p>
<dl class="note"><dt><b>Note:</b></dt><dd>x64 only </dd></dl>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a89a6b714ff24d91d78589877047a29b9a529c3a41f0f3324929310b94915de96e"></a><!-- doxytag: member="SPILL_SLOT_15" ref="a89a6b714ff24d91d78589877047a29b9a529c3a41f0f3324929310b94915de96e" args="" -->SPILL_SLOT_15</em>&nbsp;</td><td>
<p>spill slot for register save/restore routines </p>
<dl class="note"><dt><b>Note:</b></dt><dd>x64 only </dd></dl>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a89a6b714ff24d91d78589877047a29b9a3d4436b445175a7088cd958a7e81f9b8"></a><!-- doxytag: member="SPILL_SLOT_16" ref="a89a6b714ff24d91d78589877047a29b9a3d4436b445175a7088cd958a7e81f9b8" args="" -->SPILL_SLOT_16</em>&nbsp;</td><td>
<p>spill slot for register save/restore routines </p>
<dl class="note"><dt><b>Note:</b></dt><dd>x64 only </dd></dl>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a89a6b714ff24d91d78589877047a29b9a8483a4f53a6c380d0356a0596745ce09"></a><!-- doxytag: member="SPILL_SLOT_17" ref="a89a6b714ff24d91d78589877047a29b9a8483a4f53a6c380d0356a0596745ce09" args="" -->SPILL_SLOT_17</em>&nbsp;</td><td>
<p>spill slot for register save/restore routines </p>
<dl class="note"><dt><b>Note:</b></dt><dd>x64 only </dd></dl>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a89a6b714ff24d91d78589877047a29b9a794503b196c55da22002fc15549916fa"></a><!-- doxytag: member="SPILL_SLOT_MAX" ref="a89a6b714ff24d91d78589877047a29b9a794503b196c55da22002fc15549916fa" args="" -->SPILL_SLOT_MAX</em>&nbsp;</td><td>
<p>spill slot for register save/restore routines </p>
<dl class="note"><dt><b>Note:</b></dt><dd>x64 only </dd></dl>
</td></tr>
</table>
</dd>
</dl>

</div>
</div>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="a6f62065c2b7e764fe9fb0f46557e2264"></a><!-- doxytag: member="dr_ir_utils.h::decode" ref="a6f62065c2b7e764fe9fb0f46557e2264" args="(void *drcontext, byte *pc, instr_t *instr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">byte* decode </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>drcontext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">byte *&nbsp;</td>
          <td class="paramname"> <em>pc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structinstr__t.html">instr_t</a> *&nbsp;</td>
          <td class="paramname"> <em>instr</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Decodes the instruction at address <code>pc</code> into <code>instr</code>, filling in the instruction's opcode, eflags usage, prefixes, and operands. The instruction's raw bits are set to valid and pointed at <code>pc</code> (xref <a class="el" href="dr__ir__instr_8h.html#a964928ee44090aba9aef343c5d34df5c">instr_get_raw_bits()</a>). Assumes that <code>instr</code> is already initialized, but uses the x86/x64 mode for the thread <code>dcontext</code> rather than that set in instr. If caller is re-using same <a class="el" href="structinstr__t.html">instr_t</a> struct over multiple decodings, caller should call <a class="el" href="dr__ir__instr_8h.html#accd2bdee07d2e6ca0be3b252bc7b913f">instr_reset()</a> or <a class="el" href="dr__ir__instr_8h.html#ab9b44a1db49dc5cd8da8b6b27fa47d50">instr_reuse()</a>. Returns the address of the next byte after the decoded instruction. Returns NULL on decoding an invalid instr and sets opcode to OP_INVALID. </p>

</div>
</div>
<a class="anchor" id="a1321b3d18f45de750edfe2ff6ba151d2"></a><!-- doxytag: member="dr_ir_utils.h::decode_as_bb" ref="a1321b3d18f45de750edfe2ff6ba151d2" args="(void *drcontext, byte *start_pc)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">instrlist_t* decode_as_bb </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>drcontext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">byte *&nbsp;</td>
          <td class="paramname"> <em>start_pc</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Client routine to decode instructions at an arbitrary app address, following all the rules that DynamoRIO follows internally for terminating basic blocks. Note that DynamoRIO does not validate that <code>start_pc</code> is actually the first instruction of a basic block. </p>
<dl class="note"><dt><b>Note:</b></dt><dd>Caller is reponsible for freeing the list and its instrs! </dd></dl>

</div>
</div>
<a class="anchor" id="aa9055369e97457b8656fc8c3c0d6d49d"></a><!-- doxytag: member="dr_ir_utils.h::decode_eflags_usage" ref="aa9055369e97457b8656fc8c3c0d6d49d" args="(void *drcontext, byte *pc, uint *usage)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">byte* decode_eflags_usage </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>drcontext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">byte *&nbsp;</td>
          <td class="paramname"> <em>pc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint *&nbsp;</td>
          <td class="paramname"> <em>usage</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Decodes only enough of the instruction at address <code>pc</code> to determine its eflags usage, which is returned in <code>usage</code> as EFLAGS_ constants or'ed together. Returns the address of the next byte after the decoded instruction. Returns NULL on decoding an invalid instruction. </p>

</div>
</div>
<a class="anchor" id="a4946f4ab326ef4695fce55eb434c2cde"></a><!-- doxytag: member="dr_ir_utils.h::decode_first_opcode_byte" ref="a4946f4ab326ef4695fce55eb434c2cde" args="(int opcode)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">byte decode_first_opcode_byte </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>opcode</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Given an OP_ constant, returns the first byte of its opcode when encoded as an IA-32 instruction. </p>

</div>
</div>
<a class="anchor" id="aad81737da9662a4e6bf697757cb25ddf"></a><!-- doxytag: member="dr_ir_utils.h::decode_from_copy" ref="aad81737da9662a4e6bf697757cb25ddf" args="(void *drcontext, byte *copy_pc, byte *orig_pc, instr_t *instr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">byte* decode_from_copy </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>drcontext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">byte *&nbsp;</td>
          <td class="paramname"> <em>copy_pc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">byte *&nbsp;</td>
          <td class="paramname"> <em>orig_pc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structinstr__t.html">instr_t</a> *&nbsp;</td>
          <td class="paramname"> <em>instr</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Decodes the instruction at address <code>copy_pc</code> into <code>instr</code> as though it were located at address <code>orig_pc</code>. Any pc-relative operands have their values calculated as though the instruction were actually at <code>orig_pc</code>, though that address is never de-referenced. The instruction's raw bits are not valid, but its translation field (see instr_get_translation()) is set to <code>orig_pc</code>. The instruction's opcode, eflags usage, prefixes, and operands are all filled in. Assumes that <code>instr</code> is already initialized, but uses the x86/x64 mode for the thread <code>dcontext</code> rather than that set in instr. If caller is re-using same <a class="el" href="structinstr__t.html">instr_t</a> struct over multiple decodings, caller should call <a class="el" href="dr__ir__instr_8h.html#accd2bdee07d2e6ca0be3b252bc7b913f">instr_reset()</a> or <a class="el" href="dr__ir__instr_8h.html#ab9b44a1db49dc5cd8da8b6b27fa47d50">instr_reuse()</a>. Returns the address of the next byte after the decoded instruction copy at <code>copy_pc</code>. Returns NULL on decoding an invalid instr and sets opcode to OP_INVALID. </p>

</div>
</div>
<a class="anchor" id="ae30dfcf7ed64d1923b9f4e101cc983cb"></a><!-- doxytag: member="dr_ir_utils.h::decode_memory_reference_size" ref="ae30dfcf7ed64d1923b9f4e101cc983cb" args="(void *drcontext, app_pc pc, uint *size_in_bytes)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">app_pc decode_memory_reference_size </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>drcontext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">app_pc&nbsp;</td>
          <td class="paramname"> <em>pc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint *&nbsp;</td>
          <td class="paramname"> <em>size_in_bytes</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Calculates the size, in bytes, of the memory read or write of the instr at <code>pc</code>. If the instruction is a repeating string instruction, considers only one iteration. Returns the pc of the following instruction. If the instruction at <code>pc</code> does not reference memory, or is invalid, returns NULL. </p>

</div>
</div>
<a class="anchor" id="a813105fc7196a85e73580d1adfb8d336"></a><!-- doxytag: member="dr_ir_utils.h::decode_next_pc" ref="a813105fc7196a85e73580d1adfb8d336" args="(void *drcontext, byte *pc)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">byte* decode_next_pc </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>drcontext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">byte *&nbsp;</td>
          <td class="paramname"> <em>pc</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Decodes only enough of the instruction at address <code>pc</code> to determine its size. Returns the address of the byte following the instruction. Returns NULL on decoding an invalid instruction. </p>

</div>
</div>
<a class="anchor" id="a3952e7614f4bf8e62f360f08683ad8a0"></a><!-- doxytag: member="dr_ir_utils.h::decode_opcode_name" ref="a3952e7614f4bf8e62f360f08683ad8a0" args="(int opcode)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* decode_opcode_name </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>opcode</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Given an OP_ constant, returns the string name of its opcode. </p>

</div>
</div>
<a class="anchor" id="a2a8b8756bdc063a88d206f17cc5e3e2c"></a><!-- doxytag: member="dr_ir_utils.h::decode_sizeof" ref="a2a8b8756bdc063a88d206f17cc5e3e2c" args="(void *drcontext, byte *pc, int *num_prefixes _IF_X64(uint *rip_rel_pos))" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int decode_sizeof </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>drcontext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">byte *&nbsp;</td>
          <td class="paramname"> <em>pc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *num_prefixes &nbsp;</td>
          <td class="paramname"> <em>_IF_X64</em>uint *rip_rel_pos</td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Decodes only enough of the instruction at address <code>pc</code> to determine its size. Returns that size. If <code>num_prefixes</code> is non-NULL, returns the number of prefix bytes. If <code>rip_rel_pos</code> is non-NULL, returns the offset into the instruction of a rip-relative addressing displacement (for data only: ignores control-transfer relative addressing), or 0 if none. May return 0 size for certain invalid instructions. </p>

</div>
</div>
<a class="anchor" id="adbe7afa4c8654b0ee88ccd88d1f2d698"></a><!-- doxytag: member="dr_ir_utils.h::decode_trace" ref="adbe7afa4c8654b0ee88ccd88d1f2d698" args="(void *drcontext, void *tag)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">instrlist_t* decode_trace </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>drcontext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>tag</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Decodes the trace with tag <code>tag</code>, and returns an instrlist_t of the instructions comprising that fragment. If <code>tag</code> is not a valid tag for an existing trace, the routine returns NULL. Clients can use <a class="el" href="dr__tools_8h.html#a1d4c9a29f1c962457c123322aa3e1931">dr_trace_exists_at()</a> to determine whether the trace exists. </p>
<dl class="note"><dt><b>Note:</b></dt><dd>Unlike the instruction list presented by the trace event, the list here does not include any existing client modifications. If client-modified instructions are needed, it is the responsibility of the client to record or recreate that list itself. </dd>
<dd>
This routine does not support decoding thread-private traces created by other than the calling thread. </dd></dl>

</div>
</div>
<a class="anchor" id="a526fc9f23e78b5f1321891dc8f81b1b7"></a><!-- doxytag: member="dr_ir_utils.h::disassemble" ref="a526fc9f23e78b5f1321891dc8f81b1b7" args="(void *drcontext, byte *pc, file_t outfile)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">byte* disassemble </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>drcontext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">byte *&nbsp;</td>
          <td class="paramname"> <em>pc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">file_t&nbsp;</td>
          <td class="paramname"> <em>outfile</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Decodes and then prints the instruction at address <code>pc</code> to file <code>outfile</code>. The default is to use AT&amp;T-style syntax, unless the <a class="el" href="using.html#op_syntax_intel">-syntax_intel</a> runtime option is specified. Returns the address of the subsequent instruction, or NULL if the instruction at <code>pc</code> is invalid. </p>

</div>
</div>
<a class="anchor" id="a2e6a5d44647c481f50ee5208281617ba"></a><!-- doxytag: member="dr_ir_utils.h::disassemble_from_copy" ref="a2e6a5d44647c481f50ee5208281617ba" args="(void *drcontext, byte *copy_pc, byte *orig_pc, file_t outfile, bool show_pc, bool show_bytes)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">byte* disassemble_from_copy </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>drcontext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">byte *&nbsp;</td>
          <td class="paramname"> <em>copy_pc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">byte *&nbsp;</td>
          <td class="paramname"> <em>orig_pc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">file_t&nbsp;</td>
          <td class="paramname"> <em>outfile</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>show_pc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>show_bytes</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Decodes the instruction at address <code>copy_pc</code> as though it were located at address <code>orig_pc</code>, and then prints the instruction to file <code>outfile</code>. Prior to the instruction the address <code>orig_pc</code> is printed if <code>show_pc</code> and the raw bytes are printed if <code>show_bytes</code>. The default is to use AT&amp;T-style syntax, unless the <a class="el" href="using.html#op_syntax_intel">-syntax_intel</a> runtime option is specified. Returns the address of the subsequent instruction after the copy at <code>copy_pc</code>, or NULL if the instruction at <code>copy_pc</code> is invalid. </p>

</div>
</div>
<a class="anchor" id="a3082c5db55039c72ae30e3276f622aae"></a><!-- doxytag: member="dr_ir_utils.h::disassemble_set_syntax" ref="a3082c5db55039c72ae30e3276f622aae" args="(dr_disasm_flags_t flags)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void disassemble_set_syntax </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="dr__ir__utils_8h.html#a4c1e2fa2049719870ad0c1007b00d4e3">dr_disasm_flags_t</a>&nbsp;</td>
          <td class="paramname"> <em>flags</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Sets the disassembly style. Setting DR_DISASM_INTEL sets the same option that is controlled by the runtime option <code>-syntax_intel</code>. </p>

</div>
</div>
<a class="anchor" id="a3978e8cb7ba406cf7c9fed00b9c4a9bf"></a><!-- doxytag: member="dr_ir_utils.h::disassemble_to_buffer" ref="a3978e8cb7ba406cf7c9fed00b9c4a9bf" args="(void *drcontext, byte *pc, byte *orig_pc, bool show_pc, bool show_bytes, char *buf, size_t bufsz, int *printed OUT)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">byte* disassemble_to_buffer </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>drcontext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">byte *&nbsp;</td>
          <td class="paramname"> <em>pc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">byte *&nbsp;</td>
          <td class="paramname"> <em>orig_pc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>show_pc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>show_bytes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&nbsp;</td>
          <td class="paramname"> <em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>bufsz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *printed&nbsp;</td>
          <td class="paramname"> <em>OUT</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Decodes the instruction at address <code>pc</code> as though it were located at address <code>orig_pc</code>, and then prints the instruction to the buffer <code>buf</code>. Always null-terminates, and will not print more than <code>bufsz</code> characters, which includes the final null character. Indicates the number of characters printed, not including the final null, in <code>printed</code>, if <code>printed</code> is non-NULL.</p>
<p>Prior to the instruction the address <code>orig_pc</code> is printed if <code>show_pc</code> and the raw bytes are printed if <code>show_bytes</code>. The default is to use AT&amp;T-style syntax, unless the <a class="el" href="using.html#op_syntax_intel">-syntax_intel</a> runtime option is specified. Returns the address of the subsequent instruction after the copy at <code>copy_pc</code>, or NULL if the instruction at <code>copy_pc</code> is invalid. </p>

</div>
</div>
<a class="anchor" id="a2c491ac5c40069f120b0ef512ccc7166"></a><!-- doxytag: member="dr_ir_utils.h::disassemble_with_info" ref="a2c491ac5c40069f120b0ef512ccc7166" args="(void *drcontext, byte *pc, file_t outfile, bool show_pc, bool show_bytes)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">byte* disassemble_with_info </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>drcontext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">byte *&nbsp;</td>
          <td class="paramname"> <em>pc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">file_t&nbsp;</td>
          <td class="paramname"> <em>outfile</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>show_pc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>show_bytes</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Decodes and then prints the instruction at address <code>pc</code> to file <code>outfile</code>. Prior to the instruction the address is printed if <code>show_pc</code> and the raw bytes are printed if <code>show_bytes</code>. The default is to use AT&amp;T-style syntax, unless the <a class="el" href="using.html#op_syntax_intel">-syntax_intel</a> runtime option is specified. Returns the address of the subsequent instruction, or NULL if the instruction at <code>pc</code> is invalid. </p>

</div>
</div>
<a class="anchor" id="a466c814771a85f9b53e6681f4dc5c957"></a><!-- doxytag: member="dr_ir_utils.h::dr_cleanup_after_call" ref="a466c814771a85f9b53e6681f4dc5c957" args="(void *drcontext, instrlist_t *ilist, instr_t *where, uint sizeof_param_area)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dr_cleanup_after_call </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>drcontext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">instrlist_t *&nbsp;</td>
          <td class="paramname"> <em>ilist</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structinstr__t.html">instr_t</a> *&nbsp;</td>
          <td class="paramname"> <em>where</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&nbsp;</td>
          <td class="paramname"> <em>sizeof_param_area</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Inserts into <code>ilist</code> prior to <code>where</code> meta-instruction(s) to restore state after a call. </p>

</div>
</div>
<a class="anchor" id="a91ffde2808c16e07f323c34affa72209"></a><!-- doxytag: member="dr_ir_utils.h::dr_get_mcontext" ref="a91ffde2808c16e07f323c34affa72209" args="(void *drcontext, dr_mcontext_t *context)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool dr_get_mcontext </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>drcontext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct__dr__mcontext__t.html">dr_mcontext_t</a> *&nbsp;</td>
          <td class="paramname"> <em>context</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Copies the fields of the current application machine context selected by the <code>flags</code> field of <code>context</code> into <code>context</code>.</p>
<p>This routine may only be called from:</p>
<ul>
<li>A clean call invoked by <a class="el" href="dr__ir__utils_8h.html#ae7b7bd1e750b8a24ebf401fb6a6d6d5e">dr_insert_clean_call()</a> or <a class="el" href="dr__ir__utils_8h.html#a4608ec2db2a288aa5e2a53bb6d19054d">dr_prepare_for_call()</a></li>
<li>A pre- or post-syscall event (<a class="el" href="dr__events_8h.html#aa37d61a7f9dde4663b8dd4c3a44732f4">dr_register_pre_syscall_event()</a>, <a class="el" href="dr__events_8h.html#a099441f8d147404355c66178e3b19f0f">dr_register_post_syscall_event()</a>)</li>
<li>Basic block or trace creation events (<a class="el" href="dr__events_8h.html#a043a3588c4cf0c2d6838140fce530e72">dr_register_bb_event()</a>, <a class="el" href="dr__events_8h.html#a88a19a6822654caf18c017e145f48a57">dr_register_trace_event()</a>), but for basic block creation only when the basic block callback parameters <code>for_trace</code> and <code>translating</code> are false, and for trace creation only when <code>translating</code> is false.</li>
<li>A nudge callback (<a class="el" href="dr__events_8h.html#a9037603d0bd5bfca4198011adb8d10eb">dr_register_nudge_event()</a>) on Linux. (On Windows nudges happen in separate dedicated threads.)</li>
<li>A thread or process exit event (<a class="el" href="dr__events_8h.html#a0b0c102bb9a99d67c3e62ea8b3790ff1">dr_register_thread_exit_event()</a>, <a class="el" href="dr__events_8h.html#a985537df683007e1392e8a3b095ef363">dr_register_exit_event()</a>)</li>
<li>A thread init event (<a class="el" href="dr__events_8h.html#a878920c40c76e2c18043f9db772a24c0">dr_register_thread_init_event()</a>) for all but the initial thread.</li>
</ul>
<p>Even when DR_MC_CONTROL is specified, does NOT copy the pc field, except for system call events, when it will point at the post-syscall address.</p>
<p>Returns false if called from the init event or the initial thread's init event; returns true otherwise (cannot distinguish whether the caller is in a clean call so it is up to the caller to ensure it is used properly).</p>
<p>The size field of <code>context</code> must be set to the size of the structure as known at compile time. If the size field is invalid, this routine will return false.</p>
<p>The flags field of <code>context</code> must be set to the desired amount of information using the dr_mcontext_flags_t values. Asking for multimedia registers incurs a higher performance cost. An invalid flags value will return false.</p>
<dl class="note"><dt><b>Note:</b></dt><dd>NUM_XMM_SLOTS in the dr_mcontext_t.xmm array are filled in, but only if <a class="el" href="dr__ir__utils_8h.html#a5921c4f301ea05885f305f9a30b3c0b0">dr_mcontext_xmm_fields_valid()</a> returns true and DR_MC_MULTIMEDIA is set in the flags field.</dd>
<dd>
The context is the context saved at the <a class="el" href="dr__ir__utils_8h.html#ae7b7bd1e750b8a24ebf401fb6a6d6d5e">dr_insert_clean_call()</a> or <a class="el" href="dr__ir__utils_8h.html#a4608ec2db2a288aa5e2a53bb6d19054d">dr_prepare_for_call()</a> points. It does not correct for any registers saved with <a class="el" href="dr__ir__utils_8h.html#af294ac021c84f5ec47230ee7df0e6c02">dr_save_reg()</a>. To access registers saved with <a class="el" href="dr__ir__utils_8h.html#af294ac021c84f5ec47230ee7df0e6c02">dr_save_reg()</a> from a clean call use <a class="el" href="dr__ir__utils_8h.html#abb63ecfaa5256688bab9a2921fc19227">dr_read_saved_reg()</a>.</dd>
<dd>
System data structures are swapped to private versions prior to invoking clean calls or client events. Use <a class="el" href="dr__tools_8h.html#aa2944aa54d591a236f5334a35bfb41bf">dr_switch_to_app_state()</a> to examine the application version of system state. </dd></dl>

</div>
</div>
<a class="anchor" id="af2a3575059c29dae25ab02c9eb1d0ce9"></a><!-- doxytag: member="dr_ir_utils.h::dr_insert_call" ref="af2a3575059c29dae25ab02c9eb1d0ce9" args="(void *drcontext, instrlist_t *ilist, instr_t *where, void *callee, uint num_args,...)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dr_insert_call </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>drcontext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">instrlist_t *&nbsp;</td>
          <td class="paramname"> <em>ilist</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structinstr__t.html">instr_t</a> *&nbsp;</td>
          <td class="paramname"> <em>where</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>callee</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&nbsp;</td>
          <td class="paramname"> <em>num_args</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname"> <em>...</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Inserts into <code>ilist</code> prior to <code>where</code> meta-instruction(s) to set up the passed-in parameters, make a call to <code>callee</code>, and clean up the parameters.</p>
<p>The callee must use the standard C calling convention that matches the underlying 32-bit or 64-bit binary interface convention ("cdecl"). Other calling conventions, such as "fastcall" and "stdcall", are not supported.</p>
<p>This routine uses the existing stack. In 64-bit mode, this routine assumes that the stack pointer is currently 16-byte aligned.</p>
<p>The application state is NOT saved or restored (use <a class="el" href="dr__ir__utils_8h.html#a4608ec2db2a288aa5e2a53bb6d19054d">dr_prepare_for_call()</a> and <a class="el" href="dr__ir__utils_8h.html#a466c814771a85f9b53e6681f4dc5c957">dr_cleanup_after_call()</a>, or replace this routine with <a class="el" href="dr__ir__utils_8h.html#ae7b7bd1e750b8a24ebf401fb6a6d6d5e">dr_insert_clean_call()</a>). The parameter set-up may write to registers if the calling convention so dictates. The registers are NOT saved beforehand (to do so, use <a class="el" href="dr__ir__utils_8h.html#ae7b7bd1e750b8a24ebf401fb6a6d6d5e">dr_insert_clean_call()</a>).</p>
<p>It is up to the caller of this routine to preserve caller-saved registers.</p>
<p>DR does not support translating a fault in an argument. For fault transparency, the client must perform the translation (see <a class="el" href="dr__events_8h.html#ae7a179ac7a2d01157e1ab2852f50c902">dr_register_restore_state_event()</a>), or use <a class="el" href="dr__ir__utils_8h.html#ae7b7bd1e750b8a24ebf401fb6a6d6d5e">dr_insert_clean_call()</a>.</p>
<dl class="note"><dt><b>Note:</b></dt><dd>This routine only supports passing arguments that are integers or pointers of a size equal to the register size: i.e., no floating-point, multimedia, or aggregate data types. The routine also supports immediate integers that are smaller than the register size, and for 64-bit mode registers or memory references that are OPSZ_4.</dd>
<dd>
For 64-bit mode, passing arguments that use calling convention registers (for Windows, RCX, RDX, R8, R9; for Linux, RDI, RSI, RDX, RCX, R8 and R9) are supported but may incur additional stack usage.</dd>
<dd>
For 64-bit mode, if a 32-bit immediate integer is specified as an argument and it has its top bit set, we assume it is intended to be sign-extended to 64-bits; otherwise we zero-extend it.</dd>
<dd>
For 64-bit mode, variable-sized argument operands may not work properly.</dd>
<dd>
Arguments that reference DR_REG_XSP are not supported in 64-bit mode. </dd></dl>

</div>
</div>
<a class="anchor" id="a359744bc2776333fbf8f057931ca8eeb"></a><!-- doxytag: member="dr_ir_utils.h::dr_insert_call_instrumentation" ref="a359744bc2776333fbf8f057931ca8eeb" args="(void *drcontext, instrlist_t *ilist, instr_t *instr, void *callee)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dr_insert_call_instrumentation </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>drcontext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">instrlist_t *&nbsp;</td>
          <td class="paramname"> <em>ilist</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structinstr__t.html">instr_t</a> *&nbsp;</td>
          <td class="paramname"> <em>instr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>callee</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Assumes that <code>instr</code> is a near call. Inserts into <code>ilist</code> prior to <code>instr</code> instruction(s) to call callee passing two arguments:</p>
<ol type="1">
<li>address of call instruction (caller)</li>
<li>target address of call (callee) </li>
</ol>

</div>
</div>
<a class="anchor" id="abe09a1a1ca19b343279a65141c20f0a1"></a><!-- doxytag: member="dr_ir_utils.h::dr_insert_cbr_instrumentation" ref="abe09a1a1ca19b343279a65141c20f0a1" args="(void *drcontext, instrlist_t *ilist, instr_t *instr, void *callee)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dr_insert_cbr_instrumentation </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>drcontext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">instrlist_t *&nbsp;</td>
          <td class="paramname"> <em>ilist</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structinstr__t.html">instr_t</a> *&nbsp;</td>
          <td class="paramname"> <em>instr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>callee</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Assumes that <code>instr</code> is a conditional branch Inserts into <code>ilist</code> prior to <code>instr</code> instruction(s) to call callee passing three arguments:</p>
<ol type="1">
<li>address of branch instruction</li>
<li>target address of branch</li>
<li>0 if the branch is not taken, 1 if it is taken </li>
</ol>

</div>
</div>
<a class="anchor" id="ae7b7bd1e750b8a24ebf401fb6a6d6d5e"></a><!-- doxytag: member="dr_ir_utils.h::dr_insert_clean_call" ref="ae7b7bd1e750b8a24ebf401fb6a6d6d5e" args="(void *drcontext, instrlist_t *ilist, instr_t *where, void *callee, bool save_fpstate, uint num_args,...)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dr_insert_clean_call </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>drcontext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">instrlist_t *&nbsp;</td>
          <td class="paramname"> <em>ilist</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structinstr__t.html">instr_t</a> *&nbsp;</td>
          <td class="paramname"> <em>where</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>callee</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>save_fpstate</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&nbsp;</td>
          <td class="paramname"> <em>num_args</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname"> <em>...</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Inserts into <code>ilist</code> prior to <code>where</code> meta-instruction(s) to save state for a call, switch to this thread's DR stack, set up the passed-in parameters, make a call to <code>callee</code>, clean up the parameters, and then restore the saved state.</p>
<p>The callee must use the standard C calling convention that matches the underlying 32-bit or 64-bit binary interface convention ("cdecl"). Other calling conventions, such as "fastcall" and "stdcall", are not supported.</p>
<p>Stores the application state information on the DR stack, where it can be accessed from <code>callee</code> using <a class="el" href="dr__ir__utils_8h.html#a91ffde2808c16e07f323c34affa72209">dr_get_mcontext()</a> and modified using <a class="el" href="dr__ir__utils_8h.html#a56568d24667f5d64264d0bad398727b3">dr_set_mcontext()</a>.</p>
<p>If <code>save_fpstate</code> is true, preserves the fp/mmx/sse state on the DR stack. Note that it is relatively expensive to save this state (on the order of 200 cycles) and that it typically takes 512 bytes to store it (see <a class="el" href="dr__proc_8h.html#a468a29572175ba1d3ca7dbeb1fdbb825">proc_fpstate_save_size()</a>).</p>
<p>DR does support translating a fault in an argument (e.g., an argument that references application memory); such a fault will be treated as an application exception.</p>
<p>The clean call sequence will be optimized based on the runtime option <a class="el" href="using.html#op_cleancall">-opt_cleancall</a>.</p>
<dl class="note"><dt><b>Note:</b></dt><dd>The stack used to save state and call <code>callee</code> is limited to 20KB by default; this can be changed with the -stack_size DR runtime parameter. This stack cannot be used to store state that persists beyond <code>callee's</code> return point.</dd>
<dd>
This routine only supports passing arguments that are integers or pointers of a size equal to the register size: i.e., no floating-point, multimedia, or aggregate data types. The routine also supports immediate integers that are smaller than the register size, and for 64-bit mode registers or memory references that are OPSZ_4.</dd>
<dd>
For 64-bit mode, passing arguments that use calling convention registers (for Windows, RCX, RDX, R8, R9; for Linux, RDI, RSI, RDX, RCX, R8 and R9) are supported but may incur additional stack usage.</dd>
<dd>
For 64-bit mode, if a 32-bit immediate integer is specified as an argument and it has its top bit set, we assume it is intended to be sign-extended to 64-bits; otherwise we zero-extend it.</dd>
<dd>
For 64-bit mode, variable-sized argument operands may not work properly.</dd>
<dd>
Arguments that reference sub-register portions of DR_REG_XSP are not supported (full DR_REG_XSP is supported). </dd></dl>

</div>
</div>
<a class="anchor" id="a919e2106df67eaaa5bc6c49d736543b5"></a><!-- doxytag: member="dr_ir_utils.h::dr_insert_mbr_instrumentation" ref="a919e2106df67eaaa5bc6c49d736543b5" args="(void *drcontext, instrlist_t *ilist, instr_t *instr, void *callee, dr_spill_slot_t scratch_slot)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dr_insert_mbr_instrumentation </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>drcontext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">instrlist_t *&nbsp;</td>
          <td class="paramname"> <em>ilist</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structinstr__t.html">instr_t</a> *&nbsp;</td>
          <td class="paramname"> <em>instr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>callee</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="dr__ir__utils_8h.html#a89a6b714ff24d91d78589877047a29b9">dr_spill_slot_t</a>&nbsp;</td>
          <td class="paramname"> <em>scratch_slot</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Assumes that <code>instr</code> is an indirect branch. Inserts into <code>ilist</code> prior to <code>instr</code> instruction(s) to call callee passing two arguments:</p>
<ol type="1">
<li>address of branch instruction</li>
<li>target address of branch <dl class="note"><dt><b>Note:</b></dt><dd>Only the address portion of a far indirect branch is considered. </dd>
<dd>
<code>scratch_slot</code> must be &lt;= <a class="el" href="dr__ir__utils_8h.html#a762389f8ae9d809fd7b8f1418cdbd5ae">dr_max_opnd_accessible_spill_slot()</a>. <code>scratch_slot</code> is used internally to this routine and will be clobbered. </dd></dl>
</li>
</ol>

</div>
</div>
<a class="anchor" id="a3831354cc7402d68719d8055fb3e9931"></a><!-- doxytag: member="dr_ir_utils.h::dr_insert_read_tls_field" ref="a3831354cc7402d68719d8055fb3e9931" args="(void *drcontext, instrlist_t *ilist, instr_t *where, reg_id_t reg)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dr_insert_read_tls_field </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>drcontext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">instrlist_t *&nbsp;</td>
          <td class="paramname"> <em>ilist</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structinstr__t.html">instr_t</a> *&nbsp;</td>
          <td class="paramname"> <em>where</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">reg_id_t&nbsp;</td>
          <td class="paramname"> <em>reg</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Inserts into <code>ilist</code> prior to <code>where</code> meta-instruction(s) to read into the general-purpose full-size register <code>reg</code> from the user-controlled drcontext field for this thread. Reads from the same field as <a class="el" href="dr__tools_8h.html#a787aff5df1ded3de8a7ce9f3efef0594">dr_get_tls_field()</a>. </p>

</div>
</div>
<a class="anchor" id="a3647b439211a8cd70c40478a4113e128"></a><!-- doxytag: member="dr_ir_utils.h::dr_insert_ubr_instrumentation" ref="a3647b439211a8cd70c40478a4113e128" args="(void *drcontext, instrlist_t *ilist, instr_t *instr, void *callee)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dr_insert_ubr_instrumentation </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>drcontext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">instrlist_t *&nbsp;</td>
          <td class="paramname"> <em>ilist</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structinstr__t.html">instr_t</a> *&nbsp;</td>
          <td class="paramname"> <em>instr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>callee</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Assumes that <code>instr</code> is a direct, near, unconditional branch. Inserts into <code>ilist</code> prior to <code>instr</code> instruction(s) to call callee passing two arguments:</p>
<ol type="1">
<li>address of branch instruction</li>
<li>target address of branch</li>
</ol>
<dl class="warning"><dt><b>Warning:</b></dt><dd>Basic block eliding is controlled by -max_elide_jmp. If that option is set to non-zero, ubrs may never be seen. </dd></dl>

</div>
</div>
<a class="anchor" id="a982089284bd51339f448ec4b3928d3b4"></a><!-- doxytag: member="dr_ir_utils.h::dr_insert_write_tls_field" ref="a982089284bd51339f448ec4b3928d3b4" args="(void *drcontext, instrlist_t *ilist, instr_t *where, reg_id_t reg)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dr_insert_write_tls_field </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>drcontext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">instrlist_t *&nbsp;</td>
          <td class="paramname"> <em>ilist</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structinstr__t.html">instr_t</a> *&nbsp;</td>
          <td class="paramname"> <em>where</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">reg_id_t&nbsp;</td>
          <td class="paramname"> <em>reg</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Inserts into <code>ilist</code> prior to <code>where</code> meta-instruction(s) to write the general-purpose full-size register <code>reg</code> to the user-controlled drcontext field for this thread. Writes to the same field as <a class="el" href="dr__tools_8h.html#a05b499c8a3115e9ceb4c45dbee660738">dr_set_tls_field()</a>. </p>

</div>
</div>
<a class="anchor" id="a762389f8ae9d809fd7b8f1418cdbd5ae"></a><!-- doxytag: member="dr_ir_utils.h::dr_max_opnd_accessible_spill_slot" ref="a762389f8ae9d809fd7b8f1418cdbd5ae" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="dr__ir__utils_8h.html#a89a6b714ff24d91d78589877047a29b9">dr_spill_slot_t</a> dr_max_opnd_accessible_spill_slot </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Returns the largest dr_spill_slot_t that can be accessed with an <a class="el" href="structopnd__t.html">opnd_t</a> from <a class="el" href="dr__ir__utils_8h.html#a5eab608c134db044f2d9453a8407d470">dr_reg_spill_slot_opnd()</a>. </p>

</div>
</div>
<a class="anchor" id="a5921c4f301ea05885f305f9a30b3c0b0"></a><!-- doxytag: member="dr_ir_utils.h::dr_mcontext_xmm_fields_valid" ref="a5921c4f301ea05885f305f9a30b3c0b0" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool dr_mcontext_xmm_fields_valid </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Returns true if the xmm0 through xmm5 for Windows, or xmm0 through xmm15 for 64-bit Linux, or xmm0 through xmm7 for 32-bit Linux, fields in dr_mcontext_t are valid for this process (i.e., whether this process is 64-bit or WOW64, and the processor supports SSE). </p>
<dl class="note"><dt><b>Note:</b></dt><dd>If DR_MC_MULTIMEDIA is not specified when calling <a class="el" href="dr__ir__utils_8h.html#a91ffde2808c16e07f323c34affa72209">dr_get_mcontext()</a>, the xmm fields will not be filled in regardless of the return value of this routine. </dd></dl>

</div>
</div>
<a class="anchor" id="a4608ec2db2a288aa5e2a53bb6d19054d"></a><!-- doxytag: member="dr_ir_utils.h::dr_prepare_for_call" ref="a4608ec2db2a288aa5e2a53bb6d19054d" args="(void *drcontext, instrlist_t *ilist, instr_t *instr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint dr_prepare_for_call </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>drcontext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">instrlist_t *&nbsp;</td>
          <td class="paramname"> <em>ilist</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structinstr__t.html">instr_t</a> *&nbsp;</td>
          <td class="paramname"> <em>instr</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Inserts into <code>ilist</code> prior to <code>where</code> meta-instruction(s) to save state for a call. Stores the application state information on the DR stack. Returns the size of the data stored on the DR stack (in case the caller needs to align the stack pointer).</p>
<dl class="warning"><dt><b>Warning:</b></dt><dd>This routine does NOT save the fp/mmx/sse state: to do that the instrumentation routine should call <a class="el" href="dr__proc_8h.html#a4a11c9d5d127ce126562ad35b4d165dd">proc_save_fpstate()</a> to save and then <a class="el" href="dr__proc_8h.html#a23edceee5d1ae7c7d51a212432e6d644">proc_restore_fpstate()</a> to restore (or use <a class="el" href="dr__ir__utils_8h.html#ae7b7bd1e750b8a24ebf401fb6a6d6d5e">dr_insert_clean_call()</a>).</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>The preparation modifies the DR_REG_XSP and DR_REG_XAX registers (after saving them). Use <a class="el" href="dr__ir__utils_8h.html#ae7b7bd1e750b8a24ebf401fb6a6d6d5e">dr_insert_clean_call()</a> instead if an argument to the subsequent call that references DR_REG_XAX is desired.</dd>
<dd>
The stack used to save the state is limited to 20KB by default; this can be changed with the -stack_size DR runtime parameter. This stack cannot be used to store state that persists beyond a single clean call, code cache execution, or probe callback function execution. </dd></dl>

</div>
</div>
<a class="anchor" id="abb63ecfaa5256688bab9a2921fc19227"></a><!-- doxytag: member="dr_ir_utils.h::dr_read_saved_reg" ref="abb63ecfaa5256688bab9a2921fc19227" args="(void *drcontext, dr_spill_slot_t slot)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">reg_t dr_read_saved_reg </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>drcontext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="dr__ir__utils_8h.html#a89a6b714ff24d91d78589877047a29b9">dr_spill_slot_t</a>&nbsp;</td>
          <td class="paramname"> <em>slot</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Can be used from a clean call or a restore_state_event (see <a class="el" href="dr__events_8h.html#ae7a179ac7a2d01157e1ab2852f50c902">dr_register_restore_state_event()</a>) to see the value saved in spill slot <code>slot</code> by <a class="el" href="dr__ir__utils_8h.html#af294ac021c84f5ec47230ee7df0e6c02">dr_save_reg()</a>. </p>

</div>
</div>
<a class="anchor" id="a9f612cf9d0ca2025b23d30b6f5bb0231"></a><!-- doxytag: member="dr_ir_utils.h::dr_redirect_execution" ref="a9f612cf9d0ca2025b23d30b6f5bb0231" args="(dr_mcontext_t *context)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool dr_redirect_execution </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct__dr__mcontext__t.html">dr_mcontext_t</a> *&nbsp;</td>
          <td class="paramname"> <em>context</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Immediately resumes application execution from a clean call out of the cache (see <a class="el" href="dr__ir__utils_8h.html#ae7b7bd1e750b8a24ebf401fb6a6d6d5e">dr_insert_clean_call()</a> or <a class="el" href="dr__ir__utils_8h.html#a4608ec2db2a288aa5e2a53bb6d19054d">dr_prepare_for_call()</a>) or an exception event with the state specified in <code>mcontext</code> (including pc, and including the xmm fields that are valid according to <a class="el" href="dr__ir__utils_8h.html#a5921c4f301ea05885f305f9a30b3c0b0">dr_mcontext_xmm_fields_valid()</a>). The flags field of <code>context</code> must contain DR_MC_ALL; using a partial set of fields is not suported.</p>
<dl class="note"><dt><b>Note:</b></dt><dd><a class="el" href="dr__ir__utils_8h.html#a91ffde2808c16e07f323c34affa72209">dr_get_mcontext()</a> can be used to get the register state (except pc) saved in <a class="el" href="dr__ir__utils_8h.html#ae7b7bd1e750b8a24ebf401fb6a6d6d5e">dr_insert_clean_call()</a> or <a class="el" href="dr__ir__utils_8h.html#a4608ec2db2a288aa5e2a53bb6d19054d">dr_prepare_for_call()</a></dd>
<dd>
If floating point state was saved by <a class="el" href="dr__ir__utils_8h.html#a4608ec2db2a288aa5e2a53bb6d19054d">dr_prepare_for_call()</a> or <a class="el" href="dr__ir__utils_8h.html#ae7b7bd1e750b8a24ebf401fb6a6d6d5e">dr_insert_clean_call()</a> it is not restored (other than the valid xmm fields according to <a class="el" href="dr__ir__utils_8h.html#a5921c4f301ea05885f305f9a30b3c0b0">dr_mcontext_xmm_fields_valid()</a>, if DR_MC_MULTIMEDIA is specified in the flags field). The caller should instead manually save and restore the floating point state with <a class="el" href="dr__proc_8h.html#a4a11c9d5d127ce126562ad35b4d165dd">proc_save_fpstate()</a> and <a class="el" href="dr__proc_8h.html#a23edceee5d1ae7c7d51a212432e6d644">proc_restore_fpstate()</a> if necessary.</dd>
<dd>
If the caller wishes to set any other state (such as xmm registers that are not part of the mcontext) they may do so by just setting that state in the current thread before making this call. To set system data structures, use <a class="el" href="dr__tools_8h.html#aa2944aa54d591a236f5334a35bfb41bf">dr_switch_to_app_state()</a>, make the changes, and then switch back with <a class="el" href="dr__tools_8h.html#a97ba972c50a47e7121c98652b461ae8e">dr_switch_to_dr_state()</a> before calling this routine.</dd>
<dd>
This routine may only be called from a clean call from the cache. It can not be called from any registered event callback. </dd></dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>false if unsuccessful; if successful, does not return. </dd></dl>

</div>
</div>
<a class="anchor" id="a5eab608c134db044f2d9453a8407d470"></a><!-- doxytag: member="dr_ir_utils.h::dr_reg_spill_slot_opnd" ref="a5eab608c134db044f2d9453a8407d470" args="(void *drcontext, dr_spill_slot_t slot)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structopnd__t.html">opnd_t</a> dr_reg_spill_slot_opnd </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>drcontext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="dr__ir__utils_8h.html#a89a6b714ff24d91d78589877047a29b9">dr_spill_slot_t</a>&nbsp;</td>
          <td class="paramname"> <em>slot</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Returns an <a class="el" href="structopnd__t.html">opnd_t</a> that directly accesses the spill slot <code>slot</code>. Only slots &lt;= <a class="el" href="dr__ir__utils_8h.html#a762389f8ae9d809fd7b8f1418cdbd5ae">dr_max_opnd_accessible_spill_slot()</a> can be used with this routine. </p>
<dl class="note"><dt><b>Note:</b></dt><dd><code>slot</code> must be &lt;= <a class="el" href="dr__ir__utils_8h.html#a762389f8ae9d809fd7b8f1418cdbd5ae">dr_max_opnd_accessible_spill_slot()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a9a2c851eeeee7e669f3e6a7b877977d1"></a><!-- doxytag: member="dr_ir_utils.h::dr_restore_app_stack" ref="a9a2c851eeeee7e669f3e6a7b877977d1" args="(void *drcontext, instrlist_t *ilist, instr_t *where)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dr_restore_app_stack </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>drcontext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">instrlist_t *&nbsp;</td>
          <td class="paramname"> <em>ilist</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structinstr__t.html">instr_t</a> *&nbsp;</td>
          <td class="paramname"> <em>where</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Inserts into <code>ilist</code> prior to <code>where</code> meta-instruction(s) to restore into esp the value saved by dr_swap_to_dr_stack(). </p>

</div>
</div>
<a class="anchor" id="a563b0de37a51cb2e84337deef30a57cf"></a><!-- doxytag: member="dr_ir_utils.h::dr_restore_arith_flags" ref="a563b0de37a51cb2e84337deef30a57cf" args="(void *drcontext, instrlist_t *ilist, instr_t *where, dr_spill_slot_t slot)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dr_restore_arith_flags </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>drcontext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">instrlist_t *&nbsp;</td>
          <td class="paramname"> <em>ilist</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structinstr__t.html">instr_t</a> *&nbsp;</td>
          <td class="paramname"> <em>where</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="dr__ir__utils_8h.html#a89a6b714ff24d91d78589877047a29b9">dr_spill_slot_t</a>&nbsp;</td>
          <td class="paramname"> <em>slot</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Inserts into <code>ilist</code> prior to <code>where</code> meta-instruction(s) to restore the 6 arithmetic flags, assuming they were saved using <a class="el" href="dr__ir__utils_8h.html#a44636ca6809a9fb22cf817701de9ee09">dr_save_arith_flags()</a> with slot <code>slot</code> and that xax holds the same value it did after the save. </p>

</div>
</div>
<a class="anchor" id="a453bc3ecddb4298ffdc1c429f30881b8"></a><!-- doxytag: member="dr_ir_utils.h::dr_restore_reg" ref="a453bc3ecddb4298ffdc1c429f30881b8" args="(void *drcontext, instrlist_t *ilist, instr_t *where, reg_id_t reg, dr_spill_slot_t slot)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dr_restore_reg </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>drcontext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">instrlist_t *&nbsp;</td>
          <td class="paramname"> <em>ilist</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structinstr__t.html">instr_t</a> *&nbsp;</td>
          <td class="paramname"> <em>where</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">reg_id_t&nbsp;</td>
          <td class="paramname"> <em>reg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="dr__ir__utils_8h.html#a89a6b714ff24d91d78589877047a29b9">dr_spill_slot_t</a>&nbsp;</td>
          <td class="paramname"> <em>slot</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Inserts into <code>ilist</code> prior to <code>where</code> meta-instruction(s) to restore the register <code>reg</code> from the spill slot <code>slot</code>. See <a class="el" href="dr__ir__utils_8h.html#af294ac021c84f5ec47230ee7df0e6c02">dr_save_reg()</a> for notes on lifetime and alternative access to spill slots. </p>

</div>
</div>
<a class="anchor" id="a44636ca6809a9fb22cf817701de9ee09"></a><!-- doxytag: member="dr_ir_utils.h::dr_save_arith_flags" ref="a44636ca6809a9fb22cf817701de9ee09" args="(void *drcontext, instrlist_t *ilist, instr_t *where, dr_spill_slot_t slot)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dr_save_arith_flags </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>drcontext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">instrlist_t *&nbsp;</td>
          <td class="paramname"> <em>ilist</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structinstr__t.html">instr_t</a> *&nbsp;</td>
          <td class="paramname"> <em>where</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="dr__ir__utils_8h.html#a89a6b714ff24d91d78589877047a29b9">dr_spill_slot_t</a>&nbsp;</td>
          <td class="paramname"> <em>slot</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Inserts into <code>ilist</code> prior to <code>where</code> meta-instruction(s) to save the 6 arithmetic flags into xax after first saving xax to the spill slot <code>slot</code>. This is equivalent to <a class="el" href="dr__ir__utils_8h.html#af294ac021c84f5ec47230ee7df0e6c02">dr_save_reg()</a> of xax to <code>slot</code> followed by lahf and seto al instructions. See <a class="el" href="dr__ir__utils_8h.html#a563b0de37a51cb2e84337deef30a57cf">dr_restore_arith_flags()</a>.</p>
<dl class="note"><dt><b>Note:</b></dt><dd>At completion of the inserted instructions the saved flags are in the xax register. The xax register should not be modified after using this routine unless it is first saved (and later restored prior to using <a class="el" href="dr__ir__utils_8h.html#a563b0de37a51cb2e84337deef30a57cf">dr_restore_arith_flags()</a>). </dd></dl>

</div>
</div>
<a class="anchor" id="af294ac021c84f5ec47230ee7df0e6c02"></a><!-- doxytag: member="dr_ir_utils.h::dr_save_reg" ref="af294ac021c84f5ec47230ee7df0e6c02" args="(void *drcontext, instrlist_t *ilist, instr_t *where, reg_id_t reg, dr_spill_slot_t slot)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dr_save_reg </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>drcontext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">instrlist_t *&nbsp;</td>
          <td class="paramname"> <em>ilist</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structinstr__t.html">instr_t</a> *&nbsp;</td>
          <td class="paramname"> <em>where</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">reg_id_t&nbsp;</td>
          <td class="paramname"> <em>reg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="dr__ir__utils_8h.html#a89a6b714ff24d91d78589877047a29b9">dr_spill_slot_t</a>&nbsp;</td>
          <td class="paramname"> <em>slot</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Inserts into <code>ilist</code> prior to <code>where</code> meta-instruction(s) to save the register <code>reg</code> in the spill slot <code>slot</code>. See <a class="el" href="dr__ir__utils_8h.html#a453bc3ecddb4298ffdc1c429f30881b8">dr_restore_reg()</a>. Use <a class="el" href="dr__ir__utils_8h.html#abb63ecfaa5256688bab9a2921fc19227">dr_read_saved_reg()</a> and <a class="el" href="dr__ir__utils_8h.html#abf8d50d718883a1caf6a2de0fb3dbce3">dr_write_saved_reg()</a> to access spill slots from clean calls and restore_state_events (see <a class="el" href="dr__events_8h.html#ae7a179ac7a2d01157e1ab2852f50c902">dr_register_restore_state_event()</a>). </p>
<dl class="note"><dt><b>Note:</b></dt><dd>The stored value remains available only until the next non-meta (i.e. application) instruction. Use <a class="el" href="dr__ir__utils_8h.html#a982089284bd51339f448ec4b3928d3b4">dr_insert_write_tls_field()</a> and <a class="el" href="dr__ir__utils_8h.html#a3831354cc7402d68719d8055fb3e9931">dr_insert_read_tls_field()</a> for a persistent (but more costly to access) thread-local-storage location. See also <a class="el" href="dr__tools_8h.html#a95b53d79cae021a473c39f3b2662323f">dr_raw_tls_calloc()</a>. </dd></dl>

</div>
</div>
<a class="anchor" id="a56568d24667f5d64264d0bad398727b3"></a><!-- doxytag: member="dr_ir_utils.h::dr_set_mcontext" ref="a56568d24667f5d64264d0bad398727b3" args="(void *drcontext, dr_mcontext_t *context)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool dr_set_mcontext </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>drcontext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct__dr__mcontext__t.html">dr_mcontext_t</a> *&nbsp;</td>
          <td class="paramname"> <em>context</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Sets the fields of the application machine context selected by the flags field of <code>context</code> to the values in <code>context</code>.</p>
<p>This routine may only be called from:</p>
<ul>
<li>A clean call invoked by <a class="el" href="dr__ir__utils_8h.html#ae7b7bd1e750b8a24ebf401fb6a6d6d5e">dr_insert_clean_call()</a> or <a class="el" href="dr__ir__utils_8h.html#a4608ec2db2a288aa5e2a53bb6d19054d">dr_prepare_for_call()</a></li>
<li>A pre- or post-syscall event (<a class="el" href="dr__events_8h.html#aa37d61a7f9dde4663b8dd4c3a44732f4">dr_register_pre_syscall_event()</a>, <a class="el" href="dr__events_8h.html#a099441f8d147404355c66178e3b19f0f">dr_register_post_syscall_event()</a>) <a class="el" href="dr__events_8h.html#a0b0c102bb9a99d67c3e62ea8b3790ff1">dr_register_thread_exit_event()</a>)</li>
<li>Basic block or trace creation events (<a class="el" href="dr__events_8h.html#a043a3588c4cf0c2d6838140fce530e72">dr_register_bb_event()</a>, <a class="el" href="dr__events_8h.html#a88a19a6822654caf18c017e145f48a57">dr_register_trace_event()</a>), but for basic block creation only when the basic block callback parameters <code>for_trace</code> and <code>translating</code> are false, and for trace creation only when <code>translating</code> is false.</li>
</ul>
<p>Ignores the pc field.</p>
<p>If the size field of <code>context</code> is invalid, this routine will return false. A dr_mcontext_t obtained from DR will have the size field set.</p>
<p>The flags field of <code>context</code> must be set to select the desired fields for copying, using the dr_mcontext_flags_t values. Asking to copy multimedia registers incurs a higher performance cost. An invalid flags value will return false.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>whether successful.</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>The xmm fields are only set for processes where the underlying processor supports them (and when DR_MC_MULTIMEDIA is set in the flags field). For <a class="el" href="dr__ir__utils_8h.html#ae7b7bd1e750b8a24ebf401fb6a6d6d5e">dr_insert_clean_call()</a> that requested <code>save_fpstate</code>, the xmm values set here override that saved state. Use <a class="el" href="dr__ir__utils_8h.html#a5921c4f301ea05885f305f9a30b3c0b0">dr_mcontext_xmm_fields_valid()</a> to determine whether the xmm fields are valid. </dd></dl>

</div>
</div>
<a class="anchor" id="a9647e1300201596bc818ca33c95d4cc6"></a><!-- doxytag: member="dr_ir_utils.h::dr_swap_to_clean_stack" ref="a9647e1300201596bc818ca33c95d4cc6" args="(void *drcontext, instrlist_t *ilist, instr_t *where)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dr_swap_to_clean_stack </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>drcontext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">instrlist_t *&nbsp;</td>
          <td class="paramname"> <em>ilist</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structinstr__t.html">instr_t</a> *&nbsp;</td>
          <td class="paramname"> <em>where</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Inserts into <code>ilist</code> prior to <code>where</code> meta-instruction(s) to save the current esp and switch to this thread's DR stack. </p>
<dl class="note"><dt><b>Note:</b></dt><dd>The DR stack is limited to 20KB by default; this can be changed with the -stack_size DR runtime parameter. This stack cannot be used to store state that persists beyond a single clean call, code cache execution, or probe callback function execution. </dd></dl>

</div>
</div>
<a class="anchor" id="abf8d50d718883a1caf6a2de0fb3dbce3"></a><!-- doxytag: member="dr_ir_utils.h::dr_write_saved_reg" ref="abf8d50d718883a1caf6a2de0fb3dbce3" args="(void *drcontext, dr_spill_slot_t slot, reg_t value)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dr_write_saved_reg </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>drcontext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="dr__ir__utils_8h.html#a89a6b714ff24d91d78589877047a29b9">dr_spill_slot_t</a>&nbsp;</td>
          <td class="paramname"> <em>slot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">reg_t&nbsp;</td>
          <td class="paramname"> <em>value</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Can be used from a clean call to modify the value saved in the spill slot <code>slot</code> by <a class="el" href="dr__ir__utils_8h.html#af294ac021c84f5ec47230ee7df0e6c02">dr_save_reg()</a> such that a later <a class="el" href="dr__ir__utils_8h.html#a453bc3ecddb4298ffdc1c429f30881b8">dr_restore_reg()</a> will see the new value.</p>
<dl class="note"><dt><b>Note:</b></dt><dd>This routine should only be used during a clean call out of the cache. Use at any other time could corrupt application or DynamoRIO state. </dd></dl>

</div>
</div>
<a class="anchor" id="aa18c8ca0720c97403a0fa9371ae792e5"></a><!-- doxytag: member="dr_ir_utils.h::get_x86_mode" ref="aa18c8ca0720c97403a0fa9371ae792e5" args="(void *drcontext)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool get_x86_mode </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>drcontext</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>The decode and encode routines use a per-thread persistent flag that indicates whether to treat code as 32-bit (x86) or 64-bit (x64). This routine returns the value of that flag.</p>
<dl class="note"><dt><b>Note:</b></dt><dd>For 64-bit DR builds only. </dd></dl>

</div>
</div>
<a class="anchor" id="a824eaa9075a7aaf443b4cc4180eec81e"></a><!-- doxytag: member="dr_ir_utils.h::instrlist_meta_append" ref="a824eaa9075a7aaf443b4cc4180eec81e" args="(instrlist_t *ilist, instr_t *instr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void instrlist_meta_append </td>
          <td>(</td>
          <td class="paramtype">instrlist_t *&nbsp;</td>
          <td class="paramname"> <em>ilist</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structinstr__t.html">instr_t</a> *&nbsp;</td>
          <td class="paramname"> <em>instr</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Inserts <code>instr</code> as a non-application instruction onto the end of <code>ilist</code> </p>

</div>
</div>
<a class="anchor" id="a94a1526c7b520c9aefbd775adfc57108"></a><!-- doxytag: member="dr_ir_utils.h::instrlist_meta_fault_append" ref="a94a1526c7b520c9aefbd775adfc57108" args="(instrlist_t *ilist, instr_t *instr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void instrlist_meta_fault_append </td>
          <td>(</td>
          <td class="paramtype">instrlist_t *&nbsp;</td>
          <td class="paramname"> <em>ilist</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structinstr__t.html">instr_t</a> *&nbsp;</td>
          <td class="paramname"> <em>instr</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Inserts <code>instr</code> as a non-application instruction that can fault (see <a class="el" href="dr__ir__instr_8h.html#a94227a193446d370f0180e6a844be0c2">instr_set_meta_may_fault()</a>) onto the end of <code>ilist</code>.</p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000005">Deprecated:</a></b></dt><dd>Essentially equivalent to <a class="el" href="dr__ir__utils_8h.html#a824eaa9075a7aaf443b4cc4180eec81e">instrlist_meta_append()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a6ea095671bab4239c659d17d4a9cda56"></a><!-- doxytag: member="dr_ir_utils.h::instrlist_meta_fault_postinsert" ref="a6ea095671bab4239c659d17d4a9cda56" args="(instrlist_t *ilist, instr_t *where, instr_t *instr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void instrlist_meta_fault_postinsert </td>
          <td>(</td>
          <td class="paramtype">instrlist_t *&nbsp;</td>
          <td class="paramname"> <em>ilist</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structinstr__t.html">instr_t</a> *&nbsp;</td>
          <td class="paramname"> <em>where</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structinstr__t.html">instr_t</a> *&nbsp;</td>
          <td class="paramname"> <em>instr</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Inserts <code>instr</code> as a non-application instruction that can fault (see <a class="el" href="dr__ir__instr_8h.html#a94227a193446d370f0180e6a844be0c2">instr_set_meta_may_fault()</a>) into <code>ilist</code> after <code>where</code>.</p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000004">Deprecated:</a></b></dt><dd>Essentially equivalent to <a class="el" href="dr__ir__utils_8h.html#a98218650e1f61b58c5478cf68e25d9da">instrlist_meta_postinsert()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="affe811040a2962e5c6920a3c523212ab"></a><!-- doxytag: member="dr_ir_utils.h::instrlist_meta_fault_preinsert" ref="affe811040a2962e5c6920a3c523212ab" args="(instrlist_t *ilist, instr_t *where, instr_t *instr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void instrlist_meta_fault_preinsert </td>
          <td>(</td>
          <td class="paramtype">instrlist_t *&nbsp;</td>
          <td class="paramname"> <em>ilist</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structinstr__t.html">instr_t</a> *&nbsp;</td>
          <td class="paramname"> <em>where</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structinstr__t.html">instr_t</a> *&nbsp;</td>
          <td class="paramname"> <em>instr</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Inserts <code>instr</code> as a non-application instruction that can fault (see <a class="el" href="dr__ir__instr_8h.html#a94227a193446d370f0180e6a844be0c2">instr_set_meta_may_fault()</a>) into <code>ilist</code> prior to <code>where</code>.</p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000003">Deprecated:</a></b></dt><dd>Essentially equivalent to <a class="el" href="dr__ir__utils_8h.html#a3b0b7e9e09a9a85ca1a707da3ded6f69">instrlist_meta_preinsert()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a98218650e1f61b58c5478cf68e25d9da"></a><!-- doxytag: member="dr_ir_utils.h::instrlist_meta_postinsert" ref="a98218650e1f61b58c5478cf68e25d9da" args="(instrlist_t *ilist, instr_t *where, instr_t *instr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void instrlist_meta_postinsert </td>
          <td>(</td>
          <td class="paramtype">instrlist_t *&nbsp;</td>
          <td class="paramname"> <em>ilist</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structinstr__t.html">instr_t</a> *&nbsp;</td>
          <td class="paramname"> <em>where</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structinstr__t.html">instr_t</a> *&nbsp;</td>
          <td class="paramname"> <em>instr</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Inserts <code>instr</code> as a non-application instruction into <code>ilist</code> after <code>where</code>. </p>

</div>
</div>
<a class="anchor" id="a3b0b7e9e09a9a85ca1a707da3ded6f69"></a><!-- doxytag: member="dr_ir_utils.h::instrlist_meta_preinsert" ref="a3b0b7e9e09a9a85ca1a707da3ded6f69" args="(instrlist_t *ilist, instr_t *where, instr_t *instr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void instrlist_meta_preinsert </td>
          <td>(</td>
          <td class="paramtype">instrlist_t *&nbsp;</td>
          <td class="paramname"> <em>ilist</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structinstr__t.html">instr_t</a> *&nbsp;</td>
          <td class="paramname"> <em>where</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structinstr__t.html">instr_t</a> *&nbsp;</td>
          <td class="paramname"> <em>instr</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Inserts <code>instr</code> as a non-application instruction into <code>ilist</code> prior to <code>where</code>. </p>

</div>
</div>
<a class="anchor" id="adf9a4f63eafc7f9725f7d5bf1725ab5c"></a><!-- doxytag: member="dr_ir_utils.h::set_x86_mode" ref="adf9a4f63eafc7f9725f7d5bf1725ab5c" args="(void *drcontext, bool x86)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool set_x86_mode </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>drcontext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>x86</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>The decode and encode routines use a per-thread persistent flag that indicates whether to treat code as 32-bit (x86) or 64-bit (x64). This routine sets that flag to the indicated value and returns the old value. Be sure to restore the old value prior to any further application execution to avoid problems in mis-interpreting application code.</p>
<dl class="note"><dt><b>Note:</b></dt><dd>For 64-bit DR builds only. </dd></dl>

</div>
</div>
</div>
<hr size="1"><address style="text-align: center;"><small>
<img border=0 src="favicon.png"> &nbsp; DynamoRIO API version 3.2.0 --- Wed Mar 28 12:55:33 2012 
&nbsp; <img border=0 src="favicon.png">
</body>
</html>
