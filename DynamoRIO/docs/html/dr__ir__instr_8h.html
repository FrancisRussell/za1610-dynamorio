<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>DynamoRIO API: dr_ir_instr.h File Reference</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
<link rel="shortcut icon" type="image/x-icon" href="favicon.ico" />
</head><body>
<!-- Generated by Doxygen 1.6.3 -->
<div class="contents">
<h1>dr_ir_instr.h File Reference</h1>
<p>Functions to create and manipulate instructions.  
<a href="#_details">More...</a></p>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td colspan="2"><h2>Data Structures</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct__dr__instr__label__data__t.html">_dr_instr_label_data_t</a></td></tr>
<tr><td colspan="2"><h2>Defines</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__instr_8h.html#add002513aebf166b7fdae13d22828d8d">EFLAGS_READ_CF</a>&nbsp;&nbsp;&nbsp;0x00000001</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__instr_8h.html#afa533378650b8a86c903410a8abe5789">EFLAGS_READ_PF</a>&nbsp;&nbsp;&nbsp;0x00000002</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__instr_8h.html#a43c54ddcc858950e361725de7bc870d6">EFLAGS_READ_AF</a>&nbsp;&nbsp;&nbsp;0x00000004</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__instr_8h.html#a8385b4d8340260aad30cf5b8455a4efd">EFLAGS_READ_ZF</a>&nbsp;&nbsp;&nbsp;0x00000008</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__instr_8h.html#ae9e0eb52c091f04e29148ca5e7ae2199">EFLAGS_READ_SF</a>&nbsp;&nbsp;&nbsp;0x00000010</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__instr_8h.html#aebf7d3cf0c4e6b2f39c3a07533419837">EFLAGS_READ_TF</a>&nbsp;&nbsp;&nbsp;0x00000020</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__instr_8h.html#a5a57b4b5098e1ff53bb8a990eec54a14">EFLAGS_READ_IF</a>&nbsp;&nbsp;&nbsp;0x00000040</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__instr_8h.html#a241f4fe5f01af11fe8e9489fcf84ab4a">EFLAGS_READ_DF</a>&nbsp;&nbsp;&nbsp;0x00000080</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__instr_8h.html#a5b5f953da018e1530879109cb78095b0">EFLAGS_READ_OF</a>&nbsp;&nbsp;&nbsp;0x00000100</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__instr_8h.html#ab70baddbcff9ed31c328376956f7b0ea">EFLAGS_READ_NT</a>&nbsp;&nbsp;&nbsp;0x00000200</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__instr_8h.html#a14e4b47d88d4014fedaed25482d39b34">EFLAGS_READ_RF</a>&nbsp;&nbsp;&nbsp;0x00000400</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__instr_8h.html#afafb04c014284b3c4b51b0c6d17be085">EFLAGS_WRITE_CF</a>&nbsp;&nbsp;&nbsp;0x00000800</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__instr_8h.html#a302bd46f54cf696a1039c5d25f68bd02">EFLAGS_WRITE_PF</a>&nbsp;&nbsp;&nbsp;0x00001000</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__instr_8h.html#a9e0d29af655c408ddc915cc07c8ac95e">EFLAGS_WRITE_AF</a>&nbsp;&nbsp;&nbsp;0x00002000</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__instr_8h.html#a5329db528d9d749deae463b9b8edd736">EFLAGS_WRITE_ZF</a>&nbsp;&nbsp;&nbsp;0x00004000</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__instr_8h.html#a6b5ddab727f9e2c9d49f20bcfd07807b">EFLAGS_WRITE_SF</a>&nbsp;&nbsp;&nbsp;0x00008000</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__instr_8h.html#aac1ee8f92225d554aba043211c34e18b">EFLAGS_WRITE_TF</a>&nbsp;&nbsp;&nbsp;0x00010000</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__instr_8h.html#ab61834da87126c5c1b3b5b89a1bb254e">EFLAGS_WRITE_IF</a>&nbsp;&nbsp;&nbsp;0x00020000</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__instr_8h.html#abb180e5ea86b98e6bbd65708e202e6f1">EFLAGS_WRITE_DF</a>&nbsp;&nbsp;&nbsp;0x00040000</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__instr_8h.html#a3d8edc641bb696aceadb34b6d5179761">EFLAGS_WRITE_OF</a>&nbsp;&nbsp;&nbsp;0x00080000</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__instr_8h.html#a533d9a5cd836be7bd8f831256b9d407e">EFLAGS_WRITE_NT</a>&nbsp;&nbsp;&nbsp;0x00100000</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__instr_8h.html#a1ad8fd64cd98ac35c20265b54de97cf2">EFLAGS_WRITE_RF</a>&nbsp;&nbsp;&nbsp;0x00200000</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__instr_8h.html#a88d4ed7d7b9c544c09c395872a86c0ea">EFLAGS_READ_ALL</a>&nbsp;&nbsp;&nbsp;0x000007ff</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__instr_8h.html#ab5727b7a5773bace9d656e4b969d7fce">EFLAGS_WRITE_ALL</a>&nbsp;&nbsp;&nbsp;0x003ff800</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__instr_8h.html#ad61b67b227ebe0012829621c25ca65f5">EFLAGS_READ_6</a>&nbsp;&nbsp;&nbsp;0x0000011f</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__instr_8h.html#a8287fcf9cd6cd2338a57c54e45b08a7f">EFLAGS_WRITE_6</a>&nbsp;&nbsp;&nbsp;0x0008f800</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__instr_8h.html#a2f1cca9ca8d0514a42f66c081f478231">EFLAGS_WRITE_TO_READ</a>(x)&nbsp;&nbsp;&nbsp;((x) &gt;&gt; 11)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__instr_8h.html#afbe5d20458bd272fdeac681706c4bd14">EFLAGS_READ_TO_WRITE</a>(x)&nbsp;&nbsp;&nbsp;((x) &lt;&lt; 11)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__instr_8h.html#a697ecea613b828838ff6f08b88adf1d2">PREFIX_LOCK</a>&nbsp;&nbsp;&nbsp;0x1</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__instr_8h.html#a0e6a144b4030140faa950fe65fe9002d">PREFIX_JCC_NOT_TAKEN</a>&nbsp;&nbsp;&nbsp;0x2</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__instr_8h.html#a327356db32ce7a884e9a516b2d91b738">PREFIX_JCC_TAKEN</a>&nbsp;&nbsp;&nbsp;0x4</td></tr>
<tr><td colspan="2"><h2>Typedefs</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef struct <br class="typebreak"/>
<a class="el" href="struct__dr__instr__label__data__t.html">_dr_instr_label_data_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__instr_8h.html#af29c184442681322a7a77ab2a48ba889">dr_instr_label_data_t</a></td></tr>
<tr><td colspan="2"><h2>Enumerations</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom">{ <br/>
&nbsp;&nbsp;<a class="el" href="dr__ir__instr_8h.html#adb49720dc49f7d4e4cf9adbf2948e409aef9a85103f89f1abdcbc577177fe59dc">EFLAGS_CF</a> =  0x00000001, 
<br/>
&nbsp;&nbsp;<a class="el" href="dr__ir__instr_8h.html#adb49720dc49f7d4e4cf9adbf2948e409abd82d6f3c93948e598947c3e60c5ffbe">EFLAGS_PF</a> =  0x00000004, 
<br/>
&nbsp;&nbsp;<a class="el" href="dr__ir__instr_8h.html#adb49720dc49f7d4e4cf9adbf2948e409ae02f888626e1c77d3dadb0c69c4ccebe">EFLAGS_AF</a> =  0x00000010, 
<br/>
&nbsp;&nbsp;<a class="el" href="dr__ir__instr_8h.html#adb49720dc49f7d4e4cf9adbf2948e409aeb567fc9958d98e114e2aed3f73e6cf1">EFLAGS_ZF</a> =  0x00000040, 
<br/>
&nbsp;&nbsp;<a class="el" href="dr__ir__instr_8h.html#adb49720dc49f7d4e4cf9adbf2948e409a607506a5fd2d021972d2f7ecb397960f">EFLAGS_SF</a> =  0x00000080, 
<br/>
&nbsp;&nbsp;<a class="el" href="dr__ir__instr_8h.html#adb49720dc49f7d4e4cf9adbf2948e409ad3cf0d7affac2713bfcb915f809200da">EFLAGS_DF</a> =  0x00000400, 
<br/>
&nbsp;&nbsp;<a class="el" href="dr__ir__instr_8h.html#adb49720dc49f7d4e4cf9adbf2948e409ad4d56500271d500e241e46fdd7fdddb4">EFLAGS_OF</a> =  0x00000800
<br/>
 }</td></tr>
<tr><td colspan="2"><h2>Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structinstr__t.html">instr_t</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__instr_8h.html#a65f53f3c43c91833faf11b5e6cd9e905">instr_create</a> (void *drcontext)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__instr_8h.html#a77b55daa2b3780d2c07e33b8330b2f62">instr_init</a> (void *drcontext, <a class="el" href="structinstr__t.html">instr_t</a> *instr)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__instr_8h.html#ae0f3cc7fb91265cb6c8eb15a84184c1f">instr_free</a> (void *drcontext, <a class="el" href="structinstr__t.html">instr_t</a> *instr)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__instr_8h.html#accd2bdee07d2e6ca0be3b252bc7b913f">instr_reset</a> (void *drcontext, <a class="el" href="structinstr__t.html">instr_t</a> *instr)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__instr_8h.html#ab9b44a1db49dc5cd8da8b6b27fa47d50">instr_reuse</a> (void *drcontext, <a class="el" href="structinstr__t.html">instr_t</a> *instr)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__instr_8h.html#acb082bbf9ac73968667b79b4cd14d73f">instr_destroy</a> (void *drcontext, <a class="el" href="structinstr__t.html">instr_t</a> *instr)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structinstr__t.html">instr_t</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__instr_8h.html#a7e6028bd1058d4becc4e2d29c96fbaf5">instr_get_next</a> (<a class="el" href="structinstr__t.html">instr_t</a> *instr)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structinstr__t.html">instr_t</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__instr_8h.html#a4034f08d82d5f0d93f54691aefb75c82">instr_get_prev</a> (<a class="el" href="structinstr__t.html">instr_t</a> *instr)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__instr_8h.html#ab0528e8567588400c3941b38b77f05af">instr_set_next</a> (<a class="el" href="structinstr__t.html">instr_t</a> *instr, <a class="el" href="structinstr__t.html">instr_t</a> *next)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__instr_8h.html#a728084f128d0e98bb4f1a3e0e4089378">instr_set_prev</a> (<a class="el" href="structinstr__t.html">instr_t</a> *instr, <a class="el" href="structinstr__t.html">instr_t</a> *prev)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__instr_8h.html#ad5e7b4a1ecf29b3a311b684e8efc322a">instr_get_note</a> (<a class="el" href="structinstr__t.html">instr_t</a> *instr)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__instr_8h.html#aba91124bada4c62004f5837c0d52af83">instr_set_note</a> (<a class="el" href="structinstr__t.html">instr_t</a> *instr, void *value)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">app_pc&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__instr_8h.html#ab4c178ef16a57aa4c89976cb11419719">instr_get_branch_target_pc</a> (<a class="el" href="structinstr__t.html">instr_t</a> *cti_instr)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__instr_8h.html#a1429cf1d1da8156898fde712e59e86db">instr_set_branch_target_pc</a> (<a class="el" href="structinstr__t.html">instr_t</a> *cti_instr, app_pc pc)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__instr_8h.html#ad7abc869b82542e5ea0e564ec671b7cd">instr_is_exit_cti</a> (<a class="el" href="structinstr__t.html">instr_t</a> *instr)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__instr_8h.html#aa21d0c15479e3a0ee88a7ec06fe9eb22">instr_is_interrupt</a> (<a class="el" href="structinstr__t.html">instr_t</a> *instr)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__instr_8h.html#a7b0251c70b4ab2a46801eeb49f1b8fda">instr_ok_to_mangle</a> (<a class="el" href="structinstr__t.html">instr_t</a> *instr)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__instr_8h.html#a2335bd8d05936e8308506ef11f1be401">instr_set_ok_to_mangle</a> (<a class="el" href="structinstr__t.html">instr_t</a> *instr, bool val)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__instr_8h.html#a5206d055a5b06435bd5e919da40e8bd4">instr_set_meta_no_translation</a> (<a class="el" href="structinstr__t.html">instr_t</a> *instr)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__instr_8h.html#a221092e79cb7fd9a701c2e260685a6dc">instr_ok_to_emit</a> (<a class="el" href="structinstr__t.html">instr_t</a> *instr)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__instr_8h.html#ae34605a2cff286d358941be6aa91788d">instr_set_ok_to_emit</a> (<a class="el" href="structinstr__t.html">instr_t</a> *instr, bool val)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__instr_8h.html#ace0e57a48576a4aac25b1554f6ebcbf7">instr_length</a> (void *drcontext, <a class="el" href="structinstr__t.html">instr_t</a> *instr)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__instr_8h.html#a56419903595cc4bd2bb39f887a5275d5">instr_is_encoding_possible</a> (<a class="el" href="structinstr__t.html">instr_t</a> *instr)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">byte *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__instr_8h.html#a1cd4d0740eb0a0bcd2d387685719263c">instr_encode</a> (void *drcontext, <a class="el" href="structinstr__t.html">instr_t</a> *instr, byte *pc)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">byte *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__instr_8h.html#a5356c2dd3388496158fa0a918f8c2a53">instr_encode_to_copy</a> (void *drcontext, <a class="el" href="structinstr__t.html">instr_t</a> *instr, byte *copy_pc, byte *final_pc)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__instr_8h.html#af679a00bb888cbb46ae266a8591997ea">instr_mem_usage</a> (<a class="el" href="structinstr__t.html">instr_t</a> *instr)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structinstr__t.html">instr_t</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__instr_8h.html#af8c874bf0f8b67dd6a85f2d54c1e87dc">instr_clone</a> (void *drcontext, <a class="el" href="structinstr__t.html">instr_t</a> *orig)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structinstr__t.html">instr_t</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__instr_8h.html#a88ef462712287c564d125a71383a09c3">instr_build</a> (void *drcontext, int opcode, int num_dsts, int num_srcs)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structinstr__t.html">instr_t</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__instr_8h.html#a947d5940c5e43001ee44577a05d433f5">instr_build_bits</a> (void *drcontext, int opcode, uint num_bytes)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__instr_8h.html#a9890dc9d4dbc40589c974a0ff221db72">instr_valid</a> (<a class="el" href="structinstr__t.html">instr_t</a> *instr)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">app_pc&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__instr_8h.html#a57dbc129ab88dfdcf49f1105eba394a7">instr_get_app_pc</a> (<a class="el" href="structinstr__t.html">instr_t</a> *instr)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__instr_8h.html#a90d36984352b073089da3c91b901c853">instr_get_opcode</a> (<a class="el" href="structinstr__t.html">instr_t</a> *instr)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__instr_8h.html#a5e1efc53088af35fa0ed6eefd80af5dd">instr_set_opcode</a> (<a class="el" href="structinstr__t.html">instr_t</a> *instr, int opcode)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__instr_8h.html#acb4ed1d87d7852bce1995be6a940a9db">instr_num_srcs</a> (<a class="el" href="structinstr__t.html">instr_t</a> *instr)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__instr_8h.html#a40ea45c2072f0a3f0c521669723f56b8">instr_num_dsts</a> (<a class="el" href="structinstr__t.html">instr_t</a> *instr)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__instr_8h.html#aee0d80a8e69e8f0abe867f1903a107ea">instr_set_num_opnds</a> (void *drcontext, <a class="el" href="structinstr__t.html">instr_t</a> *instr, int num_dsts, int num_srcs)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structopnd__t.html">opnd_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__instr_8h.html#aa60219f08461b9bc143214c937893d98">instr_get_src</a> (<a class="el" href="structinstr__t.html">instr_t</a> *instr, uint pos)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structopnd__t.html">opnd_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__instr_8h.html#aed999847d48a5a9eb1032239a660e398">instr_get_dst</a> (<a class="el" href="structinstr__t.html">instr_t</a> *instr, uint pos)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__instr_8h.html#a96bfa15e2f3a95174e36c80c585a24e3">instr_set_src</a> (<a class="el" href="structinstr__t.html">instr_t</a> *instr, uint pos, <a class="el" href="structopnd__t.html">opnd_t</a> opnd)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__instr_8h.html#a8e843e39613655f6a5c49e081fe593c2">instr_set_dst</a> (<a class="el" href="structinstr__t.html">instr_t</a> *instr, uint pos, <a class="el" href="structopnd__t.html">opnd_t</a> opnd)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structopnd__t.html">opnd_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__instr_8h.html#a6ff26384b57a52838dbd9b854db44cb6">instr_get_target</a> (<a class="el" href="structinstr__t.html">instr_t</a> *cti_instr)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__instr_8h.html#adbf4b84b7a6b07e22af66b0aec7cacf5">instr_set_target</a> (<a class="el" href="structinstr__t.html">instr_t</a> *cti_instr, <a class="el" href="structopnd__t.html">opnd_t</a> target)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__instr_8h.html#a9c820f4c4b82638289cca3c40f1d15c0">instr_operands_valid</a> (<a class="el" href="structinstr__t.html">instr_t</a> *instr)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__instr_8h.html#ac8f4d5f068f69df848c0dd1cacebc90f">instr_set_operands_valid</a> (<a class="el" href="structinstr__t.html">instr_t</a> *instr, bool valid)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__instr_8h.html#afeaf6ea858ca81c8b9968e4be43749f6">instr_opcode_valid</a> (<a class="el" href="structinstr__t.html">instr_t</a> *instr)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">uint&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__instr_8h.html#af295aa1b99e3b1fb73562312fc547ce9">instr_get_eflags</a> (<a class="el" href="structinstr__t.html">instr_t</a> *instr)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">uint&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__instr_8h.html#a749df373b340acb6437fea2f02b2fe69">instr_get_opcode_eflags</a> (int opcode)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">uint&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__instr_8h.html#a23aa72462b20fa6349d2ca2289c0f9a3">instr_get_arith_flags</a> (<a class="el" href="structinstr__t.html">instr_t</a> *instr)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__instr_8h.html#a7b9c3a55529a9e5467851821fe53fdb2">instr_set_raw_bits</a> (<a class="el" href="structinstr__t.html">instr_t</a> *instr, byte *addr, uint length)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__instr_8h.html#a76b3326d827b06a1d1d0bc3d20ba17a2">instr_set_raw_bits_valid</a> (<a class="el" href="structinstr__t.html">instr_t</a> *instr, bool valid)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__instr_8h.html#af08de27201e4c64a655e309b47d096c4">instr_raw_bits_valid</a> (<a class="el" href="structinstr__t.html">instr_t</a> *instr)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__instr_8h.html#add5ea7e7d0387d7d1461830c1e5253c3">instr_has_allocated_bits</a> (<a class="el" href="structinstr__t.html">instr_t</a> *instr)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__instr_8h.html#adb8c87b75de66fe9fcdf3db864a08702">instr_needs_encoding</a> (<a class="el" href="structinstr__t.html">instr_t</a> *instr)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__instr_8h.html#a954715b40fa2668d7cde0c4a1bf47e51">instr_is_meta_may_fault</a> (<a class="el" href="structinstr__t.html">instr_t</a> *instr)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__instr_8h.html#a94227a193446d370f0180e6a844be0c2">instr_set_meta_may_fault</a> (<a class="el" href="structinstr__t.html">instr_t</a> *instr, bool val)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__instr_8h.html#af7b33f34d4dd11993224b4fb10e136dc">instr_allocate_raw_bits</a> (void *drcontext, <a class="el" href="structinstr__t.html">instr_t</a> *instr, uint num_bytes)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structinstr__t.html">instr_t</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__instr_8h.html#af1beda2d570ba04d74ca9cbd7c31bb1d">instr_set_translation</a> (<a class="el" href="structinstr__t.html">instr_t</a> *instr, app_pc addr)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__instr_8h.html#a8620fe9a0391247fcd9183e7cac291c3">instr_make_persistent</a> (void *drcontext, <a class="el" href="structinstr__t.html">instr_t</a> *instr)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">byte *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__instr_8h.html#a964928ee44090aba9aef343c5d34df5c">instr_get_raw_bits</a> (<a class="el" href="structinstr__t.html">instr_t</a> *instr)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__instr_8h.html#aa7af19aa3aadf7b05900a39ef62b01b9">instr_free_raw_bits</a> (void *drcontext, <a class="el" href="structinstr__t.html">instr_t</a> *instr)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">byte&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__instr_8h.html#af8d41e2a8da7c0ef207d269020053ecc">instr_get_raw_byte</a> (<a class="el" href="structinstr__t.html">instr_t</a> *instr, uint pos)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__instr_8h.html#ad11045a1b7b7cbd2053048f028e5e687">instr_set_raw_byte</a> (<a class="el" href="structinstr__t.html">instr_t</a> *instr, uint pos, byte byte)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__instr_8h.html#a71fba42e58fa08ed1e0da9be2fbde4d4">instr_set_raw_bytes</a> (<a class="el" href="structinstr__t.html">instr_t</a> *instr, byte *start, uint num_bytes)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__instr_8h.html#a22ea2d9c35a7b4fcf89e4d160314babb">instr_set_raw_word</a> (<a class="el" href="structinstr__t.html">instr_t</a> *instr, uint pos, uint word)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">uint&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__instr_8h.html#ae0d1b19bf4e736c6f361164a295160a6">instr_get_raw_word</a> (<a class="el" href="structinstr__t.html">instr_t</a> *instr, uint pos)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structinstr__t.html">instr_t</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__instr_8h.html#a3948b6ce886753002699286061faef26">instr_set_prefix_flag</a> (<a class="el" href="structinstr__t.html">instr_t</a> *instr, uint prefix)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__instr_8h.html#a3722cd7a5b3728b5edeefd4b07bd456c">instr_get_prefix_flag</a> (<a class="el" href="structinstr__t.html">instr_t</a> *instr, uint prefix)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__instr_8h.html#a74814111812ff20b281f7350fb626746">instr_set_x86_mode</a> (<a class="el" href="structinstr__t.html">instr_t</a> *instr, bool x86)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__instr_8h.html#acf3a5a5abd40c0c0694f037fcfac5705">instr_get_x86_mode</a> (<a class="el" href="structinstr__t.html">instr_t</a> *instr)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__instr_8h.html#a2dba2c8ede2bb35a708bd8dba95d5746">instr_shrink_to_16_bits</a> (<a class="el" href="structinstr__t.html">instr_t</a> *instr)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__instr_8h.html#ae0db1cec99a6fff7dde7201a87ca8892">instr_shrink_to_32_bits</a> (<a class="el" href="structinstr__t.html">instr_t</a> *instr)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__instr_8h.html#a15a3336a497835085cc0a7be3b010cf3">instr_uses_reg</a> (<a class="el" href="structinstr__t.html">instr_t</a> *instr, reg_id_t reg)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__instr_8h.html#a9b828bdfc3723d5b05d7147cfc237397">instr_uses_fp_reg</a> (<a class="el" href="structinstr__t.html">instr_t</a> *instr)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__instr_8h.html#ae1092dee2d8367ca2fec50cba5e632d0">instr_reg_in_src</a> (<a class="el" href="structinstr__t.html">instr_t</a> *instr, reg_id_t reg)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__instr_8h.html#a7e0752a69bd5b0331f8e98512ec15c2b">instr_reg_in_dst</a> (<a class="el" href="structinstr__t.html">instr_t</a> *instr, reg_id_t reg)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__instr_8h.html#a2b2d116d97b3cbb47895984077119cfa">instr_writes_to_reg</a> (<a class="el" href="structinstr__t.html">instr_t</a> *instr, reg_id_t reg)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__instr_8h.html#a5229b3775a4b2cdaa9aa257a27a0be1a">instr_reads_from_reg</a> (<a class="el" href="structinstr__t.html">instr_t</a> *instr, reg_id_t reg)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__instr_8h.html#a2d5a8131ed782adc6f31471417b88da9">instr_writes_to_exact_reg</a> (<a class="el" href="structinstr__t.html">instr_t</a> *instr, reg_id_t reg)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__instr_8h.html#a7ff0a9b43777e95bf6932260f4b5cc09">instr_replace_src_opnd</a> (<a class="el" href="structinstr__t.html">instr_t</a> *instr, <a class="el" href="structopnd__t.html">opnd_t</a> old_opnd, <a class="el" href="structopnd__t.html">opnd_t</a> new_opnd)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__instr_8h.html#a9e75c7fe47cb20acfae6bca1cd4bd2e0">instr_same</a> (<a class="el" href="structinstr__t.html">instr_t</a> *instr1, <a class="el" href="structinstr__t.html">instr_t</a> *instr2)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__instr_8h.html#ae408fe229bea0aa800cddb6b911c0e94">instr_reads_memory</a> (<a class="el" href="structinstr__t.html">instr_t</a> *instr)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__instr_8h.html#ae1aac8cef8bb6ab075238e38ad6888a9">instr_writes_memory</a> (<a class="el" href="structinstr__t.html">instr_t</a> *instr)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__instr_8h.html#a7c2b7bfe6c9670ac127a24ea7aef33d4">instr_has_rel_addr_reference</a> (<a class="el" href="structinstr__t.html">instr_t</a> *instr)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__instr_8h.html#a19b43ab8c3edd905329429075e91ea1a">instr_get_rel_addr_target</a> (<a class="el" href="structinstr__t.html">instr_t</a> *instr, app_pc *target)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__instr_8h.html#ae9e4c9cbe4890f8e37af9e299affc86c">instr_get_rel_addr_dst_idx</a> (<a class="el" href="structinstr__t.html">instr_t</a> *instr)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__instr_8h.html#a8942eef70af97b8018b31df431ef1822">instr_get_rel_addr_src_idx</a> (<a class="el" href="structinstr__t.html">instr_t</a> *instr)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">app_pc&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__instr_8h.html#aa13ec559a17ab70816f80de784e5632f">instr_compute_address</a> (<a class="el" href="structinstr__t.html">instr_t</a> *instr, <a class="el" href="struct__dr__mcontext__t.html">dr_mcontext_t</a> *mc)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__instr_8h.html#aa04322a189dd7f17ab245594e02cc6a8">instr_compute_address_ex</a> (<a class="el" href="structinstr__t.html">instr_t</a> *instr, <a class="el" href="struct__dr__mcontext__t.html">dr_mcontext_t</a> *mc, uint index, OUT app_pc *addr, OUT bool *write)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__instr_8h.html#a25107e1fb5a49de3c627b70acc7b2eef">instr_compute_address_ex_pos</a> (<a class="el" href="structinstr__t.html">instr_t</a> *instr, <a class="el" href="struct__dr__mcontext__t.html">dr_mcontext_t</a> *mc, uint index, OUT app_pc *addr, OUT bool *is_write, OUT uint *pos)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">uint&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__instr_8h.html#a67563b7baa993aa824ba1803562fc029">instr_memory_reference_size</a> (<a class="el" href="structinstr__t.html">instr_t</a> *instr)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct__dr__instr__label__data__t.html">dr_instr_label_data_t</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__instr_8h.html#a7eab5eaa85e186349d200a87e8010fec">instr_get_label_data_area</a> (<a class="el" href="structinstr__t.html">instr_t</a> *instr)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__instr_8h.html#a8b39dade5681d6135379a5d53fe57512">instr_is_mov</a> (<a class="el" href="structinstr__t.html">instr_t</a> *instr)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__instr_8h.html#a9d347723617986e9424b042cb69495e5">instr_is_call</a> (<a class="el" href="structinstr__t.html">instr_t</a> *instr)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__instr_8h.html#a5cb0fc26f65991c24002df14abb7e461">instr_is_call_direct</a> (<a class="el" href="structinstr__t.html">instr_t</a> *instr)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__instr_8h.html#a1fe1cc575e2870720ceee8ce134771f3">instr_is_call_indirect</a> (<a class="el" href="structinstr__t.html">instr_t</a> *instr)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__instr_8h.html#ade184d50e1016f220a10f40a60a4f8ad">instr_is_return</a> (<a class="el" href="structinstr__t.html">instr_t</a> *instr)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__instr_8h.html#a076d0445255d4902181cb272bacd80aa">instr_is_cti</a> (<a class="el" href="structinstr__t.html">instr_t</a> *instr)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__instr_8h.html#a2782471943558d57296b89a3f41a530d">instr_is_cti_short</a> (<a class="el" href="structinstr__t.html">instr_t</a> *instr)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__instr_8h.html#a4af759611c486c5ac9e1a5336a809661">instr_is_cti_loop</a> (<a class="el" href="structinstr__t.html">instr_t</a> *instr)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__instr_8h.html#a8c61714f2632d46211d61ebb55d4bbde">instr_is_cti_short_rewrite</a> (<a class="el" href="structinstr__t.html">instr_t</a> *instr, byte *pc)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__instr_8h.html#a006c261a813d4e91fc25c549e5ebbb8d">instr_is_cbr</a> (<a class="el" href="structinstr__t.html">instr_t</a> *instr)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__instr_8h.html#a963ac2677038071fc295b3b6eb45ce1d">instr_is_mbr</a> (<a class="el" href="structinstr__t.html">instr_t</a> *instr)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__instr_8h.html#ac39c368adab3332628a34c1f48afc466">instr_is_ubr</a> (<a class="el" href="structinstr__t.html">instr_t</a> *instr)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__instr_8h.html#a45ee0433816dfcfbe8ca41988d757aee">instr_is_far_cti</a> (<a class="el" href="structinstr__t.html">instr_t</a> *instr)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__instr_8h.html#ac83165c08bdab6b1bf0933bccba7d557">instr_is_far_abs_cti</a> (<a class="el" href="structinstr__t.html">instr_t</a> *instr)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__instr_8h.html#a86d982227aea8aa8647694b35cc592b3">instr_is_syscall</a> (<a class="el" href="structinstr__t.html">instr_t</a> *instr)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__instr_8h.html#a4a4d5454f266483029bd88e5a17e398c">instr_is_wow64_syscall</a> (<a class="el" href="structinstr__t.html">instr_t</a> *instr)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__instr_8h.html#aa653a23cf2029fc4eeaf05eb7523849d">instr_is_prefetch</a> (<a class="el" href="structinstr__t.html">instr_t</a> *instr)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__instr_8h.html#ac8da7990fa33f321134102323546516b">instr_is_mov_constant</a> (<a class="el" href="structinstr__t.html">instr_t</a> *instr, ptr_int_t *value)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__instr_8h.html#a81cdb64c78235caf707130680d1f156d">instr_is_floating</a> (<a class="el" href="structinstr__t.html">instr_t</a> *instr)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__instr_8h.html#a5e297cd513cbde904d0e09b721f1e9c1">instr_is_mmx</a> (<a class="el" href="structinstr__t.html">instr_t</a> *instr)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__instr_8h.html#a33bb11334437a3076fbb81c0493f6e7a">instr_is_sse_or_sse2</a> (<a class="el" href="structinstr__t.html">instr_t</a> *instr)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__instr_8h.html#a1cf18b53c422fdb11efe7bdcc596aea2">instr_is_mov_imm_to_tos</a> (<a class="el" href="structinstr__t.html">instr_t</a> *instr)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__instr_8h.html#ae61355d1ac416d4f04ed286eebc7c251">instr_is_label</a> (<a class="el" href="structinstr__t.html">instr_t</a> *instr)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__instr_8h.html#a465cc4935f184c4d224afbb9547a445c">instr_is_undefined</a> (<a class="el" href="structinstr__t.html">instr_t</a> *instr)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__instr_8h.html#a784fcd66cdda36aaf218121f1b75ab2d">instr_get_interrupt_number</a> (<a class="el" href="structinstr__t.html">instr_t</a> *instr)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__instr_8h.html#acc25aa34b90fcf0cdcfdbd8028464274">instr_invert_cbr</a> (<a class="el" href="structinstr__t.html">instr_t</a> *instr)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structinstr__t.html">instr_t</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__instr_8h.html#a33a349e086f96bb03bd6700129dc6135">instr_convert_short_meta_jmp_to_long</a> (void *drcontext, instrlist_t *ilist, <a class="el" href="structinstr__t.html">instr_t</a> *instr)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__instr_8h.html#a79a9b2a0b21a18dbfd0a7a534204b92b">instr_jcc_taken</a> (<a class="el" href="structinstr__t.html">instr_t</a> *instr, reg_t eflags)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__instr_8h.html#a222195624605490e7844ed3737ad3668">instr_cmovcc_to_jcc</a> (int cmovcc_opcode)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__instr_8h.html#a238dc0a1168701e30a95b57dd0c845a0">instr_cmovcc_triggered</a> (<a class="el" href="structinstr__t.html">instr_t</a> *instr, reg_t eflags)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__instr_8h.html#acb2c91a7868ad6a8e5c47af985edde61">instr_is_nop</a> (<a class="el" href="structinstr__t.html">instr_t</a> *instr)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structinstr__t.html">instr_t</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__instr_8h.html#ac00a75c880108dde16b137370be5cedb">instr_create_0dst_0src</a> (void *drcontext, int opcode)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structinstr__t.html">instr_t</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__instr_8h.html#ad3835ac2d78ba9b90e1ced9c58cada5e">instr_create_0dst_1src</a> (void *drcontext, int opcode, <a class="el" href="structopnd__t.html">opnd_t</a> src)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structinstr__t.html">instr_t</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__instr_8h.html#a54d0c2cbad95bfe24daade84c6add8af">instr_create_0dst_2src</a> (void *drcontext, int opcode, <a class="el" href="structopnd__t.html">opnd_t</a> src1, <a class="el" href="structopnd__t.html">opnd_t</a> src2)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structinstr__t.html">instr_t</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__instr_8h.html#a21033066f65f8dfd23ca24215ea99b70">instr_create_0dst_3src</a> (void *drcontext, int opcode, <a class="el" href="structopnd__t.html">opnd_t</a> src1, <a class="el" href="structopnd__t.html">opnd_t</a> src2, <a class="el" href="structopnd__t.html">opnd_t</a> src3)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structinstr__t.html">instr_t</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__instr_8h.html#a4db9f5f8dfd216fab6e9153170fb479f">instr_create_1dst_0src</a> (void *drcontext, int opcode, <a class="el" href="structopnd__t.html">opnd_t</a> dst)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structinstr__t.html">instr_t</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__instr_8h.html#a0202b3cf63b50d16947f6be6f2b00891">instr_create_1dst_1src</a> (void *drcontext, int opcode, <a class="el" href="structopnd__t.html">opnd_t</a> dst, <a class="el" href="structopnd__t.html">opnd_t</a> src)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structinstr__t.html">instr_t</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__instr_8h.html#ac469b18246e67b23f758c636f460d8ac">instr_create_1dst_2src</a> (void *drcontext, int opcode, <a class="el" href="structopnd__t.html">opnd_t</a> dst, <a class="el" href="structopnd__t.html">opnd_t</a> src1, <a class="el" href="structopnd__t.html">opnd_t</a> src2)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structinstr__t.html">instr_t</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__instr_8h.html#a4a34019f73e797090b3ab9625cdbc5fc">instr_create_1dst_3src</a> (void *drcontext, int opcode, <a class="el" href="structopnd__t.html">opnd_t</a> dst, <a class="el" href="structopnd__t.html">opnd_t</a> src1, <a class="el" href="structopnd__t.html">opnd_t</a> src2, <a class="el" href="structopnd__t.html">opnd_t</a> src3)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structinstr__t.html">instr_t</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__instr_8h.html#a4e5a5241276ad8d2f392c7a1432efb61">instr_create_1dst_5src</a> (void *drcontext, int opcode, <a class="el" href="structopnd__t.html">opnd_t</a> dst, <a class="el" href="structopnd__t.html">opnd_t</a> src1, <a class="el" href="structopnd__t.html">opnd_t</a> src2, <a class="el" href="structopnd__t.html">opnd_t</a> src3, <a class="el" href="structopnd__t.html">opnd_t</a> src4, <a class="el" href="structopnd__t.html">opnd_t</a> src5)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structinstr__t.html">instr_t</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__instr_8h.html#aeadd422dcd43564d40b43ca0e03b6910">instr_create_2dst_0src</a> (void *drcontext, int opcode, <a class="el" href="structopnd__t.html">opnd_t</a> dst1, <a class="el" href="structopnd__t.html">opnd_t</a> dst2)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structinstr__t.html">instr_t</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__instr_8h.html#ae6d0c6211ec93379e4ad6dc520506111">instr_create_2dst_1src</a> (void *drcontext, int opcode, <a class="el" href="structopnd__t.html">opnd_t</a> dst1, <a class="el" href="structopnd__t.html">opnd_t</a> dst2, <a class="el" href="structopnd__t.html">opnd_t</a> src)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structinstr__t.html">instr_t</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__instr_8h.html#a3c614653cadce1e2e6e567f3f68de6a8">instr_create_2dst_2src</a> (void *drcontext, int opcode, <a class="el" href="structopnd__t.html">opnd_t</a> dst1, <a class="el" href="structopnd__t.html">opnd_t</a> dst2, <a class="el" href="structopnd__t.html">opnd_t</a> src1, <a class="el" href="structopnd__t.html">opnd_t</a> src2)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structinstr__t.html">instr_t</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__instr_8h.html#a711cac2989e3f2fa8fa702ce3b7f8ced">instr_create_2dst_3src</a> (void *drcontext, int opcode, <a class="el" href="structopnd__t.html">opnd_t</a> dst1, <a class="el" href="structopnd__t.html">opnd_t</a> dst2, <a class="el" href="structopnd__t.html">opnd_t</a> src1, <a class="el" href="structopnd__t.html">opnd_t</a> src2, <a class="el" href="structopnd__t.html">opnd_t</a> src3)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structinstr__t.html">instr_t</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__instr_8h.html#a608e02e275eb868cd09ba8c454d78b5d">instr_create_2dst_4src</a> (void *drcontext, int opcode, <a class="el" href="structopnd__t.html">opnd_t</a> dst1, <a class="el" href="structopnd__t.html">opnd_t</a> dst2, <a class="el" href="structopnd__t.html">opnd_t</a> src1, <a class="el" href="structopnd__t.html">opnd_t</a> src2, <a class="el" href="structopnd__t.html">opnd_t</a> src3, <a class="el" href="structopnd__t.html">opnd_t</a> src4)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structinstr__t.html">instr_t</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__instr_8h.html#a678839fc8b937d70b63be5fcbbb2d014">instr_create_3dst_0src</a> (void *drcontext, int opcode, <a class="el" href="structopnd__t.html">opnd_t</a> dst1, <a class="el" href="structopnd__t.html">opnd_t</a> dst2, <a class="el" href="structopnd__t.html">opnd_t</a> dst3)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structinstr__t.html">instr_t</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__instr_8h.html#ae5f963b19ebe6ff70c0ea8174b53d9ed">instr_create_3dst_3src</a> (void *drcontext, int opcode, <a class="el" href="structopnd__t.html">opnd_t</a> dst1, <a class="el" href="structopnd__t.html">opnd_t</a> dst2, <a class="el" href="structopnd__t.html">opnd_t</a> dst3, <a class="el" href="structopnd__t.html">opnd_t</a> src1, <a class="el" href="structopnd__t.html">opnd_t</a> src2, <a class="el" href="structopnd__t.html">opnd_t</a> src3)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structinstr__t.html">instr_t</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__instr_8h.html#a32078373abe0c5fb3f97774a936569d9">instr_create_3dst_4src</a> (void *drcontext, int opcode, <a class="el" href="structopnd__t.html">opnd_t</a> dst1, <a class="el" href="structopnd__t.html">opnd_t</a> dst2, <a class="el" href="structopnd__t.html">opnd_t</a> dst3, <a class="el" href="structopnd__t.html">opnd_t</a> src1, <a class="el" href="structopnd__t.html">opnd_t</a> src2, <a class="el" href="structopnd__t.html">opnd_t</a> src3, <a class="el" href="structopnd__t.html">opnd_t</a> src4)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structinstr__t.html">instr_t</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__instr_8h.html#aee21bbcad5d7ee35f8828ed5244132fd">instr_create_3dst_5src</a> (void *drcontext, int opcode, <a class="el" href="structopnd__t.html">opnd_t</a> dst1, <a class="el" href="structopnd__t.html">opnd_t</a> dst2, <a class="el" href="structopnd__t.html">opnd_t</a> dst3, <a class="el" href="structopnd__t.html">opnd_t</a> src1, <a class="el" href="structopnd__t.html">opnd_t</a> src2, <a class="el" href="structopnd__t.html">opnd_t</a> src3, <a class="el" href="structopnd__t.html">opnd_t</a> src4, <a class="el" href="structopnd__t.html">opnd_t</a> src5)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structinstr__t.html">instr_t</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__instr_8h.html#ab8b00a25f7ec49fbf943df0e9c667136">instr_create_4dst_1src</a> (void *drcontext, int opcode, <a class="el" href="structopnd__t.html">opnd_t</a> dst1, <a class="el" href="structopnd__t.html">opnd_t</a> dst2, <a class="el" href="structopnd__t.html">opnd_t</a> dst3, <a class="el" href="structopnd__t.html">opnd_t</a> dst4, <a class="el" href="structopnd__t.html">opnd_t</a> src)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structinstr__t.html">instr_t</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__instr_8h.html#abd02600b967d24951bc7208b6d70d459">instr_create_4dst_4src</a> (void *drcontext, int opcode, <a class="el" href="structopnd__t.html">opnd_t</a> dst1, <a class="el" href="structopnd__t.html">opnd_t</a> dst2, <a class="el" href="structopnd__t.html">opnd_t</a> dst3, <a class="el" href="structopnd__t.html">opnd_t</a> dst4, <a class="el" href="structopnd__t.html">opnd_t</a> src1, <a class="el" href="structopnd__t.html">opnd_t</a> src2, <a class="el" href="structopnd__t.html">opnd_t</a> src3, <a class="el" href="structopnd__t.html">opnd_t</a> src4)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structinstr__t.html">instr_t</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__instr_8h.html#aa554f82d7fa8abd4f38dba90544c20ae">instr_create_popa</a> (void *drcontext)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structinstr__t.html">instr_t</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__instr_8h.html#a418865307bd5bd168cbde4ecd0f785a5">instr_create_pusha</a> (void *drcontext)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__instr_8h.html#a6baf5239817b639791916f3cbd6c7b9d">instr_disassemble</a> (void *drcontext, <a class="el" href="structinstr__t.html">instr_t</a> *instr, file_t outfile)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">size_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__instr_8h.html#af67ded4a34cef770ecc35e24e61813c8">instr_disassemble_to_buffer</a> (void *drcontext, <a class="el" href="structinstr__t.html">instr_t</a> *instr, char *buf, size_t bufsz)</td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<p>Functions to create and manipulate instructions. </p>
<hr/><h2>Define Documentation</h2>
<a class="anchor" id="ad61b67b227ebe0012829621c25ca65f5"></a><!-- doxytag: member="dr_ir_instr.h::EFLAGS_READ_6" ref="ad61b67b227ebe0012829621c25ca65f5" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define EFLAGS_READ_6&nbsp;&nbsp;&nbsp;0x0000011f</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Reads all 6 arithmetic flags (CF, PF, AF, ZF, SF, OF). </p>

</div>
</div>
<a class="anchor" id="a43c54ddcc858950e361725de7bc870d6"></a><!-- doxytag: member="dr_ir_instr.h::EFLAGS_READ_AF" ref="a43c54ddcc858950e361725de7bc870d6" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define EFLAGS_READ_AF&nbsp;&nbsp;&nbsp;0x00000004</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Reads AF (Auxiliary Carry Flag). </p>

</div>
</div>
<a class="anchor" id="a88d4ed7d7b9c544c09c395872a86c0ea"></a><!-- doxytag: member="dr_ir_instr.h::EFLAGS_READ_ALL" ref="a88d4ed7d7b9c544c09c395872a86c0ea" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define EFLAGS_READ_ALL&nbsp;&nbsp;&nbsp;0x000007ff</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Reads all flags. </p>

</div>
</div>
<a class="anchor" id="add002513aebf166b7fdae13d22828d8d"></a><!-- doxytag: member="dr_ir_instr.h::EFLAGS_READ_CF" ref="add002513aebf166b7fdae13d22828d8d" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define EFLAGS_READ_CF&nbsp;&nbsp;&nbsp;0x00000001</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Reads CF (Carry Flag). </p>

</div>
</div>
<a class="anchor" id="a241f4fe5f01af11fe8e9489fcf84ab4a"></a><!-- doxytag: member="dr_ir_instr.h::EFLAGS_READ_DF" ref="a241f4fe5f01af11fe8e9489fcf84ab4a" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define EFLAGS_READ_DF&nbsp;&nbsp;&nbsp;0x00000080</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Reads DF (Direction Flag). </p>

</div>
</div>
<a class="anchor" id="a5a57b4b5098e1ff53bb8a990eec54a14"></a><!-- doxytag: member="dr_ir_instr.h::EFLAGS_READ_IF" ref="a5a57b4b5098e1ff53bb8a990eec54a14" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define EFLAGS_READ_IF&nbsp;&nbsp;&nbsp;0x00000040</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Reads IF (Interrupt Enable Flag). </p>

</div>
</div>
<a class="anchor" id="ab70baddbcff9ed31c328376956f7b0ea"></a><!-- doxytag: member="dr_ir_instr.h::EFLAGS_READ_NT" ref="ab70baddbcff9ed31c328376956f7b0ea" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define EFLAGS_READ_NT&nbsp;&nbsp;&nbsp;0x00000200</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Reads NT (Nested Task). </p>

</div>
</div>
<a class="anchor" id="a5b5f953da018e1530879109cb78095b0"></a><!-- doxytag: member="dr_ir_instr.h::EFLAGS_READ_OF" ref="a5b5f953da018e1530879109cb78095b0" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define EFLAGS_READ_OF&nbsp;&nbsp;&nbsp;0x00000100</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Reads OF (Overflow Flag). </p>

</div>
</div>
<a class="anchor" id="afa533378650b8a86c903410a8abe5789"></a><!-- doxytag: member="dr_ir_instr.h::EFLAGS_READ_PF" ref="afa533378650b8a86c903410a8abe5789" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define EFLAGS_READ_PF&nbsp;&nbsp;&nbsp;0x00000002</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Reads PF (Parity Flag). </p>

</div>
</div>
<a class="anchor" id="a14e4b47d88d4014fedaed25482d39b34"></a><!-- doxytag: member="dr_ir_instr.h::EFLAGS_READ_RF" ref="a14e4b47d88d4014fedaed25482d39b34" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define EFLAGS_READ_RF&nbsp;&nbsp;&nbsp;0x00000400</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Reads RF (Resume Flag). </p>

</div>
</div>
<a class="anchor" id="ae9e0eb52c091f04e29148ca5e7ae2199"></a><!-- doxytag: member="dr_ir_instr.h::EFLAGS_READ_SF" ref="ae9e0eb52c091f04e29148ca5e7ae2199" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define EFLAGS_READ_SF&nbsp;&nbsp;&nbsp;0x00000010</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Reads SF (Sign Flag). </p>

</div>
</div>
<a class="anchor" id="aebf7d3cf0c4e6b2f39c3a07533419837"></a><!-- doxytag: member="dr_ir_instr.h::EFLAGS_READ_TF" ref="aebf7d3cf0c4e6b2f39c3a07533419837" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define EFLAGS_READ_TF&nbsp;&nbsp;&nbsp;0x00000020</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Reads TF (Trap Flag). </p>

</div>
</div>
<a class="anchor" id="afbe5d20458bd272fdeac681706c4bd14"></a><!-- doxytag: member="dr_ir_instr.h::EFLAGS_READ_TO_WRITE" ref="afbe5d20458bd272fdeac681706c4bd14" args="(x)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define EFLAGS_READ_TO_WRITE</td>
          <td>(</td>
          <td class="paramtype">x&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td>&nbsp;&nbsp;&nbsp;((x) &lt;&lt; 11)</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Converts an EFLAGS_READ_* value to the corresponding EFLAGS_WRITE_* value. </p>

</div>
</div>
<a class="anchor" id="a8385b4d8340260aad30cf5b8455a4efd"></a><!-- doxytag: member="dr_ir_instr.h::EFLAGS_READ_ZF" ref="a8385b4d8340260aad30cf5b8455a4efd" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define EFLAGS_READ_ZF&nbsp;&nbsp;&nbsp;0x00000008</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Reads ZF (Zero Flag). </p>

</div>
</div>
<a class="anchor" id="a8287fcf9cd6cd2338a57c54e45b08a7f"></a><!-- doxytag: member="dr_ir_instr.h::EFLAGS_WRITE_6" ref="a8287fcf9cd6cd2338a57c54e45b08a7f" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define EFLAGS_WRITE_6&nbsp;&nbsp;&nbsp;0x0008f800</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Writes all 6 arithmetic flags (CF, PF, AF, ZF, SF, OF). </p>

</div>
</div>
<a class="anchor" id="a9e0d29af655c408ddc915cc07c8ac95e"></a><!-- doxytag: member="dr_ir_instr.h::EFLAGS_WRITE_AF" ref="a9e0d29af655c408ddc915cc07c8ac95e" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define EFLAGS_WRITE_AF&nbsp;&nbsp;&nbsp;0x00002000</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Writes AF (Auxiliary Carry Flag). </p>

</div>
</div>
<a class="anchor" id="ab5727b7a5773bace9d656e4b969d7fce"></a><!-- doxytag: member="dr_ir_instr.h::EFLAGS_WRITE_ALL" ref="ab5727b7a5773bace9d656e4b969d7fce" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define EFLAGS_WRITE_ALL&nbsp;&nbsp;&nbsp;0x003ff800</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Writes all flags. </p>

</div>
</div>
<a class="anchor" id="afafb04c014284b3c4b51b0c6d17be085"></a><!-- doxytag: member="dr_ir_instr.h::EFLAGS_WRITE_CF" ref="afafb04c014284b3c4b51b0c6d17be085" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define EFLAGS_WRITE_CF&nbsp;&nbsp;&nbsp;0x00000800</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Writes CF (Carry Flag). </p>

</div>
</div>
<a class="anchor" id="abb180e5ea86b98e6bbd65708e202e6f1"></a><!-- doxytag: member="dr_ir_instr.h::EFLAGS_WRITE_DF" ref="abb180e5ea86b98e6bbd65708e202e6f1" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define EFLAGS_WRITE_DF&nbsp;&nbsp;&nbsp;0x00040000</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Writes DF (Direction Flag). </p>

</div>
</div>
<a class="anchor" id="ab61834da87126c5c1b3b5b89a1bb254e"></a><!-- doxytag: member="dr_ir_instr.h::EFLAGS_WRITE_IF" ref="ab61834da87126c5c1b3b5b89a1bb254e" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define EFLAGS_WRITE_IF&nbsp;&nbsp;&nbsp;0x00020000</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Writes IF (Interrupt Enable Flag). </p>

</div>
</div>
<a class="anchor" id="a533d9a5cd836be7bd8f831256b9d407e"></a><!-- doxytag: member="dr_ir_instr.h::EFLAGS_WRITE_NT" ref="a533d9a5cd836be7bd8f831256b9d407e" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define EFLAGS_WRITE_NT&nbsp;&nbsp;&nbsp;0x00100000</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Writes NT (Nested Task). </p>

</div>
</div>
<a class="anchor" id="a3d8edc641bb696aceadb34b6d5179761"></a><!-- doxytag: member="dr_ir_instr.h::EFLAGS_WRITE_OF" ref="a3d8edc641bb696aceadb34b6d5179761" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define EFLAGS_WRITE_OF&nbsp;&nbsp;&nbsp;0x00080000</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Writes OF (Overflow Flag). </p>

</div>
</div>
<a class="anchor" id="a302bd46f54cf696a1039c5d25f68bd02"></a><!-- doxytag: member="dr_ir_instr.h::EFLAGS_WRITE_PF" ref="a302bd46f54cf696a1039c5d25f68bd02" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define EFLAGS_WRITE_PF&nbsp;&nbsp;&nbsp;0x00001000</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Writes PF (Parity Flag). </p>

</div>
</div>
<a class="anchor" id="a1ad8fd64cd98ac35c20265b54de97cf2"></a><!-- doxytag: member="dr_ir_instr.h::EFLAGS_WRITE_RF" ref="a1ad8fd64cd98ac35c20265b54de97cf2" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define EFLAGS_WRITE_RF&nbsp;&nbsp;&nbsp;0x00200000</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Writes RF (Resume Flag). </p>

</div>
</div>
<a class="anchor" id="a6b5ddab727f9e2c9d49f20bcfd07807b"></a><!-- doxytag: member="dr_ir_instr.h::EFLAGS_WRITE_SF" ref="a6b5ddab727f9e2c9d49f20bcfd07807b" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define EFLAGS_WRITE_SF&nbsp;&nbsp;&nbsp;0x00008000</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Writes SF (Sign Flag). </p>

</div>
</div>
<a class="anchor" id="aac1ee8f92225d554aba043211c34e18b"></a><!-- doxytag: member="dr_ir_instr.h::EFLAGS_WRITE_TF" ref="aac1ee8f92225d554aba043211c34e18b" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define EFLAGS_WRITE_TF&nbsp;&nbsp;&nbsp;0x00010000</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Writes TF (Trap Flag). </p>

</div>
</div>
<a class="anchor" id="a2f1cca9ca8d0514a42f66c081f478231"></a><!-- doxytag: member="dr_ir_instr.h::EFLAGS_WRITE_TO_READ" ref="a2f1cca9ca8d0514a42f66c081f478231" args="(x)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define EFLAGS_WRITE_TO_READ</td>
          <td>(</td>
          <td class="paramtype">x&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td>&nbsp;&nbsp;&nbsp;((x) &gt;&gt; 11)</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Converts an EFLAGS_WRITE_* value to the corresponding EFLAGS_READ_* value. </p>

</div>
</div>
<a class="anchor" id="a5329db528d9d749deae463b9b8edd736"></a><!-- doxytag: member="dr_ir_instr.h::EFLAGS_WRITE_ZF" ref="a5329db528d9d749deae463b9b8edd736" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define EFLAGS_WRITE_ZF&nbsp;&nbsp;&nbsp;0x00004000</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Writes ZF (Zero Flag). </p>

</div>
</div>
<a class="anchor" id="a0e6a144b4030140faa950fe65fe9002d"></a><!-- doxytag: member="dr_ir_instr.h::PREFIX_JCC_NOT_TAKEN" ref="a0e6a144b4030140faa950fe65fe9002d" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define PREFIX_JCC_NOT_TAKEN&nbsp;&nbsp;&nbsp;0x2</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Branch hint: conditional branch is taken. </p>

</div>
</div>
<a class="anchor" id="a327356db32ce7a884e9a516b2d91b738"></a><!-- doxytag: member="dr_ir_instr.h::PREFIX_JCC_TAKEN" ref="a327356db32ce7a884e9a516b2d91b738" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define PREFIX_JCC_TAKEN&nbsp;&nbsp;&nbsp;0x4</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Branch hint: conditional branch is not taken. </p>

</div>
</div>
<a class="anchor" id="a697ecea613b828838ff6f08b88adf1d2"></a><!-- doxytag: member="dr_ir_instr.h::PREFIX_LOCK" ref="a697ecea613b828838ff6f08b88adf1d2" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define PREFIX_LOCK&nbsp;&nbsp;&nbsp;0x1</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Makes the instruction's memory accesses atomic. </p>

</div>
</div>
<hr/><h2>Typedef Documentation</h2>
<a class="anchor" id="af29c184442681322a7a77ab2a48ba889"></a><!-- doxytag: member="dr_ir_instr.h::dr_instr_label_data_t" ref="af29c184442681322a7a77ab2a48ba889" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="struct__dr__instr__label__data__t.html">_dr_instr_label_data_t</a>  <a class="el" href="struct__dr__instr__label__data__t.html">dr_instr_label_data_t</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Data slots available in a label (instr_create_label()) instruction for storing client-controlled data. Accessible via <a class="el" href="dr__ir__instr_8h.html#a7eab5eaa85e186349d200a87e8010fec">instr_get_label_data_area()</a>. </p>

</div>
</div>
<hr/><h2>Enumeration Type Documentation</h2>
<a class="anchor" id="adb49720dc49f7d4e4cf9adbf2948e409"></a><!-- doxytag: member="dr_ir_instr.h::@20" ref="adb49720dc49f7d4e4cf9adbf2948e409" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">anonymous enum</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>The actual bits in the eflags register that we care about:<br/>
</p>
<pre>
   11 10  9  8  7  6  5  4  3  2  1  0
   OF DF       SF ZF    AF    PF    CF  </pre> <dl><dt><b>Enumerator: </b></dt><dd><table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" id="adb49720dc49f7d4e4cf9adbf2948e409aef9a85103f89f1abdcbc577177fe59dc"></a><!-- doxytag: member="EFLAGS_CF" ref="adb49720dc49f7d4e4cf9adbf2948e409aef9a85103f89f1abdcbc577177fe59dc" args="" -->EFLAGS_CF</em>&nbsp;</td><td>
<p>The bit in the eflags register of CF (Carry Flag). </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="adb49720dc49f7d4e4cf9adbf2948e409abd82d6f3c93948e598947c3e60c5ffbe"></a><!-- doxytag: member="EFLAGS_PF" ref="adb49720dc49f7d4e4cf9adbf2948e409abd82d6f3c93948e598947c3e60c5ffbe" args="" -->EFLAGS_PF</em>&nbsp;</td><td>
<p>The bit in the eflags register of PF (Parity Flag). </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="adb49720dc49f7d4e4cf9adbf2948e409ae02f888626e1c77d3dadb0c69c4ccebe"></a><!-- doxytag: member="EFLAGS_AF" ref="adb49720dc49f7d4e4cf9adbf2948e409ae02f888626e1c77d3dadb0c69c4ccebe" args="" -->EFLAGS_AF</em>&nbsp;</td><td>
<p>The bit in the eflags register of AF (Aux Carry Flag). </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="adb49720dc49f7d4e4cf9adbf2948e409aeb567fc9958d98e114e2aed3f73e6cf1"></a><!-- doxytag: member="EFLAGS_ZF" ref="adb49720dc49f7d4e4cf9adbf2948e409aeb567fc9958d98e114e2aed3f73e6cf1" args="" -->EFLAGS_ZF</em>&nbsp;</td><td>
<p>The bit in the eflags register of ZF (Zero Flag). </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="adb49720dc49f7d4e4cf9adbf2948e409a607506a5fd2d021972d2f7ecb397960f"></a><!-- doxytag: member="EFLAGS_SF" ref="adb49720dc49f7d4e4cf9adbf2948e409a607506a5fd2d021972d2f7ecb397960f" args="" -->EFLAGS_SF</em>&nbsp;</td><td>
<p>The bit in the eflags register of SF (Sign Flag). </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="adb49720dc49f7d4e4cf9adbf2948e409ad3cf0d7affac2713bfcb915f809200da"></a><!-- doxytag: member="EFLAGS_DF" ref="adb49720dc49f7d4e4cf9adbf2948e409ad3cf0d7affac2713bfcb915f809200da" args="" -->EFLAGS_DF</em>&nbsp;</td><td>
<p>The bit in the eflags register of DF (Direction Flag). </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="adb49720dc49f7d4e4cf9adbf2948e409ad4d56500271d500e241e46fdd7fdddb4"></a><!-- doxytag: member="EFLAGS_OF" ref="adb49720dc49f7d4e4cf9adbf2948e409ad4d56500271d500e241e46fdd7fdddb4" args="" -->EFLAGS_OF</em>&nbsp;</td><td>
<p>The bit in the eflags register of OF (Overflow Flag). </p>
</td></tr>
</table>
</dd>
</dl>

</div>
</div>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="af7b33f34d4dd11993224b4fb10e136dc"></a><!-- doxytag: member="dr_ir_instr.h::instr_allocate_raw_bits" ref="af7b33f34d4dd11993224b4fb10e136dc" args="(void *drcontext, instr_t *instr, uint num_bytes)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void instr_allocate_raw_bits </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>drcontext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structinstr__t.html">instr_t</a> *&nbsp;</td>
          <td class="paramname"> <em>instr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&nbsp;</td>
          <td class="paramname"> <em>num_bytes</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Allocates <code>num_bytes</code> of memory for <code>instr's</code> raw bits. If <code>instr</code> currently points to raw bits, the allocated memory is initialized with the bytes pointed to. <code>instr</code> is then set to point to the allocated memory. </p>

</div>
</div>
<a class="anchor" id="a88ef462712287c564d125a71383a09c3"></a><!-- doxytag: member="dr_ir_instr.h::instr_build" ref="a88ef462712287c564d125a71383a09c3" args="(void *drcontext, int opcode, int num_dsts, int num_srcs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structinstr__t.html">instr_t</a>* instr_build </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>drcontext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>opcode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>num_dsts</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>num_srcs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Convenience routine: calls</p>
<ul>
<li>instr_create(dcontext)</li>
<li>instr_set_opcode(opcode)</li>
<li>instr_set_num_opnds(dcontext, instr, num_dsts, num_srcs)</li>
</ul>
<p>and returns the resulting <a class="el" href="structinstr__t.html">instr_t</a>. </p>

</div>
</div>
<a class="anchor" id="a947d5940c5e43001ee44577a05d433f5"></a><!-- doxytag: member="dr_ir_instr.h::instr_build_bits" ref="a947d5940c5e43001ee44577a05d433f5" args="(void *drcontext, int opcode, uint num_bytes)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structinstr__t.html">instr_t</a>* instr_build_bits </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>drcontext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>opcode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&nbsp;</td>
          <td class="paramname"> <em>num_bytes</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Convenience routine: calls</p>
<ul>
<li>instr_create(dcontext)</li>
<li>instr_set_opcode(instr, opcode)</li>
<li>instr_allocate_raw_bits(dcontext, instr, num_bytes)</li>
</ul>
<p>and returns the resulting <a class="el" href="structinstr__t.html">instr_t</a>. </p>

</div>
</div>
<a class="anchor" id="af8c874bf0f8b67dd6a85f2d54c1e87dc"></a><!-- doxytag: member="dr_ir_instr.h::instr_clone" ref="af8c874bf0f8b67dd6a85f2d54c1e87dc" args="(void *drcontext, instr_t *orig)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structinstr__t.html">instr_t</a>* instr_clone </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>drcontext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structinstr__t.html">instr_t</a> *&nbsp;</td>
          <td class="paramname"> <em>orig</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Returns a copy of <code>orig</code> with separately allocated memory for operands and raw bytes if they were present in <code>orig</code>. Cloning an instruction with a non-zero <code>note</code> field is not supported. </p>

</div>
</div>
<a class="anchor" id="a222195624605490e7844ed3737ad3668"></a><!-- doxytag: member="dr_ir_instr.h::instr_cmovcc_to_jcc" ref="a222195624605490e7844ed3737ad3668" args="(int cmovcc_opcode)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int instr_cmovcc_to_jcc </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>cmovcc_opcode</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Converts a cmovcc opcode <code>cmovcc_opcode</code> to the OP_jcc opcode that tests the same bits in eflags. </p>

</div>
</div>
<a class="anchor" id="a238dc0a1168701e30a95b57dd0c845a0"></a><!-- doxytag: member="dr_ir_instr.h::instr_cmovcc_triggered" ref="a238dc0a1168701e30a95b57dd0c845a0" args="(instr_t *instr, reg_t eflags)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool instr_cmovcc_triggered </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structinstr__t.html">instr_t</a> *&nbsp;</td>
          <td class="paramname"> <em>instr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">reg_t&nbsp;</td>
          <td class="paramname"> <em>eflags</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Given <code>eflags</code>, returns whether or not the conditional move instruction <code>instr</code> would execute the move. The conditional move can be an OP_cmovcc or an OP_fcmovcc instruction. </p>

</div>
</div>
<a class="anchor" id="aa13ec559a17ab70816f80de784e5632f"></a><!-- doxytag: member="dr_ir_instr.h::instr_compute_address" ref="aa13ec559a17ab70816f80de784e5632f" args="(instr_t *instr, dr_mcontext_t *mc)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">app_pc instr_compute_address </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structinstr__t.html">instr_t</a> *&nbsp;</td>
          <td class="paramname"> <em>instr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct__dr__mcontext__t.html">dr_mcontext_t</a> *&nbsp;</td>
          <td class="paramname"> <em>mc</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Returns NULL if none of <code>instr's</code> operands is a memory reference. Otherwise, returns the effective address of the first memory operand when the operands are considered in this order: destinations and then sources. The address is computed using the passed-in registers. <code>mc-&gt;flags</code> must include DR_MC_CONTROL and DR_MC_INTEGER. </p>

</div>
</div>
<a class="anchor" id="aa04322a189dd7f17ab245594e02cc6a8"></a><!-- doxytag: member="dr_ir_instr.h::instr_compute_address_ex" ref="aa04322a189dd7f17ab245594e02cc6a8" args="(instr_t *instr, dr_mcontext_t *mc, uint index, OUT app_pc *addr, OUT bool *write)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool instr_compute_address_ex </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structinstr__t.html">instr_t</a> *&nbsp;</td>
          <td class="paramname"> <em>instr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct__dr__mcontext__t.html">dr_mcontext_t</a> *&nbsp;</td>
          <td class="paramname"> <em>mc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&nbsp;</td>
          <td class="paramname"> <em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OUT app_pc *&nbsp;</td>
          <td class="paramname"> <em>addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OUT bool *&nbsp;</td>
          <td class="paramname"> <em>write</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Performs address calculation in the same manner as <a class="el" href="dr__ir__instr_8h.html#aa13ec559a17ab70816f80de784e5632f">instr_compute_address()</a> but handles multiple memory operands. The <code>index</code> parameter should be initially set to 0 and then incremented with each successive call until this routine returns false, which indicates that there are no more memory operands. The address of each is computed in the same manner as <a class="el" href="dr__ir__instr_8h.html#aa13ec559a17ab70816f80de784e5632f">instr_compute_address()</a> and returned in <code>addr</code>; whether it is a write is returned in <code>is_write</code>. Either or both OUT variables can be NULL. <code>mc-&gt;flags</code> must include DR_MC_CONTROL and DR_MC_INTEGER. </p>

</div>
</div>
<a class="anchor" id="a25107e1fb5a49de3c627b70acc7b2eef"></a><!-- doxytag: member="dr_ir_instr.h::instr_compute_address_ex_pos" ref="a25107e1fb5a49de3c627b70acc7b2eef" args="(instr_t *instr, dr_mcontext_t *mc, uint index, OUT app_pc *addr, OUT bool *is_write, OUT uint *pos)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool instr_compute_address_ex_pos </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structinstr__t.html">instr_t</a> *&nbsp;</td>
          <td class="paramname"> <em>instr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct__dr__mcontext__t.html">dr_mcontext_t</a> *&nbsp;</td>
          <td class="paramname"> <em>mc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&nbsp;</td>
          <td class="paramname"> <em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OUT app_pc *&nbsp;</td>
          <td class="paramname"> <em>addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OUT bool *&nbsp;</td>
          <td class="paramname"> <em>is_write</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OUT uint *&nbsp;</td>
          <td class="paramname"> <em>pos</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Performs address calculation in the same manner as <a class="el" href="dr__ir__instr_8h.html#aa04322a189dd7f17ab245594e02cc6a8">instr_compute_address_ex()</a> with additional information of which opnd is used for address computation returned in <code>pos</code>. If <code>pos</code> is NULL, it is the same as <a class="el" href="dr__ir__instr_8h.html#aa04322a189dd7f17ab245594e02cc6a8">instr_compute_address_ex()</a>. </p>

</div>
</div>
<a class="anchor" id="a33a349e086f96bb03bd6700129dc6135"></a><!-- doxytag: member="dr_ir_instr.h::instr_convert_short_meta_jmp_to_long" ref="a33a349e086f96bb03bd6700129dc6135" args="(void *drcontext, instrlist_t *ilist, instr_t *instr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structinstr__t.html">instr_t</a>* instr_convert_short_meta_jmp_to_long </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>drcontext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">instrlist_t *&nbsp;</td>
          <td class="paramname"> <em>ilist</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structinstr__t.html">instr_t</a> *&nbsp;</td>
          <td class="paramname"> <em>instr</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Assumes that instr is a meta instruction (!instr_ok_to_mangle()) and an <a class="el" href="dr__ir__instr_8h.html#a2782471943558d57296b89a3f41a530d">instr_is_cti_short()</a> (8-bit reach). Converts instr's opcode to a long form (32-bit reach). If instr's opcode is OP_loop* or OP_jecxz, converts it to a sequence of multiple instructions (which is different from <a class="el" href="dr__ir__instr_8h.html#a8c61714f2632d46211d61ebb55d4bbde">instr_is_cti_short_rewrite()</a>). Each added instruction is marked !instr_ok_to_mangle(). Returns the long form of the instruction, which is identical to <code>instr</code> unless <code>instr</code> is OP_loop* or OP_jecxz, in which case the return value is the final instruction in the sequence, the one that has long reach. </p>
<dl class="note"><dt><b>Note:</b></dt><dd>DR automatically converts non-meta short ctis to long form. </dd></dl>

</div>
</div>
<a class="anchor" id="a65f53f3c43c91833faf11b5e6cd9e905"></a><!-- doxytag: member="dr_ir_instr.h::instr_create" ref="a65f53f3c43c91833faf11b5e6cd9e905" args="(void *drcontext)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structinstr__t.html">instr_t</a>* instr_create </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>drcontext</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Returns an initialized <a class="el" href="structinstr__t.html">instr_t</a> allocated on the thread-local heap. Sets the x86/x64 mode of the returned <a class="el" href="structinstr__t.html">instr_t</a> to the mode of dcontext. </p>

</div>
</div>
<a class="anchor" id="ac00a75c880108dde16b137370be5cedb"></a><!-- doxytag: member="dr_ir_instr.h::instr_create_0dst_0src" ref="ac00a75c880108dde16b137370be5cedb" args="(void *drcontext, int opcode)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structinstr__t.html">instr_t</a>* instr_create_0dst_0src </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>drcontext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>opcode</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Convenience routine that returns an initialized <a class="el" href="structinstr__t.html">instr_t</a> allocated on the thread-local heap with opcode <code>opcode</code> and no sources or destinations. </p>

</div>
</div>
<a class="anchor" id="ad3835ac2d78ba9b90e1ced9c58cada5e"></a><!-- doxytag: member="dr_ir_instr.h::instr_create_0dst_1src" ref="ad3835ac2d78ba9b90e1ced9c58cada5e" args="(void *drcontext, int opcode, opnd_t src)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structinstr__t.html">instr_t</a>* instr_create_0dst_1src </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>drcontext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>opcode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structopnd__t.html">opnd_t</a>&nbsp;</td>
          <td class="paramname"> <em>src</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Convenience routine that returns an initialized <a class="el" href="structinstr__t.html">instr_t</a> allocated on the thread-local heap with opcode <code>opcode</code> and a single source (<code>src</code>). </p>

</div>
</div>
<a class="anchor" id="a54d0c2cbad95bfe24daade84c6add8af"></a><!-- doxytag: member="dr_ir_instr.h::instr_create_0dst_2src" ref="a54d0c2cbad95bfe24daade84c6add8af" args="(void *drcontext, int opcode, opnd_t src1, opnd_t src2)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structinstr__t.html">instr_t</a>* instr_create_0dst_2src </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>drcontext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>opcode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structopnd__t.html">opnd_t</a>&nbsp;</td>
          <td class="paramname"> <em>src1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structopnd__t.html">opnd_t</a>&nbsp;</td>
          <td class="paramname"> <em>src2</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Convenience routine that returns an initialized <a class="el" href="structinstr__t.html">instr_t</a> allocated on the thread-local heap with opcode <code>opcode</code> and two sources (<code>src1</code>, <code>src2</code>). </p>

</div>
</div>
<a class="anchor" id="a21033066f65f8dfd23ca24215ea99b70"></a><!-- doxytag: member="dr_ir_instr.h::instr_create_0dst_3src" ref="a21033066f65f8dfd23ca24215ea99b70" args="(void *drcontext, int opcode, opnd_t src1, opnd_t src2, opnd_t src3)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structinstr__t.html">instr_t</a>* instr_create_0dst_3src </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>drcontext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>opcode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structopnd__t.html">opnd_t</a>&nbsp;</td>
          <td class="paramname"> <em>src1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structopnd__t.html">opnd_t</a>&nbsp;</td>
          <td class="paramname"> <em>src2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structopnd__t.html">opnd_t</a>&nbsp;</td>
          <td class="paramname"> <em>src3</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Convenience routine that returns an initialized <a class="el" href="structinstr__t.html">instr_t</a> allocated on the thread-local heap with opcode <code>opcode</code> and three sources (<code>src1</code>, <code>src2</code>, <code>src3</code>). </p>

</div>
</div>
<a class="anchor" id="a4db9f5f8dfd216fab6e9153170fb479f"></a><!-- doxytag: member="dr_ir_instr.h::instr_create_1dst_0src" ref="a4db9f5f8dfd216fab6e9153170fb479f" args="(void *drcontext, int opcode, opnd_t dst)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structinstr__t.html">instr_t</a>* instr_create_1dst_0src </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>drcontext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>opcode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structopnd__t.html">opnd_t</a>&nbsp;</td>
          <td class="paramname"> <em>dst</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Convenience routine that returns an initialized <a class="el" href="structinstr__t.html">instr_t</a> allocated on the thread-local heap with opcode <code>opcode</code> and one destination (<code>dst</code>). </p>

</div>
</div>
<a class="anchor" id="a0202b3cf63b50d16947f6be6f2b00891"></a><!-- doxytag: member="dr_ir_instr.h::instr_create_1dst_1src" ref="a0202b3cf63b50d16947f6be6f2b00891" args="(void *drcontext, int opcode, opnd_t dst, opnd_t src)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structinstr__t.html">instr_t</a>* instr_create_1dst_1src </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>drcontext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>opcode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structopnd__t.html">opnd_t</a>&nbsp;</td>
          <td class="paramname"> <em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structopnd__t.html">opnd_t</a>&nbsp;</td>
          <td class="paramname"> <em>src</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Convenience routine that returns an initialized <a class="el" href="structinstr__t.html">instr_t</a> allocated on the thread-local heap with opcode <code>opcode</code>, one destination(<code>dst</code>), and one source (<code>src</code>). </p>

</div>
</div>
<a class="anchor" id="ac469b18246e67b23f758c636f460d8ac"></a><!-- doxytag: member="dr_ir_instr.h::instr_create_1dst_2src" ref="ac469b18246e67b23f758c636f460d8ac" args="(void *drcontext, int opcode, opnd_t dst, opnd_t src1, opnd_t src2)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structinstr__t.html">instr_t</a>* instr_create_1dst_2src </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>drcontext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>opcode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structopnd__t.html">opnd_t</a>&nbsp;</td>
          <td class="paramname"> <em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structopnd__t.html">opnd_t</a>&nbsp;</td>
          <td class="paramname"> <em>src1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structopnd__t.html">opnd_t</a>&nbsp;</td>
          <td class="paramname"> <em>src2</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Convenience routine that returns an initialized <a class="el" href="structinstr__t.html">instr_t</a> allocated on the thread-local heap with opcode <code>opcode</code>, one destination (<code>dst</code>), and two sources (<code>src1</code>, <code>src2</code>). </p>

</div>
</div>
<a class="anchor" id="a4a34019f73e797090b3ab9625cdbc5fc"></a><!-- doxytag: member="dr_ir_instr.h::instr_create_1dst_3src" ref="a4a34019f73e797090b3ab9625cdbc5fc" args="(void *drcontext, int opcode, opnd_t dst, opnd_t src1, opnd_t src2, opnd_t src3)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structinstr__t.html">instr_t</a>* instr_create_1dst_3src </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>drcontext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>opcode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structopnd__t.html">opnd_t</a>&nbsp;</td>
          <td class="paramname"> <em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structopnd__t.html">opnd_t</a>&nbsp;</td>
          <td class="paramname"> <em>src1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structopnd__t.html">opnd_t</a>&nbsp;</td>
          <td class="paramname"> <em>src2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structopnd__t.html">opnd_t</a>&nbsp;</td>
          <td class="paramname"> <em>src3</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Convenience routine that returns an initialized <a class="el" href="structinstr__t.html">instr_t</a> allocated on the thread-local heap with opcode <code>opcode</code>, one destination (<code>dst</code>), and three sources (<code>src1</code>, <code>src2</code>, <code>src3</code>). </p>

</div>
</div>
<a class="anchor" id="a4e5a5241276ad8d2f392c7a1432efb61"></a><!-- doxytag: member="dr_ir_instr.h::instr_create_1dst_5src" ref="a4e5a5241276ad8d2f392c7a1432efb61" args="(void *drcontext, int opcode, opnd_t dst, opnd_t src1, opnd_t src2, opnd_t src3, opnd_t src4, opnd_t src5)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structinstr__t.html">instr_t</a>* instr_create_1dst_5src </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>drcontext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>opcode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structopnd__t.html">opnd_t</a>&nbsp;</td>
          <td class="paramname"> <em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structopnd__t.html">opnd_t</a>&nbsp;</td>
          <td class="paramname"> <em>src1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structopnd__t.html">opnd_t</a>&nbsp;</td>
          <td class="paramname"> <em>src2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structopnd__t.html">opnd_t</a>&nbsp;</td>
          <td class="paramname"> <em>src3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structopnd__t.html">opnd_t</a>&nbsp;</td>
          <td class="paramname"> <em>src4</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structopnd__t.html">opnd_t</a>&nbsp;</td>
          <td class="paramname"> <em>src5</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Convenience routine that returns an initialized <a class="el" href="structinstr__t.html">instr_t</a> allocated on the thread-local heap with opcode <code>opcode</code>, one destination (<code>dst</code>), and five sources (<code>src1</code>, <code>src2</code>, <code>src3</code>, <code>src4</code>, <code>src5</code>). </p>

</div>
</div>
<a class="anchor" id="aeadd422dcd43564d40b43ca0e03b6910"></a><!-- doxytag: member="dr_ir_instr.h::instr_create_2dst_0src" ref="aeadd422dcd43564d40b43ca0e03b6910" args="(void *drcontext, int opcode, opnd_t dst1, opnd_t dst2)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structinstr__t.html">instr_t</a>* instr_create_2dst_0src </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>drcontext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>opcode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structopnd__t.html">opnd_t</a>&nbsp;</td>
          <td class="paramname"> <em>dst1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structopnd__t.html">opnd_t</a>&nbsp;</td>
          <td class="paramname"> <em>dst2</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Convenience routine that returns an initialized <a class="el" href="structinstr__t.html">instr_t</a> allocated on the thread-local heap with opcode <code>opcode</code>, two destinations (<code>dst1</code>, <code>dst2</code>) and no sources. </p>

</div>
</div>
<a class="anchor" id="ae6d0c6211ec93379e4ad6dc520506111"></a><!-- doxytag: member="dr_ir_instr.h::instr_create_2dst_1src" ref="ae6d0c6211ec93379e4ad6dc520506111" args="(void *drcontext, int opcode, opnd_t dst1, opnd_t dst2, opnd_t src)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structinstr__t.html">instr_t</a>* instr_create_2dst_1src </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>drcontext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>opcode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structopnd__t.html">opnd_t</a>&nbsp;</td>
          <td class="paramname"> <em>dst1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structopnd__t.html">opnd_t</a>&nbsp;</td>
          <td class="paramname"> <em>dst2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structopnd__t.html">opnd_t</a>&nbsp;</td>
          <td class="paramname"> <em>src</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Convenience routine that returns an initialized <a class="el" href="structinstr__t.html">instr_t</a> allocated on the thread-local heap with opcode <code>opcode</code>, two destinations (<code>dst1</code>, <code>dst2</code>) and one source (<code>src</code>). </p>

</div>
</div>
<a class="anchor" id="a3c614653cadce1e2e6e567f3f68de6a8"></a><!-- doxytag: member="dr_ir_instr.h::instr_create_2dst_2src" ref="a3c614653cadce1e2e6e567f3f68de6a8" args="(void *drcontext, int opcode, opnd_t dst1, opnd_t dst2, opnd_t src1, opnd_t src2)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structinstr__t.html">instr_t</a>* instr_create_2dst_2src </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>drcontext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>opcode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structopnd__t.html">opnd_t</a>&nbsp;</td>
          <td class="paramname"> <em>dst1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structopnd__t.html">opnd_t</a>&nbsp;</td>
          <td class="paramname"> <em>dst2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structopnd__t.html">opnd_t</a>&nbsp;</td>
          <td class="paramname"> <em>src1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structopnd__t.html">opnd_t</a>&nbsp;</td>
          <td class="paramname"> <em>src2</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Convenience routine that returns an initialized <a class="el" href="structinstr__t.html">instr_t</a> allocated on the thread-local heap with opcode <code>opcode</code>, two destinations (<code>dst1</code>, <code>dst2</code>) and two sources (<code>src1</code>, <code>src2</code>). </p>

</div>
</div>
<a class="anchor" id="a711cac2989e3f2fa8fa702ce3b7f8ced"></a><!-- doxytag: member="dr_ir_instr.h::instr_create_2dst_3src" ref="a711cac2989e3f2fa8fa702ce3b7f8ced" args="(void *drcontext, int opcode, opnd_t dst1, opnd_t dst2, opnd_t src1, opnd_t src2, opnd_t src3)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structinstr__t.html">instr_t</a>* instr_create_2dst_3src </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>drcontext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>opcode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structopnd__t.html">opnd_t</a>&nbsp;</td>
          <td class="paramname"> <em>dst1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structopnd__t.html">opnd_t</a>&nbsp;</td>
          <td class="paramname"> <em>dst2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structopnd__t.html">opnd_t</a>&nbsp;</td>
          <td class="paramname"> <em>src1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structopnd__t.html">opnd_t</a>&nbsp;</td>
          <td class="paramname"> <em>src2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structopnd__t.html">opnd_t</a>&nbsp;</td>
          <td class="paramname"> <em>src3</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Convenience routine that returns an initialized <a class="el" href="structinstr__t.html">instr_t</a> allocated on the thread-local heap with opcode <code>opcode</code>, two destinations (<code>dst1</code>, <code>dst2</code>) and three sources (<code>src1</code>, <code>src2</code>, <code>src3</code>). </p>

</div>
</div>
<a class="anchor" id="a608e02e275eb868cd09ba8c454d78b5d"></a><!-- doxytag: member="dr_ir_instr.h::instr_create_2dst_4src" ref="a608e02e275eb868cd09ba8c454d78b5d" args="(void *drcontext, int opcode, opnd_t dst1, opnd_t dst2, opnd_t src1, opnd_t src2, opnd_t src3, opnd_t src4)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structinstr__t.html">instr_t</a>* instr_create_2dst_4src </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>drcontext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>opcode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structopnd__t.html">opnd_t</a>&nbsp;</td>
          <td class="paramname"> <em>dst1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structopnd__t.html">opnd_t</a>&nbsp;</td>
          <td class="paramname"> <em>dst2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structopnd__t.html">opnd_t</a>&nbsp;</td>
          <td class="paramname"> <em>src1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structopnd__t.html">opnd_t</a>&nbsp;</td>
          <td class="paramname"> <em>src2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structopnd__t.html">opnd_t</a>&nbsp;</td>
          <td class="paramname"> <em>src3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structopnd__t.html">opnd_t</a>&nbsp;</td>
          <td class="paramname"> <em>src4</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Convenience routine that returns an initialized <a class="el" href="structinstr__t.html">instr_t</a> allocated on the thread-local heap with opcode <code>opcode</code>, two destinations (<code>dst1</code>, <code>dst2</code>) and four sources (<code>src1</code>, <code>src2</code>, <code>src3</code>, <code>src4</code>). </p>

</div>
</div>
<a class="anchor" id="a678839fc8b937d70b63be5fcbbb2d014"></a><!-- doxytag: member="dr_ir_instr.h::instr_create_3dst_0src" ref="a678839fc8b937d70b63be5fcbbb2d014" args="(void *drcontext, int opcode, opnd_t dst1, opnd_t dst2, opnd_t dst3)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structinstr__t.html">instr_t</a>* instr_create_3dst_0src </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>drcontext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>opcode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structopnd__t.html">opnd_t</a>&nbsp;</td>
          <td class="paramname"> <em>dst1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structopnd__t.html">opnd_t</a>&nbsp;</td>
          <td class="paramname"> <em>dst2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structopnd__t.html">opnd_t</a>&nbsp;</td>
          <td class="paramname"> <em>dst3</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Convenience routine that returns an initialized <a class="el" href="structinstr__t.html">instr_t</a> allocated on the thread-local heap with opcode <code>opcode</code>, three destinations (<code>dst1</code>, <code>dst2</code>, <code>dst3</code>) and no sources. </p>

</div>
</div>
<a class="anchor" id="ae5f963b19ebe6ff70c0ea8174b53d9ed"></a><!-- doxytag: member="dr_ir_instr.h::instr_create_3dst_3src" ref="ae5f963b19ebe6ff70c0ea8174b53d9ed" args="(void *drcontext, int opcode, opnd_t dst1, opnd_t dst2, opnd_t dst3, opnd_t src1, opnd_t src2, opnd_t src3)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structinstr__t.html">instr_t</a>* instr_create_3dst_3src </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>drcontext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>opcode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structopnd__t.html">opnd_t</a>&nbsp;</td>
          <td class="paramname"> <em>dst1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structopnd__t.html">opnd_t</a>&nbsp;</td>
          <td class="paramname"> <em>dst2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structopnd__t.html">opnd_t</a>&nbsp;</td>
          <td class="paramname"> <em>dst3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structopnd__t.html">opnd_t</a>&nbsp;</td>
          <td class="paramname"> <em>src1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structopnd__t.html">opnd_t</a>&nbsp;</td>
          <td class="paramname"> <em>src2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structopnd__t.html">opnd_t</a>&nbsp;</td>
          <td class="paramname"> <em>src3</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Convenience routine that returns an initialized <a class="el" href="structinstr__t.html">instr_t</a> allocated on the thread-local heap with opcode <code>opcode</code>, three destinations (<code>dst1</code>, <code>dst2</code>, <code>dst3</code>) and three sources (<code>src1</code>, <code>src2</code>, <code>src3</code>). </p>

</div>
</div>
<a class="anchor" id="a32078373abe0c5fb3f97774a936569d9"></a><!-- doxytag: member="dr_ir_instr.h::instr_create_3dst_4src" ref="a32078373abe0c5fb3f97774a936569d9" args="(void *drcontext, int opcode, opnd_t dst1, opnd_t dst2, opnd_t dst3, opnd_t src1, opnd_t src2, opnd_t src3, opnd_t src4)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structinstr__t.html">instr_t</a>* instr_create_3dst_4src </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>drcontext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>opcode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structopnd__t.html">opnd_t</a>&nbsp;</td>
          <td class="paramname"> <em>dst1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structopnd__t.html">opnd_t</a>&nbsp;</td>
          <td class="paramname"> <em>dst2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structopnd__t.html">opnd_t</a>&nbsp;</td>
          <td class="paramname"> <em>dst3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structopnd__t.html">opnd_t</a>&nbsp;</td>
          <td class="paramname"> <em>src1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structopnd__t.html">opnd_t</a>&nbsp;</td>
          <td class="paramname"> <em>src2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structopnd__t.html">opnd_t</a>&nbsp;</td>
          <td class="paramname"> <em>src3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structopnd__t.html">opnd_t</a>&nbsp;</td>
          <td class="paramname"> <em>src4</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Convenience routine that returns an initialized <a class="el" href="structinstr__t.html">instr_t</a> allocated on the thread-local heap with opcode <code>opcode</code>, three destinations (<code>dst1</code>, <code>dst2</code>, <code>dst3</code>) and four sources (<code>src1</code>, <code>src2</code>, <code>src3</code>, <code>src4</code>). </p>

</div>
</div>
<a class="anchor" id="aee21bbcad5d7ee35f8828ed5244132fd"></a><!-- doxytag: member="dr_ir_instr.h::instr_create_3dst_5src" ref="aee21bbcad5d7ee35f8828ed5244132fd" args="(void *drcontext, int opcode, opnd_t dst1, opnd_t dst2, opnd_t dst3, opnd_t src1, opnd_t src2, opnd_t src3, opnd_t src4, opnd_t src5)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structinstr__t.html">instr_t</a>* instr_create_3dst_5src </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>drcontext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>opcode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structopnd__t.html">opnd_t</a>&nbsp;</td>
          <td class="paramname"> <em>dst1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structopnd__t.html">opnd_t</a>&nbsp;</td>
          <td class="paramname"> <em>dst2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structopnd__t.html">opnd_t</a>&nbsp;</td>
          <td class="paramname"> <em>dst3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structopnd__t.html">opnd_t</a>&nbsp;</td>
          <td class="paramname"> <em>src1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structopnd__t.html">opnd_t</a>&nbsp;</td>
          <td class="paramname"> <em>src2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structopnd__t.html">opnd_t</a>&nbsp;</td>
          <td class="paramname"> <em>src3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structopnd__t.html">opnd_t</a>&nbsp;</td>
          <td class="paramname"> <em>src4</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structopnd__t.html">opnd_t</a>&nbsp;</td>
          <td class="paramname"> <em>src5</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Convenience routine that returns an initialized <a class="el" href="structinstr__t.html">instr_t</a> allocated on the thread-local heap with opcode <code>opcode</code>, three destinations (<code>dst1</code>, <code>dst2</code>, <code>dst3</code>) and five sources (<code>src1</code>, <code>src2</code>, <code>src3</code>, <code>src4</code>, <code>src5</code>). </p>

</div>
</div>
<a class="anchor" id="ab8b00a25f7ec49fbf943df0e9c667136"></a><!-- doxytag: member="dr_ir_instr.h::instr_create_4dst_1src" ref="ab8b00a25f7ec49fbf943df0e9c667136" args="(void *drcontext, int opcode, opnd_t dst1, opnd_t dst2, opnd_t dst3, opnd_t dst4, opnd_t src)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structinstr__t.html">instr_t</a>* instr_create_4dst_1src </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>drcontext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>opcode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structopnd__t.html">opnd_t</a>&nbsp;</td>
          <td class="paramname"> <em>dst1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structopnd__t.html">opnd_t</a>&nbsp;</td>
          <td class="paramname"> <em>dst2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structopnd__t.html">opnd_t</a>&nbsp;</td>
          <td class="paramname"> <em>dst3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structopnd__t.html">opnd_t</a>&nbsp;</td>
          <td class="paramname"> <em>dst4</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structopnd__t.html">opnd_t</a>&nbsp;</td>
          <td class="paramname"> <em>src</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Convenience routine that returns an initialized <a class="el" href="structinstr__t.html">instr_t</a> allocated on the thread-local heap with opcode <code>opcode</code>, four destinations (<code>dst1</code>, <code>dst2</code>, <code>dst3</code>, <code>dst4</code>) and 1 source (<code>src</code>). </p>

</div>
</div>
<a class="anchor" id="abd02600b967d24951bc7208b6d70d459"></a><!-- doxytag: member="dr_ir_instr.h::instr_create_4dst_4src" ref="abd02600b967d24951bc7208b6d70d459" args="(void *drcontext, int opcode, opnd_t dst1, opnd_t dst2, opnd_t dst3, opnd_t dst4, opnd_t src1, opnd_t src2, opnd_t src3, opnd_t src4)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structinstr__t.html">instr_t</a>* instr_create_4dst_4src </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>drcontext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>opcode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structopnd__t.html">opnd_t</a>&nbsp;</td>
          <td class="paramname"> <em>dst1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structopnd__t.html">opnd_t</a>&nbsp;</td>
          <td class="paramname"> <em>dst2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structopnd__t.html">opnd_t</a>&nbsp;</td>
          <td class="paramname"> <em>dst3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structopnd__t.html">opnd_t</a>&nbsp;</td>
          <td class="paramname"> <em>dst4</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structopnd__t.html">opnd_t</a>&nbsp;</td>
          <td class="paramname"> <em>src1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structopnd__t.html">opnd_t</a>&nbsp;</td>
          <td class="paramname"> <em>src2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structopnd__t.html">opnd_t</a>&nbsp;</td>
          <td class="paramname"> <em>src3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structopnd__t.html">opnd_t</a>&nbsp;</td>
          <td class="paramname"> <em>src4</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Convenience routine that returns an initialized <a class="el" href="structinstr__t.html">instr_t</a> allocated on the thread-local heap with opcode <code>opcode</code>, four destinations (<code>dst1</code>, <code>dst2</code>, <code>dst3</code>, <code>dst4</code>) and four sources (<code>src1</code>, <code>src2</code>, <code>src3</code>, <code>src4</code>). </p>

</div>
</div>
<a class="anchor" id="aa554f82d7fa8abd4f38dba90544c20ae"></a><!-- doxytag: member="dr_ir_instr.h::instr_create_popa" ref="aa554f82d7fa8abd4f38dba90544c20ae" args="(void *drcontext)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structinstr__t.html">instr_t</a>* instr_create_popa </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>drcontext</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Convenience routine that returns an initialized <a class="el" href="structinstr__t.html">instr_t</a> for OP_popa. </p>

</div>
</div>
<a class="anchor" id="a418865307bd5bd168cbde4ecd0f785a5"></a><!-- doxytag: member="dr_ir_instr.h::instr_create_pusha" ref="a418865307bd5bd168cbde4ecd0f785a5" args="(void *drcontext)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structinstr__t.html">instr_t</a>* instr_create_pusha </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>drcontext</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Convenience routine that returns an initialized <a class="el" href="structinstr__t.html">instr_t</a> for OP_pusha. </p>

</div>
</div>
<a class="anchor" id="acb082bbf9ac73968667b79b4cd14d73f"></a><!-- doxytag: member="dr_ir_instr.h::instr_destroy" ref="acb082bbf9ac73968667b79b4cd14d73f" args="(void *drcontext, instr_t *instr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void instr_destroy </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>drcontext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structinstr__t.html">instr_t</a> *&nbsp;</td>
          <td class="paramname"> <em>instr</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Performs <a class="el" href="dr__ir__instr_8h.html#ae0f3cc7fb91265cb6c8eb15a84184c1f">instr_free()</a> and then deallocates the thread-local heap storage for <code>instr</code>. </p>

</div>
</div>
<a class="anchor" id="a6baf5239817b639791916f3cbd6c7b9d"></a><!-- doxytag: member="dr_ir_instr.h::instr_disassemble" ref="a6baf5239817b639791916f3cbd6c7b9d" args="(void *drcontext, instr_t *instr, file_t outfile)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void instr_disassemble </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>drcontext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structinstr__t.html">instr_t</a> *&nbsp;</td>
          <td class="paramname"> <em>instr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">file_t&nbsp;</td>
          <td class="paramname"> <em>outfile</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Prints the instruction <code>instr</code> to file <code>outfile</code>. Does not print address-size or data-size prefixes for other than just-decoded instrs, and does not check that the instruction has a valid encoding. Prints each operand with leading zeros indicating the size. The default is to use AT&amp;T-style syntax, unless the <a class="el" href="using.html#op_syntax_intel">-syntax_intel</a> runtime option is specified. </p>

</div>
</div>
<a class="anchor" id="af67ded4a34cef770ecc35e24e61813c8"></a><!-- doxytag: member="dr_ir_instr.h::instr_disassemble_to_buffer" ref="af67ded4a34cef770ecc35e24e61813c8" args="(void *drcontext, instr_t *instr, char *buf, size_t bufsz)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t instr_disassemble_to_buffer </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>drcontext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structinstr__t.html">instr_t</a> *&nbsp;</td>
          <td class="paramname"> <em>instr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&nbsp;</td>
          <td class="paramname"> <em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>bufsz</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Prints the instruction <code>instr</code> to the buffer <code>buf</code>. Always null-terminates, and will not print more than <code>bufsz</code> characters, which includes the final null character. Returns the number of characters printed, not including the final null.</p>
<p>Does not print address-size or data-size prefixes for other than just-decoded instrs, and does not check that the instruction has a valid encoding. Prints each operand with leading zeros indicating the size. The default is to use AT&amp;T-style syntax, unless the <a class="el" href="using.html#op_syntax_intel">-syntax_intel</a> runtime option is specified. </p>

</div>
</div>
<a class="anchor" id="a1cd4d0740eb0a0bcd2d387685719263c"></a><!-- doxytag: member="dr_ir_instr.h::instr_encode" ref="a1cd4d0740eb0a0bcd2d387685719263c" args="(void *drcontext, instr_t *instr, byte *pc)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">byte* instr_encode </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>drcontext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structinstr__t.html">instr_t</a> *&nbsp;</td>
          <td class="paramname"> <em>instr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">byte *&nbsp;</td>
          <td class="paramname"> <em>pc</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Encodes <code>instr</code> into the memory at <code>pc</code>. Uses the x86/x64 mode stored in instr, not the mode of the current thread. Returns the pc after the encoded instr, or NULL if the encoding failed. If instr is a cti with an <a class="el" href="structinstr__t.html">instr_t</a> target, the note fields of instr and of the target must be set with the respective offsets of each instr_t! (instrlist_encode does this automatically, if the target is in the list). x86 instructions can occupy up to 17 bytes, so the caller should ensure the target location has enough room to avoid overflow. </p>

</div>
</div>
<a class="anchor" id="a5356c2dd3388496158fa0a918f8c2a53"></a><!-- doxytag: member="dr_ir_instr.h::instr_encode_to_copy" ref="a5356c2dd3388496158fa0a918f8c2a53" args="(void *drcontext, instr_t *instr, byte *copy_pc, byte *final_pc)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">byte* instr_encode_to_copy </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>drcontext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structinstr__t.html">instr_t</a> *&nbsp;</td>
          <td class="paramname"> <em>instr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">byte *&nbsp;</td>
          <td class="paramname"> <em>copy_pc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">byte *&nbsp;</td>
          <td class="paramname"> <em>final_pc</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Encodes <code>instr</code> into the memory at <code>copy_pc</code> in preparation for copying to <code>final_pc</code>. Any pc-relative component is encoded as though the instruction were located at <code>final_pc</code>. This allows for direct copying of the encoded bytes to <code>final_pc</code> without re-relativization.</p>
<p>Uses the x86/x64 mode stored in instr, not the mode of the current thread. Returns the pc after the encoded instr, or NULL if the encoding failed. If instr is a cti with an <a class="el" href="structinstr__t.html">instr_t</a> target, the note fields of instr and of the target must be set with the respective offsets of each instr_t! (instrlist_encode does this automatically, if the target is in the list). x86 instructions can occupy up to 17 bytes, so the caller should ensure the target location has enough room to avoid overflow. </p>

</div>
</div>
<a class="anchor" id="ae0f3cc7fb91265cb6c8eb15a84184c1f"></a><!-- doxytag: member="dr_ir_instr.h::instr_free" ref="ae0f3cc7fb91265cb6c8eb15a84184c1f" args="(void *drcontext, instr_t *instr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void instr_free </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>drcontext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structinstr__t.html">instr_t</a> *&nbsp;</td>
          <td class="paramname"> <em>instr</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Deallocates all memory that was allocated by <code>instr</code>. This includes raw bytes allocated by <a class="el" href="dr__ir__instr_8h.html#af7b33f34d4dd11993224b4fb10e136dc">instr_allocate_raw_bits()</a> and operands allocated by <a class="el" href="dr__ir__instr_8h.html#aee0d80a8e69e8f0abe867f1903a107ea">instr_set_num_opnds()</a>. Does not deallocate the storage for <code>instr</code> itself. </p>

</div>
</div>
<a class="anchor" id="aa7af19aa3aadf7b05900a39ef62b01b9"></a><!-- doxytag: member="dr_ir_instr.h::instr_free_raw_bits" ref="aa7af19aa3aadf7b05900a39ef62b01b9" args="(void *drcontext, instr_t *instr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void instr_free_raw_bits </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>drcontext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structinstr__t.html">instr_t</a> *&nbsp;</td>
          <td class="paramname"> <em>instr</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>If <code>instr</code> has raw bits allocated, frees them. </p>

</div>
</div>
<a class="anchor" id="a57dbc129ab88dfdcf49f1105eba394a7"></a><!-- doxytag: member="dr_ir_instr.h::instr_get_app_pc" ref="a57dbc129ab88dfdcf49f1105eba394a7" args="(instr_t *instr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">app_pc instr_get_app_pc </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structinstr__t.html">instr_t</a> *&nbsp;</td>
          <td class="paramname"> <em>instr</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Get the original application PC of <code>instr</code> if it exists. </p>

</div>
</div>
<a class="anchor" id="a23aa72462b20fa6349d2ca2289c0f9a3"></a><!-- doxytag: member="dr_ir_instr.h::instr_get_arith_flags" ref="a23aa72462b20fa6349d2ca2289c0f9a3" args="(instr_t *instr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint instr_get_arith_flags </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structinstr__t.html">instr_t</a> *&nbsp;</td>
          <td class="paramname"> <em>instr</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Returns <code>instr's</code> arithmetic flags (bottom 6 eflags) use as EFLAGS_ constants or'ed together. If <code>instr's</code> eflags behavior has not been calculated yet or is invalid, the entire eflags use is calculated and returned (not just the arithmetic flags). </p>

</div>
</div>
<a class="anchor" id="ab4c178ef16a57aa4c89976cb11419719"></a><!-- doxytag: member="dr_ir_instr.h::instr_get_branch_target_pc" ref="ab4c178ef16a57aa4c89976cb11419719" args="(instr_t *cti_instr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">app_pc instr_get_branch_target_pc </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structinstr__t.html">instr_t</a> *&nbsp;</td>
          <td class="paramname"> <em>cti_instr</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return the taken target pc of the (direct branch) instruction. </p>

</div>
</div>
<a class="anchor" id="aed999847d48a5a9eb1032239a660e398"></a><!-- doxytag: member="dr_ir_instr.h::instr_get_dst" ref="aed999847d48a5a9eb1032239a660e398" args="(instr_t *instr, uint pos)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structopnd__t.html">opnd_t</a> instr_get_dst </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structinstr__t.html">instr_t</a> *&nbsp;</td>
          <td class="paramname"> <em>instr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&nbsp;</td>
          <td class="paramname"> <em>pos</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Returns <code>instr's</code> destination operand at position <code>pos</code> (0-based). </p>

</div>
</div>
<a class="anchor" id="af295aa1b99e3b1fb73562312fc547ce9"></a><!-- doxytag: member="dr_ir_instr.h::instr_get_eflags" ref="af295aa1b99e3b1fb73562312fc547ce9" args="(instr_t *instr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint instr_get_eflags </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structinstr__t.html">instr_t</a> *&nbsp;</td>
          <td class="paramname"> <em>instr</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Returns <code>instr's</code> eflags use as EFLAGS_ constants or'ed together. </p>

</div>
</div>
<a class="anchor" id="a784fcd66cdda36aaf218121f1b75ab2d"></a><!-- doxytag: member="dr_ir_instr.h::instr_get_interrupt_number" ref="a784fcd66cdda36aaf218121f1b75ab2d" args="(instr_t *instr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int instr_get_interrupt_number </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structinstr__t.html">instr_t</a> *&nbsp;</td>
          <td class="paramname"> <em>instr</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Assumes that <code>instr's</code> opcode is OP_int and that either <code>instr's</code> operands or its raw bits are valid. Returns the first source operand if <code>instr's</code> operands are valid, else if <code>instr's</code> raw bits are valid returns the first raw byte. </p>

</div>
</div>
<a class="anchor" id="a7eab5eaa85e186349d200a87e8010fec"></a><!-- doxytag: member="dr_ir_instr.h::instr_get_label_data_area" ref="a7eab5eaa85e186349d200a87e8010fec" args="(instr_t *instr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct__dr__instr__label__data__t.html">dr_instr_label_data_t</a>* instr_get_label_data_area </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structinstr__t.html">instr_t</a> *&nbsp;</td>
          <td class="paramname"> <em>instr</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl class="return"><dt><b>Returns:</b></dt><dd>a pointer to user-controlled data fields in a label instruction. These fields are available for use by clients for their own purposes. Returns NULL if <code>instr</code> is not a label instruction. </dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>These data fields are copied (shallowly) across <a class="el" href="dr__ir__instr_8h.html#af8c874bf0f8b67dd6a85f2d54c1e87dc">instr_clone()</a>. </dd></dl>

</div>
</div>
<a class="anchor" id="a7e6028bd1058d4becc4e2d29c96fbaf5"></a><!-- doxytag: member="dr_ir_instr.h::instr_get_next" ref="a7e6028bd1058d4becc4e2d29c96fbaf5" args="(instr_t *instr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structinstr__t.html">instr_t</a>* instr_get_next </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structinstr__t.html">instr_t</a> *&nbsp;</td>
          <td class="paramname"> <em>instr</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Returns the next <a class="el" href="structinstr__t.html">instr_t</a> in the instrlist_t that contains <code>instr</code>. </p>
<dl class="note"><dt><b>Note:</b></dt><dd>The next pointer for an <a class="el" href="structinstr__t.html">instr_t</a> is inside the <a class="el" href="structinstr__t.html">instr_t</a> data structure itself, making it impossible to have on <a class="el" href="structinstr__t.html">instr_t</a> in two different InstrLists (but removing the need for an extra data structure for each element of the instrlist_t). </dd></dl>

</div>
</div>
<a class="anchor" id="ad5e7b4a1ecf29b3a311b684e8efc322a"></a><!-- doxytag: member="dr_ir_instr.h::instr_get_note" ref="ad5e7b4a1ecf29b3a311b684e8efc322a" args="(instr_t *instr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* instr_get_note </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structinstr__t.html">instr_t</a> *&nbsp;</td>
          <td class="paramname"> <em>instr</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Gets the value of the user-controlled note field in <code>instr</code>. </p>
<dl class="note"><dt><b>Note:</b></dt><dd>Important: is also used when emitting for targets that are other instructions. Thus it will be overwritten when calling <a class="el" href="dr__ir__instrlist_8h.html#aaac5ae2bc9af179b56bbbe5efc14e8b5">instrlist_encode()</a> or <a class="el" href="dr__ir__instrlist_8h.html#a8ae48a113e137b95cd3499f9fa57f5ea">instrlist_encode_to_copy()</a> with <code>has_instr_jmp_targets</code> set to true. </dd>
<dd>
The note field is copied (shallowly) by <a class="el" href="dr__ir__instr_8h.html#af8c874bf0f8b67dd6a85f2d54c1e87dc">instr_clone()</a>. </dd></dl>

</div>
</div>
<a class="anchor" id="a90d36984352b073089da3c91b901c853"></a><!-- doxytag: member="dr_ir_instr.h::instr_get_opcode" ref="a90d36984352b073089da3c91b901c853" args="(instr_t *instr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int instr_get_opcode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structinstr__t.html">instr_t</a> *&nbsp;</td>
          <td class="paramname"> <em>instr</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Returns <code>instr's</code> opcode (an OP_ constant). </p>

</div>
</div>
<a class="anchor" id="a749df373b340acb6437fea2f02b2fe69"></a><!-- doxytag: member="dr_ir_instr.h::instr_get_opcode_eflags" ref="a749df373b340acb6437fea2f02b2fe69" args="(int opcode)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint instr_get_opcode_eflags </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>opcode</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Returns the eflags usage of instructions with opcode <code>opcode</code>, as EFLAGS_ constants or'ed together. </p>

</div>
</div>
<a class="anchor" id="a3722cd7a5b3728b5edeefd4b07bd456c"></a><!-- doxytag: member="dr_ir_instr.h::instr_get_prefix_flag" ref="a3722cd7a5b3728b5edeefd4b07bd456c" args="(instr_t *instr, uint prefix)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool instr_get_prefix_flag </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structinstr__t.html">instr_t</a> *&nbsp;</td>
          <td class="paramname"> <em>instr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&nbsp;</td>
          <td class="paramname"> <em>prefix</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Assumes that <code>prefix</code> is a PREFIX_ constant. Returns true if <code>instr's</code> prefixes contain the flag <code>prefix</code>. </p>

</div>
</div>
<a class="anchor" id="a4034f08d82d5f0d93f54691aefb75c82"></a><!-- doxytag: member="dr_ir_instr.h::instr_get_prev" ref="a4034f08d82d5f0d93f54691aefb75c82" args="(instr_t *instr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structinstr__t.html">instr_t</a>* instr_get_prev </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structinstr__t.html">instr_t</a> *&nbsp;</td>
          <td class="paramname"> <em>instr</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Returns the previous <a class="el" href="structinstr__t.html">instr_t</a> in the instrlist_t that contains <code>instr</code>. </p>

</div>
</div>
<a class="anchor" id="a964928ee44090aba9aef343c5d34df5c"></a><!-- doxytag: member="dr_ir_instr.h::instr_get_raw_bits" ref="a964928ee44090aba9aef343c5d34df5c" args="(instr_t *instr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">byte* instr_get_raw_bits </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structinstr__t.html">instr_t</a> *&nbsp;</td>
          <td class="paramname"> <em>instr</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Assumes that <code>instr's</code> raw bits are valid. Returns a pointer to <code>instr's</code> raw bits. </p>
<dl class="note"><dt><b>Note:</b></dt><dd>A freshly-decoded instruction has valid raw bits that point to the address from which it was decoded. </dd></dl>

</div>
</div>
<a class="anchor" id="af8d41e2a8da7c0ef207d269020053ecc"></a><!-- doxytag: member="dr_ir_instr.h::instr_get_raw_byte" ref="af8d41e2a8da7c0ef207d269020053ecc" args="(instr_t *instr, uint pos)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">byte instr_get_raw_byte </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structinstr__t.html">instr_t</a> *&nbsp;</td>
          <td class="paramname"> <em>instr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&nbsp;</td>
          <td class="paramname"> <em>pos</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Assumes that <code>instr's</code> raw bits are valid and have &gt; <code>pos</code> bytes. Returns a pointer to <code>instr's</code> raw byte at position <code>pos</code> (beginning with 0). </p>

</div>
</div>
<a class="anchor" id="ae0d1b19bf4e736c6f361164a295160a6"></a><!-- doxytag: member="dr_ir_instr.h::instr_get_raw_word" ref="ae0d1b19bf4e736c6f361164a295160a6" args="(instr_t *instr, uint pos)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint instr_get_raw_word </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structinstr__t.html">instr_t</a> *&nbsp;</td>
          <td class="paramname"> <em>instr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&nbsp;</td>
          <td class="paramname"> <em>pos</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Assumes that <code>instr's</code> raw bits are valid and have &gt; <code>pos</code> + 3 bytes. Returns the 4 bytes beginning at position <code>pos</code> (0-based). </p>

</div>
</div>
<a class="anchor" id="ae9e4c9cbe4890f8e37af9e299affc86c"></a><!-- doxytag: member="dr_ir_instr.h::instr_get_rel_addr_dst_idx" ref="ae9e4c9cbe4890f8e37af9e299affc86c" args="(instr_t *instr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int instr_get_rel_addr_dst_idx </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structinstr__t.html">instr_t</a> *&nbsp;</td>
          <td class="paramname"> <em>instr</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>If any of <code>instr's</code> destination operands is a rip-relative memory reference, returns the operand position. If there is no such destination operand, returns -1.</p>
<dl class="note"><dt><b>Note:</b></dt><dd>For 64-bit DR builds only. </dd></dl>

</div>
</div>
<a class="anchor" id="a8942eef70af97b8018b31df431ef1822"></a><!-- doxytag: member="dr_ir_instr.h::instr_get_rel_addr_src_idx" ref="a8942eef70af97b8018b31df431ef1822" args="(instr_t *instr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int instr_get_rel_addr_src_idx </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structinstr__t.html">instr_t</a> *&nbsp;</td>
          <td class="paramname"> <em>instr</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>If any of <code>instr's</code> source operands is a rip-relative memory reference, returns the operand position. If there is no such source operand, returns -1.</p>
<dl class="note"><dt><b>Note:</b></dt><dd>For 64-bit DR builds only. </dd></dl>

</div>
</div>
<a class="anchor" id="a19b43ab8c3edd905329429075e91ea1a"></a><!-- doxytag: member="dr_ir_instr.h::instr_get_rel_addr_target" ref="a19b43ab8c3edd905329429075e91ea1a" args="(instr_t *instr, app_pc *target)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool instr_get_rel_addr_target </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structinstr__t.html">instr_t</a> *&nbsp;</td>
          <td class="paramname"> <em>instr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">app_pc *&nbsp;</td>
          <td class="paramname"> <em>target</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>If any of <code>instr's</code> operands is a rip-relative memory reference, returns the address that reference targets. Else returns false.</p>
<dl class="note"><dt><b>Note:</b></dt><dd>For 64-bit DR builds only. </dd></dl>

</div>
</div>
<a class="anchor" id="aa60219f08461b9bc143214c937893d98"></a><!-- doxytag: member="dr_ir_instr.h::instr_get_src" ref="aa60219f08461b9bc143214c937893d98" args="(instr_t *instr, uint pos)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structopnd__t.html">opnd_t</a> instr_get_src </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structinstr__t.html">instr_t</a> *&nbsp;</td>
          <td class="paramname"> <em>instr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&nbsp;</td>
          <td class="paramname"> <em>pos</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Returns <code>instr's</code> source operand at position <code>pos</code> (0-based). </p>

</div>
</div>
<a class="anchor" id="a6ff26384b57a52838dbd9b854db44cb6"></a><!-- doxytag: member="dr_ir_instr.h::instr_get_target" ref="a6ff26384b57a52838dbd9b854db44cb6" args="(instr_t *cti_instr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structopnd__t.html">opnd_t</a> instr_get_target </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structinstr__t.html">instr_t</a> *&nbsp;</td>
          <td class="paramname"> <em>cti_instr</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Assumes that <code>cti_instr</code> is a control transfer instruction Returns the first source operand of <code>cti_instr</code> (its target). </p>

</div>
</div>
<a class="anchor" id="acf3a5a5abd40c0c0694f037fcfac5705"></a><!-- doxytag: member="dr_ir_instr.h::instr_get_x86_mode" ref="acf3a5a5abd40c0c0694f037fcfac5705" args="(instr_t *instr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool instr_get_x86_mode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structinstr__t.html">instr_t</a> *&nbsp;</td>
          <td class="paramname"> <em>instr</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Returns true if <code>instr</code> is an x86 instruction (32-bit) and false if <code>instr</code> is an x64 instruction (64-bit).</p>
<dl class="note"><dt><b>Note:</b></dt><dd>For 64-bit DR builds only. </dd></dl>

</div>
</div>
<a class="anchor" id="add5ea7e7d0387d7d1461830c1e5253c3"></a><!-- doxytag: member="dr_ir_instr.h::instr_has_allocated_bits" ref="add5ea7e7d0387d7d1461830c1e5253c3" args="(instr_t *instr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool instr_has_allocated_bits </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structinstr__t.html">instr_t</a> *&nbsp;</td>
          <td class="paramname"> <em>instr</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Returns true iff <code>instr</code> has its own allocated memory for raw bits. </p>

</div>
</div>
<a class="anchor" id="a7c2b7bfe6c9670ac127a24ea7aef33d4"></a><!-- doxytag: member="dr_ir_instr.h::instr_has_rel_addr_reference" ref="a7c2b7bfe6c9670ac127a24ea7aef33d4" args="(instr_t *instr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool instr_has_rel_addr_reference </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structinstr__t.html">instr_t</a> *&nbsp;</td>
          <td class="paramname"> <em>instr</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Returns true iff any of <code>instr's</code> operands is a rip-relative memory reference.</p>
<dl class="note"><dt><b>Note:</b></dt><dd>For 64-bit DR builds only. </dd></dl>

</div>
</div>
<a class="anchor" id="a77b55daa2b3780d2c07e33b8330b2f62"></a><!-- doxytag: member="dr_ir_instr.h::instr_init" ref="a77b55daa2b3780d2c07e33b8330b2f62" args="(void *drcontext, instr_t *instr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void instr_init </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>drcontext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structinstr__t.html">instr_t</a> *&nbsp;</td>
          <td class="paramname"> <em>instr</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Initializes <code>instr</code>. Sets the x86/x64 mode of <code>instr</code> to the mode of dcontext. </p>

</div>
</div>
<a class="anchor" id="acc25aa34b90fcf0cdcfdbd8028464274"></a><!-- doxytag: member="dr_ir_instr.h::instr_invert_cbr" ref="acc25aa34b90fcf0cdcfdbd8028464274" args="(instr_t *instr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void instr_invert_cbr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structinstr__t.html">instr_t</a> *&nbsp;</td>
          <td class="paramname"> <em>instr</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Assumes that <code>instr</code> is a conditional branch instruction Reverses the logic of <code>instr's</code> conditional e.g., changes OP_jb to OP_jnb. Works on cti_short_rewrite as well. </p>

</div>
</div>
<a class="anchor" id="a9d347723617986e9424b042cb69495e5"></a><!-- doxytag: member="dr_ir_instr.h::instr_is_call" ref="a9d347723617986e9424b042cb69495e5" args="(instr_t *instr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool instr_is_call </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structinstr__t.html">instr_t</a> *&nbsp;</td>
          <td class="paramname"> <em>instr</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Returns true iff <code>instr's</code> opcode is OP_call, OP_call_far, OP_call_ind, or OP_call_far_ind. </p>

</div>
</div>
<a class="anchor" id="a5cb0fc26f65991c24002df14abb7e461"></a><!-- doxytag: member="dr_ir_instr.h::instr_is_call_direct" ref="a5cb0fc26f65991c24002df14abb7e461" args="(instr_t *instr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool instr_is_call_direct </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structinstr__t.html">instr_t</a> *&nbsp;</td>
          <td class="paramname"> <em>instr</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Returns true iff <code>instr's</code> opcode is OP_call or OP_call_far. </p>

</div>
</div>
<a class="anchor" id="a1fe1cc575e2870720ceee8ce134771f3"></a><!-- doxytag: member="dr_ir_instr.h::instr_is_call_indirect" ref="a1fe1cc575e2870720ceee8ce134771f3" args="(instr_t *instr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool instr_is_call_indirect </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structinstr__t.html">instr_t</a> *&nbsp;</td>
          <td class="paramname"> <em>instr</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Returns true iff <code>instr's</code> opcode is OP_call_ind or OP_call_far_ind. </p>

</div>
</div>
<a class="anchor" id="a006c261a813d4e91fc25c549e5ebbb8d"></a><!-- doxytag: member="dr_ir_instr.h::instr_is_cbr" ref="a006c261a813d4e91fc25c549e5ebbb8d" args="(instr_t *instr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool instr_is_cbr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structinstr__t.html">instr_t</a> *&nbsp;</td>
          <td class="paramname"> <em>instr</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Returns true iff <code>instr</code> is a conditional branch: OP_jcc, OP_jcc_short, OP_loop*, or OP_jecxz. </p>

</div>
</div>
<a class="anchor" id="a076d0445255d4902181cb272bacd80aa"></a><!-- doxytag: member="dr_ir_instr.h::instr_is_cti" ref="a076d0445255d4902181cb272bacd80aa" args="(instr_t *instr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool instr_is_cti </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structinstr__t.html">instr_t</a> *&nbsp;</td>
          <td class="paramname"> <em>instr</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Returns true iff <code>instr</code> is a control transfer instruction of any kind This includes OP_jcc, OP_jcc_short, OP_loop*, OP_jecxz, OP_call*, and OP_jmp*. </p>

</div>
</div>
<a class="anchor" id="a4af759611c486c5ac9e1a5336a809661"></a><!-- doxytag: member="dr_ir_instr.h::instr_is_cti_loop" ref="a4af759611c486c5ac9e1a5336a809661" args="(instr_t *instr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool instr_is_cti_loop </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structinstr__t.html">instr_t</a> *&nbsp;</td>
          <td class="paramname"> <em>instr</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Returns true iff <code>instr</code> is one of OP_loop* or OP_jecxz. </p>

</div>
</div>
<a class="anchor" id="a2782471943558d57296b89a3f41a530d"></a><!-- doxytag: member="dr_ir_instr.h::instr_is_cti_short" ref="a2782471943558d57296b89a3f41a530d" args="(instr_t *instr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool instr_is_cti_short </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structinstr__t.html">instr_t</a> *&nbsp;</td>
          <td class="paramname"> <em>instr</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Returns true iff <code>instr</code> is a control transfer instruction that takes an 8-bit offset: OP_loop*, OP_jecxz, OP_jmp_short, or OP_jcc_short </p>

</div>
</div>
<a class="anchor" id="a8c61714f2632d46211d61ebb55d4bbde"></a><!-- doxytag: member="dr_ir_instr.h::instr_is_cti_short_rewrite" ref="a8c61714f2632d46211d61ebb55d4bbde" args="(instr_t *instr, byte *pc)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool instr_is_cti_short_rewrite </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structinstr__t.html">instr_t</a> *&nbsp;</td>
          <td class="paramname"> <em>instr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">byte *&nbsp;</td>
          <td class="paramname"> <em>pc</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Returns true iff <code>instr's</code> opcode is OP_loop* or OP_jecxz and instr has been transformed to a sequence of instruction that will allow a 32-bit offset. If <code>pc</code> != NULL, <code>pc</code> is expected to point the the beginning of the encoding of <code>instr</code>, and the following instructions are assumed to be encoded in sequence after <code>instr</code>. Otherwise, the encoding is expected to be found in <code>instr's</code> allocated bits. </p>

</div>
</div>
<a class="anchor" id="a56419903595cc4bd2bb39f887a5275d5"></a><!-- doxytag: member="dr_ir_instr.h::instr_is_encoding_possible" ref="a56419903595cc4bd2bb39f887a5275d5" args="(instr_t *instr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool instr_is_encoding_possible </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structinstr__t.html">instr_t</a> *&nbsp;</td>
          <td class="paramname"> <em>instr</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Returns true iff <code>instr</code> can be encoding as a valid IA-32 instruction. </p>

</div>
</div>
<a class="anchor" id="ad7abc869b82542e5ea0e564ec671b7cd"></a><!-- doxytag: member="dr_ir_instr.h::instr_is_exit_cti" ref="ad7abc869b82542e5ea0e564ec671b7cd" args="(instr_t *instr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool instr_is_exit_cti </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structinstr__t.html">instr_t</a> *&nbsp;</td>
          <td class="paramname"> <em>instr</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Returns true iff <code>instr</code> is a conditional branch, unconditional branch, or indirect branch with a program address target (NOT an <a class="el" href="structinstr__t.html">instr_t</a> address target) and <code>instr</code> is ok to mangle. </p>

</div>
</div>
<a class="anchor" id="ac83165c08bdab6b1bf0933bccba7d557"></a><!-- doxytag: member="dr_ir_instr.h::instr_is_far_abs_cti" ref="ac83165c08bdab6b1bf0933bccba7d557" args="(instr_t *instr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool instr_is_far_abs_cti </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structinstr__t.html">instr_t</a> *&nbsp;</td>
          <td class="paramname"> <em>instr</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Returns true if <code>instr</code> is an absolute call or jmp that is far. </p>

</div>
</div>
<a class="anchor" id="a45ee0433816dfcfbe8ca41988d757aee"></a><!-- doxytag: member="dr_ir_instr.h::instr_is_far_cti" ref="a45ee0433816dfcfbe8ca41988d757aee" args="(instr_t *instr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool instr_is_far_cti </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structinstr__t.html">instr_t</a> *&nbsp;</td>
          <td class="paramname"> <em>instr</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Returns true iff <code>instr</code> is a far control transfer instruction: OP_jmp_far, OP_call_far, OP_jmp_far_ind, OP_call_far_ind, OP_ret_far, or OP_iret. </p>

</div>
</div>
<a class="anchor" id="a81cdb64c78235caf707130680d1f156d"></a><!-- doxytag: member="dr_ir_instr.h::instr_is_floating" ref="a81cdb64c78235caf707130680d1f156d" args="(instr_t *instr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool instr_is_floating </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structinstr__t.html">instr_t</a> *&nbsp;</td>
          <td class="paramname"> <em>instr</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Returns true iff <code>instr</code> is a floating point instruction. </p>

</div>
</div>
<a class="anchor" id="aa21d0c15479e3a0ee88a7ec06fe9eb22"></a><!-- doxytag: member="dr_ir_instr.h::instr_is_interrupt" ref="aa21d0c15479e3a0ee88a7ec06fe9eb22" args="(instr_t *instr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool instr_is_interrupt </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structinstr__t.html">instr_t</a> *&nbsp;</td>
          <td class="paramname"> <em>instr</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return true iff <code>instr's</code> opcode is OP_int, OP_into, or OP_int3. </p>

</div>
</div>
<a class="anchor" id="ae61355d1ac416d4f04ed286eebc7c251"></a><!-- doxytag: member="dr_ir_instr.h::instr_is_label" ref="ae61355d1ac416d4f04ed286eebc7c251" args="(instr_t *instr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool instr_is_label </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structinstr__t.html">instr_t</a> *&nbsp;</td>
          <td class="paramname"> <em>instr</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Returns true iff <code>instr</code> is a label meta-instruction. </p>

</div>
</div>
<a class="anchor" id="a963ac2677038071fc295b3b6eb45ce1d"></a><!-- doxytag: member="dr_ir_instr.h::instr_is_mbr" ref="a963ac2677038071fc295b3b6eb45ce1d" args="(instr_t *instr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool instr_is_mbr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structinstr__t.html">instr_t</a> *&nbsp;</td>
          <td class="paramname"> <em>instr</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Returns true iff <code>instr</code> is a multi-way (indirect) branch: OP_jmp_ind, OP_call_ind, OP_ret, OP_jmp_far_ind, OP_call_far_ind, OP_ret_far, or OP_iret. </p>

</div>
</div>
<a class="anchor" id="a954715b40fa2668d7cde0c4a1bf47e51"></a><!-- doxytag: member="dr_ir_instr.h::instr_is_meta_may_fault" ref="a954715b40fa2668d7cde0c4a1bf47e51" args="(instr_t *instr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool instr_is_meta_may_fault </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structinstr__t.html">instr_t</a> *&nbsp;</td>
          <td class="paramname"> <em>instr</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return true iff <code>instr</code> is not a meta-instruction that can fault (see <a class="el" href="dr__ir__instr_8h.html#a94227a193446d370f0180e6a844be0c2">instr_set_meta_may_fault()</a> for more information).</p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000001">Deprecated:</a></b></dt><dd>Any meta instruction can fault if it has a non-NULL translation field and the client fully handles all of its faults, so this routine is no longer needed. </dd></dl>

</div>
</div>
<a class="anchor" id="a5e297cd513cbde904d0e09b721f1e9c1"></a><!-- doxytag: member="dr_ir_instr.h::instr_is_mmx" ref="a5e297cd513cbde904d0e09b721f1e9c1" args="(instr_t *instr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool instr_is_mmx </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structinstr__t.html">instr_t</a> *&nbsp;</td>
          <td class="paramname"> <em>instr</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Returns true iff <code>instr</code> is part of Intel's MMX instructions. </p>

</div>
</div>
<a class="anchor" id="a8b39dade5681d6135379a5d53fe57512"></a><!-- doxytag: member="dr_ir_instr.h::instr_is_mov" ref="a8b39dade5681d6135379a5d53fe57512" args="(instr_t *instr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool instr_is_mov </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structinstr__t.html">instr_t</a> *&nbsp;</td>
          <td class="paramname"> <em>instr</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Returns true iff <code>instr</code> is an IA-32 "mov" instruction: either OP_mov_st, OP_mov_ld, OP_mov_imm, OP_mov_seg, or OP_mov_priv. </p>

</div>
</div>
<a class="anchor" id="ac8da7990fa33f321134102323546516b"></a><!-- doxytag: member="dr_ir_instr.h::instr_is_mov_constant" ref="ac8da7990fa33f321134102323546516b" args="(instr_t *instr, ptr_int_t *value)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool instr_is_mov_constant </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structinstr__t.html">instr_t</a> *&nbsp;</td>
          <td class="paramname"> <em>instr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ptr_int_t *&nbsp;</td>
          <td class="paramname"> <em>value</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Tries to identify common cases of moving a constant into either a register or a memory address. Returns true and sets <code>*value</code> to the constant being moved for the following cases: mov_imm, mov_st, and xor where the source equals the destination. </p>

</div>
</div>
<a class="anchor" id="a1cf18b53c422fdb11efe7bdcc596aea2"></a><!-- doxytag: member="dr_ir_instr.h::instr_is_mov_imm_to_tos" ref="a1cf18b53c422fdb11efe7bdcc596aea2" args="(instr_t *instr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool instr_is_mov_imm_to_tos </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structinstr__t.html">instr_t</a> *&nbsp;</td>
          <td class="paramname"> <em>instr</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Returns true iff <code>instr</code> is a "mov $imm -&gt; (%esp)". </p>

</div>
</div>
<a class="anchor" id="acb2c91a7868ad6a8e5c47af985edde61"></a><!-- doxytag: member="dr_ir_instr.h::instr_is_nop" ref="acb2c91a7868ad6a8e5c47af985edde61" args="(instr_t *instr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool instr_is_nop </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structinstr__t.html">instr_t</a> *&nbsp;</td>
          <td class="paramname"> <em>instr</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Returns true if <code>instr</code> is one of a class of common nops. currently checks:</p>
<ul>
<li>nop</li>
<li>nop reg/mem</li>
<li>xchg reg, reg</li>
<li>mov reg, reg</li>
<li>lea reg, (reg) </li>
</ul>

</div>
</div>
<a class="anchor" id="aa653a23cf2029fc4eeaf05eb7523849d"></a><!-- doxytag: member="dr_ir_instr.h::instr_is_prefetch" ref="aa653a23cf2029fc4eeaf05eb7523849d" args="(instr_t *instr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool instr_is_prefetch </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structinstr__t.html">instr_t</a> *&nbsp;</td>
          <td class="paramname"> <em>instr</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Returns true iff <code>instr</code> is a prefetch instruction: OP_prefetchnta, OP_prefetchnt0, OP_prefetchnt1, OP_prefetchnt2, OP_prefetch, or OP_prefetchw. </p>

</div>
</div>
<a class="anchor" id="ade184d50e1016f220a10f40a60a4f8ad"></a><!-- doxytag: member="dr_ir_instr.h::instr_is_return" ref="ade184d50e1016f220a10f40a60a4f8ad" args="(instr_t *instr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool instr_is_return </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structinstr__t.html">instr_t</a> *&nbsp;</td>
          <td class="paramname"> <em>instr</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Returns true iff <code>instr's</code> opcode is OP_ret, OP_ret_far, or OP_iret. </p>

</div>
</div>
<a class="anchor" id="a33bb11334437a3076fbb81c0493f6e7a"></a><!-- doxytag: member="dr_ir_instr.h::instr_is_sse_or_sse2" ref="a33bb11334437a3076fbb81c0493f6e7a" args="(instr_t *instr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool instr_is_sse_or_sse2 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structinstr__t.html">instr_t</a> *&nbsp;</td>
          <td class="paramname"> <em>instr</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Returns true iff <code>instr</code> is part of Intel's SSE or SSE2 instructions. </p>

</div>
</div>
<a class="anchor" id="a86d982227aea8aa8647694b35cc592b3"></a><!-- doxytag: member="dr_ir_instr.h::instr_is_syscall" ref="a86d982227aea8aa8647694b35cc592b3" args="(instr_t *instr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool instr_is_syscall </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structinstr__t.html">instr_t</a> *&nbsp;</td>
          <td class="paramname"> <em>instr</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Returns true iff <code>instr</code> is used to implement system calls: OP_int with a source operand of 0x80 on linux or 0x2e on windows, or OP_sysenter, or OP_syscall, or <a class="el" href="dr__ir__instr_8h.html#a4a4d5454f266483029bd88e5a17e398c">instr_is_wow64_syscall()</a> for WOW64. </p>

</div>
</div>
<a class="anchor" id="ac39c368adab3332628a34c1f48afc466"></a><!-- doxytag: member="dr_ir_instr.h::instr_is_ubr" ref="ac39c368adab3332628a34c1f48afc466" args="(instr_t *instr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool instr_is_ubr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structinstr__t.html">instr_t</a> *&nbsp;</td>
          <td class="paramname"> <em>instr</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Returns true iff <code>instr</code> is an unconditional direct branch: OP_jmp, OP_jmp_short, or OP_jmp_far. </p>

</div>
</div>
<a class="anchor" id="a465cc4935f184c4d224afbb9547a445c"></a><!-- doxytag: member="dr_ir_instr.h::instr_is_undefined" ref="a465cc4935f184c4d224afbb9547a445c" args="(instr_t *instr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool instr_is_undefined </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structinstr__t.html">instr_t</a> *&nbsp;</td>
          <td class="paramname"> <em>instr</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Returns true iff <code>instr</code> is an "undefined" instruction (ud2) </p>

</div>
</div>
<a class="anchor" id="a4a4d5454f266483029bd88e5a17e398c"></a><!-- doxytag: member="dr_ir_instr.h::instr_is_wow64_syscall" ref="a4a4d5454f266483029bd88e5a17e398c" args="(instr_t *instr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool instr_is_wow64_syscall </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structinstr__t.html">instr_t</a> *&nbsp;</td>
          <td class="paramname"> <em>instr</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Returns true iff <code>instr</code> is the indirect transfer from the 32-bit ntdll.dll to the wow64 system call emulation layer. This instruction will also return true for instr_is_syscall, as well as appear as an indirect call, so clients modifying indirect calls may want to avoid modifying this type.</p>
<dl class="note"><dt><b>Note:</b></dt><dd>Windows-only </dd></dl>

</div>
</div>
<a class="anchor" id="a79a9b2a0b21a18dbfd0a7a534204b92b"></a><!-- doxytag: member="dr_ir_instr.h::instr_jcc_taken" ref="a79a9b2a0b21a18dbfd0a7a534204b92b" args="(instr_t *instr, reg_t eflags)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool instr_jcc_taken </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structinstr__t.html">instr_t</a> *&nbsp;</td>
          <td class="paramname"> <em>instr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">reg_t&nbsp;</td>
          <td class="paramname"> <em>eflags</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Given <code>eflags</code>, returns whether or not the conditional branch, <code>instr</code>, would be taken. </p>

</div>
</div>
<a class="anchor" id="ace0e57a48576a4aac25b1554f6ebcbf7"></a><!-- doxytag: member="dr_ir_instr.h::instr_length" ref="ace0e57a48576a4aac25b1554f6ebcbf7" args="(void *drcontext, instr_t *instr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int instr_length </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>drcontext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structinstr__t.html">instr_t</a> *&nbsp;</td>
          <td class="paramname"> <em>instr</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Returns the length of <code>instr</code>. As a side effect, if instr_ok_to_mangle(instr) and <code>instr's</code> raw bits are invalid, encodes <code>instr</code> into bytes allocated with <a class="el" href="dr__ir__instr_8h.html#af7b33f34d4dd11993224b4fb10e136dc">instr_allocate_raw_bits()</a>, after which instr is marked as having valid raw bits. </p>

</div>
</div>
<a class="anchor" id="a8620fe9a0391247fcd9183e7cac291c3"></a><!-- doxytag: member="dr_ir_instr.h::instr_make_persistent" ref="a8620fe9a0391247fcd9183e7cac291c3" args="(void *drcontext, instr_t *instr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void instr_make_persistent </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>drcontext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structinstr__t.html">instr_t</a> *&nbsp;</td>
          <td class="paramname"> <em>instr</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Calling this function with <code>instr</code> makes it safe to keep the instruction around indefinitely when its raw bits point into the cache. The function allocates memory local to <code>instr</code> to hold a copy of the raw bits. If this was not done, the original raw bits could be deleted at some point. Making an instruction persistent is necessary if you want to keep it beyond returning from the call that produced the instruction. </p>

</div>
</div>
<a class="anchor" id="af679a00bb888cbb46ae266a8591997ea"></a><!-- doxytag: member="dr_ir_instr.h::instr_mem_usage" ref="af679a00bb888cbb46ae266a8591997ea" args="(instr_t *instr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int instr_mem_usage </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structinstr__t.html">instr_t</a> *&nbsp;</td>
          <td class="paramname"> <em>instr</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Returns number of bytes of heap used by <code>instr</code>. </p>

</div>
</div>
<a class="anchor" id="a67563b7baa993aa824ba1803562fc029"></a><!-- doxytag: member="dr_ir_instr.h::instr_memory_reference_size" ref="a67563b7baa993aa824ba1803562fc029" args="(instr_t *instr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint instr_memory_reference_size </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structinstr__t.html">instr_t</a> *&nbsp;</td>
          <td class="paramname"> <em>instr</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Calculates the size, in bytes, of the memory read or write of <code>instr</code>. If <code>instr</code> does not reference memory, or is invalid, returns 0. If <code>instr</code> is a repeated string instruction, considers only one iteration. </p>

</div>
</div>
<a class="anchor" id="adb8c87b75de66fe9fcdf3db864a08702"></a><!-- doxytag: member="dr_ir_instr.h::instr_needs_encoding" ref="adb8c87b75de66fe9fcdf3db864a08702" args="(instr_t *instr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool instr_needs_encoding </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structinstr__t.html">instr_t</a> *&nbsp;</td>
          <td class="paramname"> <em>instr</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Returns true iff <code>instr's</code> raw bits are not a valid encoding of <code>instr</code>. </p>

</div>
</div>
<a class="anchor" id="a40ea45c2072f0a3f0c521669723f56b8"></a><!-- doxytag: member="dr_ir_instr.h::instr_num_dsts" ref="a40ea45c2072f0a3f0c521669723f56b8" args="(instr_t *instr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int instr_num_dsts </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structinstr__t.html">instr_t</a> *&nbsp;</td>
          <td class="paramname"> <em>instr</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Returns the number of destination operands of <code>instr</code>. </p>

</div>
</div>
<a class="anchor" id="acb4ed1d87d7852bce1995be6a940a9db"></a><!-- doxytag: member="dr_ir_instr.h::instr_num_srcs" ref="acb4ed1d87d7852bce1995be6a940a9db" args="(instr_t *instr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int instr_num_srcs </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structinstr__t.html">instr_t</a> *&nbsp;</td>
          <td class="paramname"> <em>instr</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Returns the number of source operands of <code>instr</code>.</p>
<dl class="note"><dt><b>Note:</b></dt><dd>Addressing registers used in destination memory references (i.e., base, index, or segment registers) are not separately listed as source operands. </dd></dl>

</div>
</div>
<a class="anchor" id="a221092e79cb7fd9a701c2e260685a6dc"></a><!-- doxytag: member="dr_ir_instr.h::instr_ok_to_emit" ref="a221092e79cb7fd9a701c2e260685a6dc" args="(instr_t *instr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool instr_ok_to_emit </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structinstr__t.html">instr_t</a> *&nbsp;</td>
          <td class="paramname"> <em>instr</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return true iff <code>instr</code> is to be emitted into the cache. </p>

</div>
</div>
<a class="anchor" id="a7b0251c70b4ab2a46801eeb49f1b8fda"></a><!-- doxytag: member="dr_ir_instr.h::instr_ok_to_mangle" ref="a7b0251c70b4ab2a46801eeb49f1b8fda" args="(instr_t *instr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool instr_ok_to_mangle </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structinstr__t.html">instr_t</a> *&nbsp;</td>
          <td class="paramname"> <em>instr</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return true iff <code>instr</code> is not a meta-instruction (see <a class="el" href="dr__ir__instr_8h.html#a2335bd8d05936e8308506ef11f1be401">instr_set_ok_to_mangle()</a> for more information). </p>

</div>
</div>
<a class="anchor" id="afeaf6ea858ca81c8b9968e4be43749f6"></a><!-- doxytag: member="dr_ir_instr.h::instr_opcode_valid" ref="afeaf6ea858ca81c8b9968e4be43749f6" args="(instr_t *instr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool instr_opcode_valid </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structinstr__t.html">instr_t</a> *&nbsp;</td>
          <td class="paramname"> <em>instr</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Returns true iff <code>instr's</code> opcode is valid. If the opcode is ever set to other than OP_INVALID or OP_UNDECODED it is assumed to be valid. However, calling <a class="el" href="dr__ir__instr_8h.html#a90d36984352b073089da3c91b901c853">instr_get_opcode()</a> will attempt to decode a valid opcode, hence the purpose of this routine. </p>

</div>
</div>
<a class="anchor" id="a9c820f4c4b82638289cca3c40f1d15c0"></a><!-- doxytag: member="dr_ir_instr.h::instr_operands_valid" ref="a9c820f4c4b82638289cca3c40f1d15c0" args="(instr_t *instr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool instr_operands_valid </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structinstr__t.html">instr_t</a> *&nbsp;</td>
          <td class="paramname"> <em>instr</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Returns true iff <code>instr's</code> operands are up to date. </p>

</div>
</div>
<a class="anchor" id="af08de27201e4c64a655e309b47d096c4"></a><!-- doxytag: member="dr_ir_instr.h::instr_raw_bits_valid" ref="af08de27201e4c64a655e309b47d096c4" args="(instr_t *instr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool instr_raw_bits_valid </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structinstr__t.html">instr_t</a> *&nbsp;</td>
          <td class="paramname"> <em>instr</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Returns true iff <code>instr's</code> raw bits are a valid encoding of instr. </p>

</div>
</div>
<a class="anchor" id="a5229b3775a4b2cdaa9aa257a27a0be1a"></a><!-- doxytag: member="dr_ir_instr.h::instr_reads_from_reg" ref="a5229b3775a4b2cdaa9aa257a27a0be1a" args="(instr_t *instr, reg_id_t reg)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool instr_reads_from_reg </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structinstr__t.html">instr_t</a> *&nbsp;</td>
          <td class="paramname"> <em>instr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">reg_id_t&nbsp;</td>
          <td class="paramname"> <em>reg</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Assumes that reg is a DR_REG_ constant. Returns true iff at least one of instr's operands reads from a register that overlaps reg (checks both source operands and addressing registers used in destination operands).</p>
<p>Returns false for multi-byte nops with an operand using reg. </p>

</div>
</div>
<a class="anchor" id="ae408fe229bea0aa800cddb6b911c0e94"></a><!-- doxytag: member="dr_ir_instr.h::instr_reads_memory" ref="ae408fe229bea0aa800cddb6b911c0e94" args="(instr_t *instr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool instr_reads_memory </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structinstr__t.html">instr_t</a> *&nbsp;</td>
          <td class="paramname"> <em>instr</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Returns true iff any of <code>instr's</code> source operands is a memory reference.</p>
<p>Returns false for multi-byte nops with a memory operand. </p>

</div>
</div>
<a class="anchor" id="a7e0752a69bd5b0331f8e98512ec15c2b"></a><!-- doxytag: member="dr_ir_instr.h::instr_reg_in_dst" ref="a7e0752a69bd5b0331f8e98512ec15c2b" args="(instr_t *instr, reg_id_t reg)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool instr_reg_in_dst </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structinstr__t.html">instr_t</a> *&nbsp;</td>
          <td class="paramname"> <em>instr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">reg_id_t&nbsp;</td>
          <td class="paramname"> <em>reg</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Assumes that <code>reg</code> is a DR_REG_ constant. Returns true iff at least one of <code>instr's</code> destination operands references <code>reg</code>. </p>

</div>
</div>
<a class="anchor" id="ae1092dee2d8367ca2fec50cba5e632d0"></a><!-- doxytag: member="dr_ir_instr.h::instr_reg_in_src" ref="ae1092dee2d8367ca2fec50cba5e632d0" args="(instr_t *instr, reg_id_t reg)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool instr_reg_in_src </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structinstr__t.html">instr_t</a> *&nbsp;</td>
          <td class="paramname"> <em>instr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">reg_id_t&nbsp;</td>
          <td class="paramname"> <em>reg</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Assumes that <code>reg</code> is a DR_REG_ constant. Returns true iff at least one of <code>instr's</code> source operands references <code>reg</code>.</p>
<p>Returns false for multi-byte nops with a source operand using reg.</p>
<dl class="note"><dt><b>Note:</b></dt><dd>Use <a class="el" href="dr__ir__instr_8h.html#a5229b3775a4b2cdaa9aa257a27a0be1a">instr_reads_from_reg()</a> to also consider addressing registers in destination operands. </dd></dl>

</div>
</div>
<a class="anchor" id="a7ff0a9b43777e95bf6932260f4b5cc09"></a><!-- doxytag: member="dr_ir_instr.h::instr_replace_src_opnd" ref="a7ff0a9b43777e95bf6932260f4b5cc09" args="(instr_t *instr, opnd_t old_opnd, opnd_t new_opnd)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool instr_replace_src_opnd </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structinstr__t.html">instr_t</a> *&nbsp;</td>
          <td class="paramname"> <em>instr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structopnd__t.html">opnd_t</a>&nbsp;</td>
          <td class="paramname"> <em>old_opnd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structopnd__t.html">opnd_t</a>&nbsp;</td>
          <td class="paramname"> <em>new_opnd</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Replaces all instances of <code>old_opnd</code> in <code>instr's</code> source operands with <code>new_opnd</code> (uses <a class="el" href="dr__ir__opnd_8h.html#adabfafe5e90003ff8e05775beef1f283">opnd_same()</a> to detect sameness). </p>

</div>
</div>
<a class="anchor" id="accd2bdee07d2e6ca0be3b252bc7b913f"></a><!-- doxytag: member="dr_ir_instr.h::instr_reset" ref="accd2bdee07d2e6ca0be3b252bc7b913f" args="(void *drcontext, instr_t *instr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void instr_reset </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>drcontext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structinstr__t.html">instr_t</a> *&nbsp;</td>
          <td class="paramname"> <em>instr</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Performs both <a class="el" href="dr__ir__instr_8h.html#ae0f3cc7fb91265cb6c8eb15a84184c1f">instr_free()</a> and <a class="el" href="dr__ir__instr_8h.html#a77b55daa2b3780d2c07e33b8330b2f62">instr_init()</a>. <code>instr</code> must have been initialized. </p>

</div>
</div>
<a class="anchor" id="ab9b44a1db49dc5cd8da8b6b27fa47d50"></a><!-- doxytag: member="dr_ir_instr.h::instr_reuse" ref="ab9b44a1db49dc5cd8da8b6b27fa47d50" args="(void *drcontext, instr_t *instr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void instr_reuse </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>drcontext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structinstr__t.html">instr_t</a> *&nbsp;</td>
          <td class="paramname"> <em>instr</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Frees all dynamically allocated storage that was allocated by <code>instr</code>, except for allocated bits. Also zeroes out <code>instr's</code> fields, except for raw bit fields, whether <code>instr</code> is <a class="el" href="dr__ir__instr_8h.html#a7b0251c70b4ab2a46801eeb49f1b8fda">instr_ok_to_mangle()</a>, and the x86 mode of <code>instr</code>. <code>instr</code> must have been initialized. </p>

</div>
</div>
<a class="anchor" id="a9e75c7fe47cb20acfae6bca1cd4bd2e0"></a><!-- doxytag: member="dr_ir_instr.h::instr_same" ref="a9e75c7fe47cb20acfae6bca1cd4bd2e0" args="(instr_t *instr1, instr_t *instr2)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool instr_same </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structinstr__t.html">instr_t</a> *&nbsp;</td>
          <td class="paramname"> <em>instr1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structinstr__t.html">instr_t</a> *&nbsp;</td>
          <td class="paramname"> <em>instr2</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Returns true iff <code>instr1</code> and <code>instr2</code> have the same opcode, prefixes, and source and destination operands (uses <a class="el" href="dr__ir__opnd_8h.html#adabfafe5e90003ff8e05775beef1f283">opnd_same()</a> to compare the operands). </p>

</div>
</div>
<a class="anchor" id="a1429cf1d1da8156898fde712e59e86db"></a><!-- doxytag: member="dr_ir_instr.h::instr_set_branch_target_pc" ref="a1429cf1d1da8156898fde712e59e86db" args="(instr_t *cti_instr, app_pc pc)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void instr_set_branch_target_pc </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structinstr__t.html">instr_t</a> *&nbsp;</td>
          <td class="paramname"> <em>cti_instr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">app_pc&nbsp;</td>
          <td class="paramname"> <em>pc</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Set the taken target pc of the (direct branch) instruction. </p>

</div>
</div>
<a class="anchor" id="a8e843e39613655f6a5c49e081fe593c2"></a><!-- doxytag: member="dr_ir_instr.h::instr_set_dst" ref="a8e843e39613655f6a5c49e081fe593c2" args="(instr_t *instr, uint pos, opnd_t opnd)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void instr_set_dst </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structinstr__t.html">instr_t</a> *&nbsp;</td>
          <td class="paramname"> <em>instr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&nbsp;</td>
          <td class="paramname"> <em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structopnd__t.html">opnd_t</a>&nbsp;</td>
          <td class="paramname"> <em>opnd</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Sets <code>instr's</code> destination operand at position <code>pos</code> to be <code>opnd</code>. Also calls instr_set_raw_bits_valid(<code>instr</code>, false) and instr_set_operands_valid(<code>instr</code>, true). </p>

</div>
</div>
<a class="anchor" id="a94227a193446d370f0180e6a844be0c2"></a><!-- doxytag: member="dr_ir_instr.h::instr_set_meta_may_fault" ref="a94227a193446d370f0180e6a844be0c2" args="(instr_t *instr, bool val)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void instr_set_meta_may_fault </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structinstr__t.html">instr_t</a> *&nbsp;</td>
          <td class="paramname"> <em>instr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>val</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000002">Deprecated:</a></b></dt><dd>Any meta instruction can fault if it has a non-NULL translation field and the client fully handles all of its faults, so this routine is no longer needed. </dd></dl>

</div>
</div>
<a class="anchor" id="a5206d055a5b06435bd5e919da40e8bd4"></a><!-- doxytag: member="dr_ir_instr.h::instr_set_meta_no_translation" ref="a5206d055a5b06435bd5e919da40e8bd4" args="(instr_t *instr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void instr_set_meta_no_translation </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structinstr__t.html">instr_t</a> *&nbsp;</td>
          <td class="paramname"> <em>instr</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>A convenience routine that calls both <a class="el" href="dr__ir__instr_8h.html#a2335bd8d05936e8308506ef11f1be401">instr_set_ok_to_mangle</a> (instr, false) and <a class="el" href="dr__ir__instr_8h.html#af1beda2d570ba04d74ca9cbd7c31bb1d">instr_set_translation</a> (instr, NULL). </p>

</div>
</div>
<a class="anchor" id="ab0528e8567588400c3941b38b77f05af"></a><!-- doxytag: member="dr_ir_instr.h::instr_set_next" ref="ab0528e8567588400c3941b38b77f05af" args="(instr_t *instr, instr_t *next)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void instr_set_next </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structinstr__t.html">instr_t</a> *&nbsp;</td>
          <td class="paramname"> <em>instr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structinstr__t.html">instr_t</a> *&nbsp;</td>
          <td class="paramname"> <em>next</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Sets the next field of <code>instr</code> to point to <code>next</code>. </p>

</div>
</div>
<a class="anchor" id="aba91124bada4c62004f5837c0d52af83"></a><!-- doxytag: member="dr_ir_instr.h::instr_set_note" ref="aba91124bada4c62004f5837c0d52af83" args="(instr_t *instr, void *value)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void instr_set_note </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structinstr__t.html">instr_t</a> *&nbsp;</td>
          <td class="paramname"> <em>instr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>value</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Sets the user-controlled note field in <code>instr</code> to <code>value</code>. </p>

</div>
</div>
<a class="anchor" id="aee0d80a8e69e8f0abe867f1903a107ea"></a><!-- doxytag: member="dr_ir_instr.h::instr_set_num_opnds" ref="aee0d80a8e69e8f0abe867f1903a107ea" args="(void *drcontext, instr_t *instr, int num_dsts, int num_srcs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void instr_set_num_opnds </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>drcontext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structinstr__t.html">instr_t</a> *&nbsp;</td>
          <td class="paramname"> <em>instr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>num_dsts</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>num_srcs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Assumes that <code>instr</code> has been initialized but does not have any operands yet. Allocates storage for <code>num_srcs</code> source operands and <code>num_dsts</code> destination operands. </p>

</div>
</div>
<a class="anchor" id="ae34605a2cff286d358941be6aa91788d"></a><!-- doxytag: member="dr_ir_instr.h::instr_set_ok_to_emit" ref="ae34605a2cff286d358941be6aa91788d" args="(instr_t *instr, bool val)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void instr_set_ok_to_emit </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structinstr__t.html">instr_t</a> *&nbsp;</td>
          <td class="paramname"> <em>instr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>val</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Set <code>instr</code> to "ok to emit" if <code>val</code> is true and "not ok to emit" if <code>val</code> is false. An instruction that should not be emitted is treated normally by DR for purposes of exits but is not placed into the cache. It is used for final jumps that are to be elided. </p>

</div>
</div>
<a class="anchor" id="a2335bd8d05936e8308506ef11f1be401"></a><!-- doxytag: member="dr_ir_instr.h::instr_set_ok_to_mangle" ref="a2335bd8d05936e8308506ef11f1be401" args="(instr_t *instr, bool val)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void instr_set_ok_to_mangle </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structinstr__t.html">instr_t</a> *&nbsp;</td>
          <td class="paramname"> <em>instr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>val</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Sets <code>instr</code> to "ok to mangle" if <code>val</code> is true and "not ok to
 mangle" if <code>val</code> is false. An instruction that is "not ok to
 mangle" is treated by DR as a "meta-instruction", distinct from normal application instructions, and is not mangled in any way. This is necessary to have DR not create an exit stub for a direct jump. All non-meta instructions that are added to basic blocks or traces should have their translation fields set (via <a class="el" href="dr__ir__instr_8h.html#af1beda2d570ba04d74ca9cbd7c31bb1d">instr_set_translation()</a>, or the convenience routine <a class="el" href="dr__ir__instr_8h.html#a5206d055a5b06435bd5e919da40e8bd4">instr_set_meta_no_translation()</a>) when recreating state at a fault; meta instructions should not fault (unless such faults are handled by the client) and are not considered application instructions but rather added instrumentation code (see <a class="el" href="dr__events_8h.html#a043a3588c4cf0c2d6838140fce530e72">dr_register_bb_event()</a> for further information on recreating). </p>

</div>
</div>
<a class="anchor" id="a5e1efc53088af35fa0ed6eefd80af5dd"></a><!-- doxytag: member="dr_ir_instr.h::instr_set_opcode" ref="a5e1efc53088af35fa0ed6eefd80af5dd" args="(instr_t *instr, int opcode)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void instr_set_opcode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structinstr__t.html">instr_t</a> *&nbsp;</td>
          <td class="paramname"> <em>instr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>opcode</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Assumes <code>opcode</code> is an OP_ constant and sets it to be instr's opcode. </p>

</div>
</div>
<a class="anchor" id="ac8f4d5f068f69df848c0dd1cacebc90f"></a><!-- doxytag: member="dr_ir_instr.h::instr_set_operands_valid" ref="ac8f4d5f068f69df848c0dd1cacebc90f" args="(instr_t *instr, bool valid)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void instr_set_operands_valid </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structinstr__t.html">instr_t</a> *&nbsp;</td>
          <td class="paramname"> <em>instr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>valid</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Sets <code>instr's</code> operands to be valid if <code>valid</code> is true, invalid otherwise. </p>

</div>
</div>
<a class="anchor" id="a3948b6ce886753002699286061faef26"></a><!-- doxytag: member="dr_ir_instr.h::instr_set_prefix_flag" ref="a3948b6ce886753002699286061faef26" args="(instr_t *instr, uint prefix)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structinstr__t.html">instr_t</a>* instr_set_prefix_flag </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structinstr__t.html">instr_t</a> *&nbsp;</td>
          <td class="paramname"> <em>instr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&nbsp;</td>
          <td class="paramname"> <em>prefix</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Assumes that <code>prefix</code> is a PREFIX_ constant. Ors <code>instr's</code> prefixes with <code>prefix</code>. Returns the supplied instr (for easy chaining). </p>

</div>
</div>
<a class="anchor" id="a728084f128d0e98bb4f1a3e0e4089378"></a><!-- doxytag: member="dr_ir_instr.h::instr_set_prev" ref="a728084f128d0e98bb4f1a3e0e4089378" args="(instr_t *instr, instr_t *prev)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void instr_set_prev </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structinstr__t.html">instr_t</a> *&nbsp;</td>
          <td class="paramname"> <em>instr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structinstr__t.html">instr_t</a> *&nbsp;</td>
          <td class="paramname"> <em>prev</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Sets the prev field of <code>instr</code> to point to <code>prev</code>. </p>

</div>
</div>
<a class="anchor" id="a7b9c3a55529a9e5467851821fe53fdb2"></a><!-- doxytag: member="dr_ir_instr.h::instr_set_raw_bits" ref="a7b9c3a55529a9e5467851821fe53fdb2" args="(instr_t *instr, byte *addr, uint length)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void instr_set_raw_bits </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structinstr__t.html">instr_t</a> *&nbsp;</td>
          <td class="paramname"> <em>instr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">byte *&nbsp;</td>
          <td class="paramname"> <em>addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&nbsp;</td>
          <td class="paramname"> <em>length</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Assumes that <code>instr</code> does not currently have any raw bits allocated. Sets <code>instr's</code> raw bits to be <code>length</code> bytes starting at <code>addr</code>. Does not set the operands invalid. </p>

</div>
</div>
<a class="anchor" id="a76b3326d827b06a1d1d0bc3d20ba17a2"></a><!-- doxytag: member="dr_ir_instr.h::instr_set_raw_bits_valid" ref="a76b3326d827b06a1d1d0bc3d20ba17a2" args="(instr_t *instr, bool valid)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void instr_set_raw_bits_valid </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structinstr__t.html">instr_t</a> *&nbsp;</td>
          <td class="paramname"> <em>instr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>valid</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Sets <code>instr's</code> raw bits to be valid if <code>valid</code> is true, invalid otherwise. </p>

</div>
</div>
<a class="anchor" id="ad11045a1b7b7cbd2053048f028e5e687"></a><!-- doxytag: member="dr_ir_instr.h::instr_set_raw_byte" ref="ad11045a1b7b7cbd2053048f028e5e687" args="(instr_t *instr, uint pos, byte byte)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void instr_set_raw_byte </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structinstr__t.html">instr_t</a> *&nbsp;</td>
          <td class="paramname"> <em>instr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&nbsp;</td>
          <td class="paramname"> <em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">byte&nbsp;</td>
          <td class="paramname"> <em>byte</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Assumes that <code>instr's</code> raw bits are valid and allocated by <code>instr</code> and have &gt; <code>pos</code> bytes. Sets instr's raw byte at position <code>pos</code> (beginning with 0) to the value <code>byte</code>. </p>

</div>
</div>
<a class="anchor" id="a71fba42e58fa08ed1e0da9be2fbde4d4"></a><!-- doxytag: member="dr_ir_instr.h::instr_set_raw_bytes" ref="a71fba42e58fa08ed1e0da9be2fbde4d4" args="(instr_t *instr, byte *start, uint num_bytes)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void instr_set_raw_bytes </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structinstr__t.html">instr_t</a> *&nbsp;</td>
          <td class="paramname"> <em>instr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">byte *&nbsp;</td>
          <td class="paramname"> <em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&nbsp;</td>
          <td class="paramname"> <em>num_bytes</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Assumes that <code>instr's</code> raw bits are valid and allocated by <code>instr</code> and have &gt;= num_bytes bytes. Copies the <code>num_bytes</code> beginning at start to <code>instr's</code> raw bits. </p>

</div>
</div>
<a class="anchor" id="a22ea2d9c35a7b4fcf89e4d160314babb"></a><!-- doxytag: member="dr_ir_instr.h::instr_set_raw_word" ref="a22ea2d9c35a7b4fcf89e4d160314babb" args="(instr_t *instr, uint pos, uint word)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void instr_set_raw_word </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structinstr__t.html">instr_t</a> *&nbsp;</td>
          <td class="paramname"> <em>instr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&nbsp;</td>
          <td class="paramname"> <em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&nbsp;</td>
          <td class="paramname"> <em>word</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Assumes that <code>instr's</code> raw bits are valid and allocated by <code>instr</code> and have &gt; pos+3 bytes. Sets the 4 bytes beginning at position <code>pos</code> (0-based) to the value word. </p>

</div>
</div>
<a class="anchor" id="a96bfa15e2f3a95174e36c80c585a24e3"></a><!-- doxytag: member="dr_ir_instr.h::instr_set_src" ref="a96bfa15e2f3a95174e36c80c585a24e3" args="(instr_t *instr, uint pos, opnd_t opnd)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void instr_set_src </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structinstr__t.html">instr_t</a> *&nbsp;</td>
          <td class="paramname"> <em>instr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&nbsp;</td>
          <td class="paramname"> <em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structopnd__t.html">opnd_t</a>&nbsp;</td>
          <td class="paramname"> <em>opnd</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Sets <code>instr's</code> source operand at position <code>pos</code> to be <code>opnd</code>. Also calls instr_set_raw_bits_valid(<code>instr</code>, false) and instr_set_operands_valid(<code>instr</code>, true). </p>

</div>
</div>
<a class="anchor" id="adbf4b84b7a6b07e22af66b0aec7cacf5"></a><!-- doxytag: member="dr_ir_instr.h::instr_set_target" ref="adbf4b84b7a6b07e22af66b0aec7cacf5" args="(instr_t *cti_instr, opnd_t target)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void instr_set_target </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structinstr__t.html">instr_t</a> *&nbsp;</td>
          <td class="paramname"> <em>cti_instr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structopnd__t.html">opnd_t</a>&nbsp;</td>
          <td class="paramname"> <em>target</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Assumes that <code>cti_instr</code> is a control transfer instruction. Sets the first source operand of <code>cti_instr</code> to be <code>target</code>. Also calls instr_set_raw_bits_valid(<code>instr</code>, false) and instr_set_operands_valid(<code>instr</code>, true). </p>

</div>
</div>
<a class="anchor" id="af1beda2d570ba04d74ca9cbd7c31bb1d"></a><!-- doxytag: member="dr_ir_instr.h::instr_set_translation" ref="af1beda2d570ba04d74ca9cbd7c31bb1d" args="(instr_t *instr, app_pc addr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structinstr__t.html">instr_t</a>* instr_set_translation </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structinstr__t.html">instr_t</a> *&nbsp;</td>
          <td class="paramname"> <em>instr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">app_pc&nbsp;</td>
          <td class="paramname"> <em>addr</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Sets the translation pointer for <code>instr</code>, used to recreate the application address corresponding to this instruction. When adding or modifying instructions that are to be considered application instructions (i.e., non meta-instructions: see <a class="el" href="dr__ir__instr_8h.html#a7b0251c70b4ab2a46801eeb49f1b8fda">instr_ok_to_mangle</a>), the translation should always be set. Pick the application address that if executed will be equivalent to restarting <code>instr</code>. Currently the translation address must lie within the existing bounds of the containing code block. Returns the supplied <code>instr</code> (for easy chaining). Use <a class="el" href="dr__ir__instr_8h.html#a57dbc129ab88dfdcf49f1105eba394a7">instr_get_app_pc</a> to see the current value of the translation. </p>

</div>
</div>
<a class="anchor" id="a74814111812ff20b281f7350fb626746"></a><!-- doxytag: member="dr_ir_instr.h::instr_set_x86_mode" ref="a74814111812ff20b281f7350fb626746" args="(instr_t *instr, bool x86)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void instr_set_x86_mode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structinstr__t.html">instr_t</a> *&nbsp;</td>
          <td class="paramname"> <em>instr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>x86</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Each instruction stores whether it should be interpreted in 32-bit (x86) or 64-bit (x64) mode. This routine sets the mode for <code>instr</code>.</p>
<dl class="note"><dt><b>Note:</b></dt><dd>For 64-bit DR builds only. </dd></dl>

</div>
</div>
<a class="anchor" id="a2dba2c8ede2bb35a708bd8dba95d5746"></a><!-- doxytag: member="dr_ir_instr.h::instr_shrink_to_16_bits" ref="a2dba2c8ede2bb35a708bd8dba95d5746" args="(instr_t *instr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void instr_shrink_to_16_bits </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structinstr__t.html">instr_t</a> *&nbsp;</td>
          <td class="paramname"> <em>instr</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Shrinks all registers not used as addresses, and all immed integer and address sizes, to 16 bits. Does not shrink DR_REG_ESI or DR_REG_EDI used in string instructions. </p>

</div>
</div>
<a class="anchor" id="ae0db1cec99a6fff7dde7201a87ca8892"></a><!-- doxytag: member="dr_ir_instr.h::instr_shrink_to_32_bits" ref="ae0db1cec99a6fff7dde7201a87ca8892" args="(instr_t *instr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void instr_shrink_to_32_bits </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structinstr__t.html">instr_t</a> *&nbsp;</td>
          <td class="paramname"> <em>instr</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Shrinks all registers, including addresses, and all immed integer and address sizes, to 32 bits.</p>
<dl class="note"><dt><b>Note:</b></dt><dd>For 64-bit DR builds only. </dd></dl>

</div>
</div>
<a class="anchor" id="a9b828bdfc3723d5b05d7147cfc237397"></a><!-- doxytag: member="dr_ir_instr.h::instr_uses_fp_reg" ref="a9b828bdfc3723d5b05d7147cfc237397" args="(instr_t *instr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool instr_uses_fp_reg </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structinstr__t.html">instr_t</a> *&nbsp;</td>
          <td class="paramname"> <em>instr</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Returns true iff at least one of <code>instr's</code> operands references a floating point register. </p>

</div>
</div>
<a class="anchor" id="a15a3336a497835085cc0a7be3b010cf3"></a><!-- doxytag: member="dr_ir_instr.h::instr_uses_reg" ref="a15a3336a497835085cc0a7be3b010cf3" args="(instr_t *instr, reg_id_t reg)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool instr_uses_reg </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structinstr__t.html">instr_t</a> *&nbsp;</td>
          <td class="paramname"> <em>instr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">reg_id_t&nbsp;</td>
          <td class="paramname"> <em>reg</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Assumes that <code>reg</code> is a DR_REG_ constant. Returns true iff at least one of <code>instr's</code> operands references a register that overlaps <code>reg</code>.</p>
<p>Returns false for multi-byte nops with an operand using reg. </p>

</div>
</div>
<a class="anchor" id="a9890dc9d4dbc40589c974a0ff221db72"></a><!-- doxytag: member="dr_ir_instr.h::instr_valid" ref="a9890dc9d4dbc40589c974a0ff221db72" args="(instr_t *instr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool instr_valid </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structinstr__t.html">instr_t</a> *&nbsp;</td>
          <td class="paramname"> <em>instr</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Returns true iff <code>instr's</code> opcode is NOT OP_INVALID. Not to be confused with an invalid opcode, which can be OP_INVALID or OP_UNDECODED. OP_INVALID means an instruction with no valid fields: raw bits (may exist but do not correspond to a valid instr), opcode, eflags, or operands. It could be an uninitialized instruction or the result of decoding an invalid sequence of bytes. </p>

</div>
</div>
<a class="anchor" id="ae1aac8cef8bb6ab075238e38ad6888a9"></a><!-- doxytag: member="dr_ir_instr.h::instr_writes_memory" ref="ae1aac8cef8bb6ab075238e38ad6888a9" args="(instr_t *instr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool instr_writes_memory </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structinstr__t.html">instr_t</a> *&nbsp;</td>
          <td class="paramname"> <em>instr</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Returns true iff any of <code>instr's</code> destination operands is a memory reference. </p>

</div>
</div>
<a class="anchor" id="a2d5a8131ed782adc6f31471417b88da9"></a><!-- doxytag: member="dr_ir_instr.h::instr_writes_to_exact_reg" ref="a2d5a8131ed782adc6f31471417b88da9" args="(instr_t *instr, reg_id_t reg)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool instr_writes_to_exact_reg </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structinstr__t.html">instr_t</a> *&nbsp;</td>
          <td class="paramname"> <em>instr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">reg_id_t&nbsp;</td>
          <td class="paramname"> <em>reg</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Assumes that <code>reg</code> is a DR_REG_ constant. Returns true iff at least one of <code>instr's</code> destination operands is the same register (not enough to just overlap) as <code>reg</code>. </p>

</div>
</div>
<a class="anchor" id="a2b2d116d97b3cbb47895984077119cfa"></a><!-- doxytag: member="dr_ir_instr.h::instr_writes_to_reg" ref="a2b2d116d97b3cbb47895984077119cfa" args="(instr_t *instr, reg_id_t reg)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool instr_writes_to_reg </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structinstr__t.html">instr_t</a> *&nbsp;</td>
          <td class="paramname"> <em>instr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">reg_id_t&nbsp;</td>
          <td class="paramname"> <em>reg</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Assumes that <code>reg</code> is a DR_REG_ constant. Returns true iff at least one of <code>instr's</code> destination operands is a register operand for a register that overlaps <code>reg</code>. </p>

</div>
</div>
</div>
<hr size="1"><address style="text-align: center;"><small>
<img border=0 src="favicon.png"> &nbsp; DynamoRIO API version 3.2.0 --- Wed Mar 28 12:55:32 2012 
&nbsp; <img border=0 src="favicon.png">
</body>
</html>
