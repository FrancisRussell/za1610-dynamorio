<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>DynamoRIO API: Multi-Instrumentation Manager</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
<link rel="shortcut icon" type="image/x-icon" href="favicon.ico" />
</head><body>
<!-- Generated by Doxygen 1.6.3 -->
<div class="contents">
<h1>Multi-Instrumentation Manager</h1><table border="0" cellpadding="0" cellspacing="0">
<tr><td colspan="2"><h2>Data Structures</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct__drmgr__priority__t.html">_drmgr_priority_t</a></td></tr>
<tr><td colspan="2"><h2>Typedefs</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="dr__events_8h.html#a689518ac5d1ad136b13e03012702b209">dr_emit_flags_t</a>(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__drmgr.html#ga20cf573c904b2885a2b65d5d3db42847">drmgr_xform_cb_t</a> )(void *drcontext, void *tag, instrlist_t *bb, bool for_trace, bool translating)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="dr__events_8h.html#a689518ac5d1ad136b13e03012702b209">dr_emit_flags_t</a>(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__drmgr.html#ga01c9afbdf3843c508d1b4c486f2f4f19">drmgr_analysis_cb_t</a> )(void *drcontext, void *tag, instrlist_t *bb, bool for_trace, bool translating, OUT void **user_data)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="group__drmgr.html#ga01c9afbdf3843c508d1b4c486f2f4f19">drmgr_analysis_cb_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__drmgr.html#gacb8f7568c015abb3c26c78983bb7c533">drmgr_app2app_ex_cb_t</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="dr__events_8h.html#a689518ac5d1ad136b13e03012702b209">dr_emit_flags_t</a>(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__drmgr.html#ga434156c1ee1f2d695f8d897ede5afa50">drmgr_ilist_ex_cb_t</a> )(void *drcontext, void *tag, instrlist_t *bb, bool for_trace, bool translating, void *user_data)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="dr__events_8h.html#a689518ac5d1ad136b13e03012702b209">dr_emit_flags_t</a>(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__drmgr.html#ga17d7b1dae48792e4cc8b5b751850ac83">drmgr_insertion_cb_t</a> )(void *drcontext, void *tag, instrlist_t *bb, <a class="el" href="structinstr__t.html">instr_t</a> *inst, bool for_trace, bool translating, void *user_data)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="struct__drmgr__priority__t.html">_drmgr_priority_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__drmgr.html#ga85630d78f521678da499f26dc5cda5aa">drmgr_priority_t</a></td></tr>
<tr><td colspan="2"><h2>Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">DR_EXPORT bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__drmgr.html#ga07ab03a2182247922f756778d18bb3fd">drmgr_init</a> (void)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">DR_EXPORT void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__drmgr.html#ga1e27214f63289548497d25c9e628a5d7">drmgr_exit</a> (void)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">DR_EXPORT bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__drmgr.html#gae270eeb1ab24d4e05f8588b23822f45c">drmgr_register_bb_app2app_event</a> (<a class="el" href="group__drmgr.html#ga20cf573c904b2885a2b65d5d3db42847">drmgr_xform_cb_t</a> func, <a class="el" href="struct__drmgr__priority__t.html">drmgr_priority_t</a> *priority)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">DR_EXPORT bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__drmgr.html#ga22a83c67e54d71259e42b8e10abe62d6">drmgr_unregister_bb_app2app_event</a> (<a class="el" href="group__drmgr.html#ga20cf573c904b2885a2b65d5d3db42847">drmgr_xform_cb_t</a> func)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">DR_EXPORT bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__drmgr.html#ga83a5fc96944e10bd7356e0c492c93966">drmgr_register_bb_instrumentation_event</a> (<a class="el" href="group__drmgr.html#ga01c9afbdf3843c508d1b4c486f2f4f19">drmgr_analysis_cb_t</a> analysis_func, <a class="el" href="group__drmgr.html#ga17d7b1dae48792e4cc8b5b751850ac83">drmgr_insertion_cb_t</a> insertion_func, <a class="el" href="struct__drmgr__priority__t.html">drmgr_priority_t</a> *priority)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">DR_EXPORT bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__drmgr.html#gaff08fa96e523f613b7371835c5025422">drmgr_unregister_bb_instrumentation_event</a> (<a class="el" href="group__drmgr.html#ga01c9afbdf3843c508d1b4c486f2f4f19">drmgr_analysis_cb_t</a> func)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">DR_EXPORT bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__drmgr.html#ga2f1f4cb66a41c81a12a8b37ba96083de">drmgr_register_bb_instru2instru_event</a> (<a class="el" href="group__drmgr.html#ga20cf573c904b2885a2b65d5d3db42847">drmgr_xform_cb_t</a> func, <a class="el" href="struct__drmgr__priority__t.html">drmgr_priority_t</a> *priority)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">DR_EXPORT bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__drmgr.html#ga4c692eb44a082c09833d13ed85360814">drmgr_unregister_bb_instru2instru_event</a> (<a class="el" href="group__drmgr.html#ga20cf573c904b2885a2b65d5d3db42847">drmgr_xform_cb_t</a> func)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">DR_EXPORT bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__drmgr.html#ga26e4be9f62ffd954f2f95ba21ec92953">drmgr_register_bb_instrumentation_ex_event</a> (<a class="el" href="group__drmgr.html#gacb8f7568c015abb3c26c78983bb7c533">drmgr_app2app_ex_cb_t</a> app2app_func, <a class="el" href="group__drmgr.html#ga434156c1ee1f2d695f8d897ede5afa50">drmgr_ilist_ex_cb_t</a> analysis_func, <a class="el" href="group__drmgr.html#ga17d7b1dae48792e4cc8b5b751850ac83">drmgr_insertion_cb_t</a> insertion_func, <a class="el" href="group__drmgr.html#ga434156c1ee1f2d695f8d897ede5afa50">drmgr_ilist_ex_cb_t</a> instru2instru_func, <a class="el" href="struct__drmgr__priority__t.html">drmgr_priority_t</a> *priority)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">DR_EXPORT bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__drmgr.html#ga6980f5fdc8f1f74ecaca53d0ef49c16a">drmgr_unregister_bb_instrumentation_ex_event</a> (<a class="el" href="group__drmgr.html#gacb8f7568c015abb3c26c78983bb7c533">drmgr_app2app_ex_cb_t</a> app2app_func, <a class="el" href="group__drmgr.html#ga434156c1ee1f2d695f8d897ede5afa50">drmgr_ilist_ex_cb_t</a> analysis_func, <a class="el" href="group__drmgr.html#ga17d7b1dae48792e4cc8b5b751850ac83">drmgr_insertion_cb_t</a> insertion_func, <a class="el" href="group__drmgr.html#ga434156c1ee1f2d695f8d897ede5afa50">drmgr_ilist_ex_cb_t</a> instru2instru_func)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">DR_EXPORT int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__drmgr.html#ga512b4290d94b1874537e5b604cb27cab">drmgr_register_tls_field</a> (void)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">DR_EXPORT bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__drmgr.html#ga0389d904f0e656f8a8777d850e6187f3">drmgr_unregister_tls_field</a> (int idx)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">DR_EXPORT void *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__drmgr.html#gade57b8de9ed73d579044aa8f12abfe8d">drmgr_get_tls_field</a> (void *drcontext, int idx)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">DR_EXPORT bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__drmgr.html#gac92542bc4f09040f3085079e68d60f66">drmgr_set_tls_field</a> (void *drcontext, int idx, void *value)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">DR_EXPORT bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__drmgr.html#ga7c72a35608998e6e359a3a652a7f97f7">drmgr_insert_read_tls_field</a> (void *drcontext, int idx, instrlist_t *ilist, <a class="el" href="structinstr__t.html">instr_t</a> *where, reg_id_t reg)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">DR_EXPORT bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__drmgr.html#ga65e2ae3d0f058fb069db7969e390c881">drmgr_insert_write_tls_field</a> (void *drcontext, int idx, instrlist_t *ilist, <a class="el" href="structinstr__t.html">instr_t</a> *where, reg_id_t reg, reg_id_t scratch)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">DR_EXPORT int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__drmgr.html#ga933ff32be874004447af771283d0bcee">drmgr_register_cls_field</a> (void(*cb_init_func)(void *drcontext, bool new_depth), void(*cb_exit_func)(void *drcontext, bool thread_exit))</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">DR_EXPORT bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__drmgr.html#gaab638b9a9480b505e6ae323ffb72bb1d">drmgr_unregister_cls_field</a> (void(*cb_init_func)(void *drcontext, bool new_depth), void(*cb_exit_func)(void *drcontext, bool thread_exit), int idx)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">DR_EXPORT void *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__drmgr.html#ga67585e915e3f9b555ea4382ed6027812">drmgr_get_cls_field</a> (void *drcontext, int idx)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">DR_EXPORT bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__drmgr.html#ga5d3bc85402a8909c862d9c06d415f138">drmgr_set_cls_field</a> (void *drcontext, int idx, void *value)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">DR_EXPORT bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__drmgr.html#gaba85528be6e0126b45a76245b6b4b001">drmgr_insert_read_cls_field</a> (void *drcontext, int idx, instrlist_t *ilist, <a class="el" href="structinstr__t.html">instr_t</a> *where, reg_id_t reg)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">DR_EXPORT bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__drmgr.html#gaa1d2757949d817bae787612177c00d85">drmgr_insert_write_cls_field</a> (void *drcontext, int idx, instrlist_t *ilist, <a class="el" href="structinstr__t.html">instr_t</a> *where, reg_id_t reg, reg_id_t scratch)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">DR_EXPORT bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__drmgr.html#gae2a70abba090ee410babc6a1548bb21d">drmgr_push_cls</a> (void *drcontext)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">DR_EXPORT bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__drmgr.html#ga4ac55faa0a4274ab5d8ac1cbd247b569">drmgr_pop_cls</a> (void *drcontext)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">DR_EXPORT ptr_uint_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__drmgr.html#ga057f980fa9323a0bb8a4226c7c52c14a">drmgr_reserve_note_range</a> (size_t size)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">DR_EXPORT int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__drmgr.html#ga357735ce7daa0bb717556455f20040a5">drmgr_decode_sysnum_from_wrapper</a> (app_pc entry)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">DR_EXPORT bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__drmgr.html#gaaac050cf70682f6fcb8e28aa942705cd">drmgr_register_thread_init_event</a> (void(*func)(void *drcontext))</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">DR_EXPORT bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__drmgr.html#ga835120bfe4726d59d13f8fbcd01fb264">drmgr_unregister_thread_init_event</a> (void(*func)(void *drcontext))</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">DR_EXPORT bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__drmgr.html#ga2d3e4b9d9e8cff8e8ec01ef44392cfdd">drmgr_register_thread_exit_event</a> (void(*func)(void *drcontext))</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">DR_EXPORT bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__drmgr.html#ga1a83a4ecf1b6172eab85e116aef96bea">drmgr_unregister_thread_exit_event</a> (void(*func)(void *drcontext))</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">DR_EXPORT bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__drmgr.html#gad4c1941a911a84b4f0ec60d2c37c6862">drmgr_register_pre_syscall_event</a> (bool(*func)(void *drcontext, int sysnum))</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">DR_EXPORT bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__drmgr.html#ga7b437d862c741e995a75dc2d59ed6e43">drmgr_unregister_pre_syscall_event</a> (bool(*func)(void *drcontext, int sysnum))</td></tr>
</table>
<hr/><h2>Typedef Documentation</h2>
<a class="anchor" id="ga01c9afbdf3843c508d1b4c486f2f4f19"></a><!-- doxytag: member="drmgr.h::drmgr_analysis_cb_t" ref="ga01c9afbdf3843c508d1b4c486f2f4f19" args=")(void *drcontext, void *tag, instrlist_t *bb, bool for_trace, bool translating, OUT void **user_data)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="dr__events_8h.html#a689518ac5d1ad136b13e03012702b209">dr_emit_flags_t</a>(* <a class="el" href="group__drmgr.html#ga01c9afbdf3843c508d1b4c486f2f4f19">drmgr_analysis_cb_t</a>)(void *drcontext, void *tag, instrlist_t *bb, bool for_trace, bool translating, OUT void **user_data)</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Callback function for the second stage: application analysis.</p>
<p>The <code>user_data</code> parameter can be used to pass data from this stage to the third stage.</p>
<p>See <a class="el" href="dr__events_8h.html#a689518ac5d1ad136b13e03012702b209">dr_emit_flags_t</a> for an explanation of the return value. If any instrumentation pass requests DR_EMIT_STORE_TRANSLATIONS, they will be stored. </p>

</div>
</div>
<a class="anchor" id="gacb8f7568c015abb3c26c78983bb7c533"></a><!-- doxytag: member="drmgr.h::drmgr_app2app_ex_cb_t" ref="gacb8f7568c015abb3c26c78983bb7c533" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="group__drmgr.html#ga01c9afbdf3843c508d1b4c486f2f4f19">drmgr_analysis_cb_t</a> <a class="el" href="group__drmgr.html#gacb8f7568c015abb3c26c78983bb7c533">drmgr_app2app_ex_cb_t</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Callback function for the first stage when using a user data parameter: app2app transformations on instruction list. </p>

</div>
</div>
<a class="anchor" id="ga434156c1ee1f2d695f8d897ede5afa50"></a><!-- doxytag: member="drmgr.h::drmgr_ilist_ex_cb_t" ref="ga434156c1ee1f2d695f8d897ede5afa50" args=")(void *drcontext, void *tag, instrlist_t *bb, bool for_trace, bool translating, void *user_data)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="dr__events_8h.html#a689518ac5d1ad136b13e03012702b209">dr_emit_flags_t</a>(* <a class="el" href="group__drmgr.html#ga434156c1ee1f2d695f8d897ede5afa50">drmgr_ilist_ex_cb_t</a>)(void *drcontext, void *tag, instrlist_t *bb, bool for_trace, bool translating, void *user_data)</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Callback function for the second and last stages when using a user data parameter for all four: analysis and instru2instru transformations on the whole instruction list.</p>
<p>See <a class="el" href="dr__events_8h.html#a689518ac5d1ad136b13e03012702b209">dr_emit_flags_t</a> for an explanation of the return value. If any instrumentation pass requests DR_EMIT_STORE_TRANSLATIONS, they will be stored. </p>

</div>
</div>
<a class="anchor" id="ga17d7b1dae48792e4cc8b5b751850ac83"></a><!-- doxytag: member="drmgr.h::drmgr_insertion_cb_t" ref="ga17d7b1dae48792e4cc8b5b751850ac83" args=")(void *drcontext, void *tag, instrlist_t *bb, instr_t *inst, bool for_trace, bool translating, void *user_data)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="dr__events_8h.html#a689518ac5d1ad136b13e03012702b209">dr_emit_flags_t</a>(* <a class="el" href="group__drmgr.html#ga17d7b1dae48792e4cc8b5b751850ac83">drmgr_insertion_cb_t</a>)(void *drcontext, void *tag, instrlist_t *bb, <a class="el" href="structinstr__t.html">instr_t</a> *inst, bool for_trace, bool translating, void *user_data)</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Callback function for the third stage: instrumentation insertion.</p>
<p>The <code>user_data</code> parameter contains data passed from the second stage to this stage.</p>
<p>See <a class="el" href="dr__events_8h.html#a689518ac5d1ad136b13e03012702b209">dr_emit_flags_t</a> for an explanation of the return value. If any instrumentation pass requests DR_EMIT_STORE_TRANSLATIONS, they will be stored. </p>

</div>
</div>
<a class="anchor" id="ga85630d78f521678da499f26dc5cda5aa"></a><!-- doxytag: member="drmgr.h::drmgr_priority_t" ref="ga85630d78f521678da499f26dc5cda5aa" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="struct__drmgr__priority__t.html">_drmgr_priority_t</a>  <a class="el" href="struct__drmgr__priority__t.html">drmgr_priority_t</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Specifies the ordering of callbacks for <code>drmgr's</code> events </p>

</div>
</div>
<a class="anchor" id="ga20cf573c904b2885a2b65d5d3db42847"></a><!-- doxytag: member="drmgr.h::drmgr_xform_cb_t" ref="ga20cf573c904b2885a2b65d5d3db42847" args=")(void *drcontext, void *tag, instrlist_t *bb, bool for_trace, bool translating)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="dr__events_8h.html#a689518ac5d1ad136b13e03012702b209">dr_emit_flags_t</a>(* <a class="el" href="group__drmgr.html#ga20cf573c904b2885a2b65d5d3db42847">drmgr_xform_cb_t</a>)(void *drcontext, void *tag, instrlist_t *bb, bool for_trace, bool translating)</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Callback function for the first and last stages: app2app and instru2instru transformations on the whole instruction list.</p>
<p>See <a class="el" href="dr__events_8h.html#a689518ac5d1ad136b13e03012702b209">dr_emit_flags_t</a> for an explanation of the return value. If any instrumentation pass requests DR_EMIT_STORE_TRANSLATIONS, they will be stored. </p>

</div>
</div>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="ga357735ce7daa0bb717556455f20040a5"></a><!-- doxytag: member="drmgr.h::drmgr_decode_sysnum_from_wrapper" ref="ga357735ce7daa0bb717556455f20040a5" args="(app_pc entry)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DR_EXPORT int drmgr_decode_sysnum_from_wrapper </td>
          <td>(</td>
          <td class="paramtype">app_pc&nbsp;</td>
          <td class="paramname"> <em>entry</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Given a system call wrapper routine <code>entry</code> of the Native API variety, decodes the routine and returns the system call number. </p>

</div>
</div>
<a class="anchor" id="ga1e27214f63289548497d25c9e628a5d7"></a><!-- doxytag: member="drmgr.h::drmgr_exit" ref="ga1e27214f63289548497d25c9e628a5d7" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DR_EXPORT void drmgr_exit </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Cleans up the drmgr extension. </p>

</div>
</div>
<a class="anchor" id="ga67585e915e3f9b555ea4382ed6027812"></a><!-- doxytag: member="drmgr.h::drmgr_get_cls_field" ref="ga67585e915e3f9b555ea4382ed6027812" args="(void *drcontext, int idx)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DR_EXPORT void* drmgr_get_cls_field </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>drcontext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>idx</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Returns the user-controlled callback-local-storage field for the given index, which was returned by <a class="el" href="group__drmgr.html#ga933ff32be874004447af771283d0bcee">drmgr_register_cls_field()</a>. To generate an instruction sequence that reads the drcontext field inline in the code cache, use <a class="el" href="group__drmgr.html#gaba85528be6e0126b45a76245b6b4b001">drmgr_insert_read_cls_field()</a>. </p>

</div>
</div>
<a class="anchor" id="gade57b8de9ed73d579044aa8f12abfe8d"></a><!-- doxytag: member="drmgr.h::drmgr_get_tls_field" ref="gade57b8de9ed73d579044aa8f12abfe8d" args="(void *drcontext, int idx)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DR_EXPORT void* drmgr_get_tls_field </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>drcontext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>idx</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Returns the user-controlled thread-local-storage field for the given index, which was returned by <a class="el" href="group__drmgr.html#ga512b4290d94b1874537e5b604cb27cab">drmgr_register_tls_field()</a>. To generate an instruction sequence that reads the drcontext field inline in the code cache, use <a class="el" href="group__drmgr.html#ga7c72a35608998e6e359a3a652a7f97f7">drmgr_insert_read_tls_field()</a>. </p>

</div>
</div>
<a class="anchor" id="ga07ab03a2182247922f756778d18bb3fd"></a><!-- doxytag: member="drmgr.h::drmgr_init" ref="ga07ab03a2182247922f756778d18bb3fd" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DR_EXPORT bool drmgr_init </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Initializes the drmgr extension. Must be called prior to any of the other routines, and should only be called once. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>whether successful. Will return false if called a second time. </dd></dl>

</div>
</div>
<a class="anchor" id="gaba85528be6e0126b45a76245b6b4b001"></a><!-- doxytag: member="drmgr.h::drmgr_insert_read_cls_field" ref="gaba85528be6e0126b45a76245b6b4b001" args="(void *drcontext, int idx, instrlist_t *ilist, instr_t *where, reg_id_t reg)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DR_EXPORT bool drmgr_insert_read_cls_field </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>drcontext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>idx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">instrlist_t *&nbsp;</td>
          <td class="paramname"> <em>ilist</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structinstr__t.html">instr_t</a> *&nbsp;</td>
          <td class="paramname"> <em>where</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">reg_id_t&nbsp;</td>
          <td class="paramname"> <em>reg</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Inserts into <code>ilist</code> prior to <code>where</code> meta-instruction(s) to read into the general-purpose full-size register <code>reg</code> from the user-controlled drcontext field for the current (at execution time) callback and index. Reads from the same field as <a class="el" href="group__drmgr.html#ga67585e915e3f9b555ea4382ed6027812">drmgr_get_cls_field()</a>. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>whether successful. </dd></dl>

</div>
</div>
<a class="anchor" id="ga7c72a35608998e6e359a3a652a7f97f7"></a><!-- doxytag: member="drmgr.h::drmgr_insert_read_tls_field" ref="ga7c72a35608998e6e359a3a652a7f97f7" args="(void *drcontext, int idx, instrlist_t *ilist, instr_t *where, reg_id_t reg)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DR_EXPORT bool drmgr_insert_read_tls_field </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>drcontext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>idx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">instrlist_t *&nbsp;</td>
          <td class="paramname"> <em>ilist</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structinstr__t.html">instr_t</a> *&nbsp;</td>
          <td class="paramname"> <em>where</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">reg_id_t&nbsp;</td>
          <td class="paramname"> <em>reg</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Inserts into <code>ilist</code> prior to <code>where</code> meta-instruction(s) to read into the general-purpose full-size register <code>reg</code> from the user-controlled drcontext field for this thread and index. Reads from the same field as <a class="el" href="group__drmgr.html#gade57b8de9ed73d579044aa8f12abfe8d">drmgr_get_tls_field()</a>. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>whether successful. </dd></dl>

</div>
</div>
<a class="anchor" id="gaa1d2757949d817bae787612177c00d85"></a><!-- doxytag: member="drmgr.h::drmgr_insert_write_cls_field" ref="gaa1d2757949d817bae787612177c00d85" args="(void *drcontext, int idx, instrlist_t *ilist, instr_t *where, reg_id_t reg, reg_id_t scratch)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DR_EXPORT bool drmgr_insert_write_cls_field </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>drcontext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>idx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">instrlist_t *&nbsp;</td>
          <td class="paramname"> <em>ilist</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structinstr__t.html">instr_t</a> *&nbsp;</td>
          <td class="paramname"> <em>where</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">reg_id_t&nbsp;</td>
          <td class="paramname"> <em>reg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">reg_id_t&nbsp;</td>
          <td class="paramname"> <em>scratch</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Inserts into <code>ilist</code> prior to <code>where</code> meta-instruction(s) to write the general-purpose full-size register <code>reg</code> to the user-controlled drcontext field for the current (at execution time) callback and index. Writes to the same field as <a class="el" href="group__drmgr.html#ga5d3bc85402a8909c862d9c06d415f138">drmgr_set_cls_field()</a>. The register <code>scratch</code> will be overwritten. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>whether successful. </dd></dl>

</div>
</div>
<a class="anchor" id="ga65e2ae3d0f058fb069db7969e390c881"></a><!-- doxytag: member="drmgr.h::drmgr_insert_write_tls_field" ref="ga65e2ae3d0f058fb069db7969e390c881" args="(void *drcontext, int idx, instrlist_t *ilist, instr_t *where, reg_id_t reg, reg_id_t scratch)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DR_EXPORT bool drmgr_insert_write_tls_field </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>drcontext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>idx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">instrlist_t *&nbsp;</td>
          <td class="paramname"> <em>ilist</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structinstr__t.html">instr_t</a> *&nbsp;</td>
          <td class="paramname"> <em>where</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">reg_id_t&nbsp;</td>
          <td class="paramname"> <em>reg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">reg_id_t&nbsp;</td>
          <td class="paramname"> <em>scratch</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Inserts into <code>ilist</code> prior to <code>where</code> meta-instruction(s) to write the general-purpose full-size register <code>reg</code> to the user-controlled drcontext field for this thread and index. Writes to the same field as <a class="el" href="group__drmgr.html#gac92542bc4f09040f3085079e68d60f66">drmgr_set_tls_field()</a>. The register <code>scratch</code> will be overwritten. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>whether successful. </dd></dl>

</div>
</div>
<a class="anchor" id="ga4ac55faa0a4274ab5d8ac1cbd247b569"></a><!-- doxytag: member="drmgr.h::drmgr_pop_cls" ref="ga4ac55faa0a4274ab5d8ac1cbd247b569" args="(void *drcontext)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DR_EXPORT bool drmgr_pop_cls </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>drcontext</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Pops a callback context from the callback-local storage (cls) context stack for the given thread. This function is automatically called on exit from a Windows callback. Users can invoke it to provide context stacks for their own uses, including Linux signals or layered wrapped functions. Invoking this function will trigger the <code>cb_exit_func</code> passed to <a class="el" href="group__drmgr.html#ga933ff32be874004447af771283d0bcee">drmgr_register_cls_field()</a>.</p>
<p>Returns false if the context stack has only one entry. </p>

</div>
</div>
<a class="anchor" id="gae2a70abba090ee410babc6a1548bb21d"></a><!-- doxytag: member="drmgr.h::drmgr_push_cls" ref="gae2a70abba090ee410babc6a1548bb21d" args="(void *drcontext)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DR_EXPORT bool drmgr_push_cls </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>drcontext</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Pushes a new callback context onto the callback-local storage (cls) context stack for the given thread. This function is automatically called on entry to a new Windows callback. Users can invoke it to provide context stacks for their own uses, including Linux signals or layered wrapped functions. Invoking this function will trigger the <code>cb_init_func</code> passed to <a class="el" href="group__drmgr.html#ga933ff32be874004447af771283d0bcee">drmgr_register_cls_field()</a>. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>whether successful. </dd></dl>

</div>
</div>
<a class="anchor" id="gae270eeb1ab24d4e05f8588b23822f45c"></a><!-- doxytag: member="drmgr.h::drmgr_register_bb_app2app_event" ref="gae270eeb1ab24d4e05f8588b23822f45c" args="(drmgr_xform_cb_t func, drmgr_priority_t *priority)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DR_EXPORT bool drmgr_register_bb_app2app_event </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__drmgr.html#ga20cf573c904b2885a2b65d5d3db42847">drmgr_xform_cb_t</a>&nbsp;</td>
          <td class="paramname"> <em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct__drmgr__priority__t.html">drmgr_priority_t</a> *&nbsp;</td>
          <td class="paramname"> <em>priority</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Registers a callback function for the first instrumentation stage: application-to-application ("app2app") transformations on each basic block. drmgr will call <code>func</code> as the first of four instrumentation stages for each dynamic application basic block. Examples of app2app transformations include replacing one function with another or replacing one instruction with another throughout an application.</p>
<p>The app2app passes are allowed to modify and insert non-meta (i.e., application) instructions and are intended for application code transformations. These passes should avoid adding meta instructions other than label instructions.</p>
<p>All instrumentation must follow the guidelines for <a class="el" href="dr__events_8h.html#a043a3588c4cf0c2d6838140fce530e72">dr_register_bb_event()</a> with the exception that multiple application control transfer instructions are supported so long as all but one have intra-block <code><a class="el" href="structinstr__t.html">instr_t</a></code> targets. This is to support internal control flow that may be necessary for some application-to-application transformations. These control transfer instructions should have a translation set so that later passes know which application address they correspond to. <code>drmgr</code> will mark all of the extra non-meta control transfers as meta, and clear their translation fields, right before passing to DynamoRIO, in order to satisfy DynamoRIO's constraints. This allows all of the instrumentation passes to see these instructions as application instructions, which is how they should be treated.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>false if the given priority request cannot be satisfied (e.g., <code>priority-&gt;before</code> is already ordered after <code>priority-&gt;after</code>) or the given name is already taken.</dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>func</em>&nbsp;</td><td>The callback to be called. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>priority</em>&nbsp;</td><td>Specifies the relative ordering of the callback. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga2f1f4cb66a41c81a12a8b37ba96083de"></a><!-- doxytag: member="drmgr.h::drmgr_register_bb_instru2instru_event" ref="ga2f1f4cb66a41c81a12a8b37ba96083de" args="(drmgr_xform_cb_t func, drmgr_priority_t *priority)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DR_EXPORT bool drmgr_register_bb_instru2instru_event </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__drmgr.html#ga20cf573c904b2885a2b65d5d3db42847">drmgr_xform_cb_t</a>&nbsp;</td>
          <td class="paramname"> <em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct__drmgr__priority__t.html">drmgr_priority_t</a> *&nbsp;</td>
          <td class="paramname"> <em>priority</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Registers a callback function for the fourth instrumentation stage: instrumentation-to-instrumentation transformations on each basic block. drmgr will call <code>func</code> as the fourth of four instrumentation stages for each dynamic application basic block. Instrumentation-to-instrumentation passes are allowed to insert meta instructions but not non-meta instructions, and are intended for optimization of prior instrumentation passes.</p>
<p>All instrumentation must follow the guidelines for <a class="el" href="dr__events_8h.html#a043a3588c4cf0c2d6838140fce530e72">dr_register_bb_event()</a>.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>false if the given priority request cannot be satisfied (e.g., <code>priority-&gt;before</code> is already ordered after <code>priority-&gt;after</code>) or the given name is already taken.</dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>func</em>&nbsp;</td><td>The callback to be called. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>priority</em>&nbsp;</td><td>Specifies the relative ordering of the callback. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga83a5fc96944e10bd7356e0c492c93966"></a><!-- doxytag: member="drmgr.h::drmgr_register_bb_instrumentation_event" ref="ga83a5fc96944e10bd7356e0c492c93966" args="(drmgr_analysis_cb_t analysis_func, drmgr_insertion_cb_t insertion_func, drmgr_priority_t *priority)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DR_EXPORT bool drmgr_register_bb_instrumentation_event </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__drmgr.html#ga01c9afbdf3843c508d1b4c486f2f4f19">drmgr_analysis_cb_t</a>&nbsp;</td>
          <td class="paramname"> <em>analysis_func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__drmgr.html#ga17d7b1dae48792e4cc8b5b751850ac83">drmgr_insertion_cb_t</a>&nbsp;</td>
          <td class="paramname"> <em>insertion_func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct__drmgr__priority__t.html">drmgr_priority_t</a> *&nbsp;</td>
          <td class="paramname"> <em>priority</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Registers callback functions for the second and third instrumentation stages: application analysis and instrumentation insertion. drmgr will call <code>func</code> as the second of four instrumentation stages for each dynamic application basic block.</p>
<p>The first stage performed any changes to the original application code, and later stages are not allowed to change application code. Application analysis passes in the second stage are not allowed to add to or change the instruction list other than adding label instructions, and are intended for analysis of application code either for immediate use or for use by the third stage. Label instructions can be used to store data for use in subsequent stages with custom tags inserted as notes via <a class="el" href="group__drmgr.html#ga057f980fa9323a0bb8a4226c7c52c14a">drmgr_reserve_note_range()</a> and custom data stored via <a class="el" href="dr__ir__instr_8h.html#a7eab5eaa85e186349d200a87e8010fec">instr_get_label_data_area()</a>.</p>
<p>The third instrumentation stage is instrumentation insertion. Unlike the other stages, this one passes only one instruction to the callback, allowing each registered component to act on one instruction before moving to the next instruction. Instrumentation insertion passes are allowed to insert meta instructions only immediately prior to the passed-in instruction: not before any prior non-meta instrution nor after any subsequent non-meta instruction. They are not allowed to insert new non-meta instructions or change existing non-meta instructions. Because other components may have alread acted on the instruction list, be sure to ignore already existing meta instructions.</p>
<p>The <code>analysis_func</code> and <code>insertion_func</code> share the same priority. Their user_data parameter can be used to pass data from the analysis stage to the insertion stage.</p>
<p>All instrumentation must follow the guidelines for <a class="el" href="dr__events_8h.html#a043a3588c4cf0c2d6838140fce530e72">dr_register_bb_event()</a>.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>false if the given priority request cannot be satisfied (e.g., <code>priority-&gt;before</code> is already ordered after <code>priority-&gt;after</code>) or the given name is already taken.</dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>analysis_func</em>&nbsp;</td><td>The analysis callback to be called for the second stage. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>insertion_func</em>&nbsp;</td><td>The insertion callback to be called for the third stage. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>priority</em>&nbsp;</td><td>Specifies the relative ordering of both callbacks. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga26e4be9f62ffd954f2f95ba21ec92953"></a><!-- doxytag: member="drmgr.h::drmgr_register_bb_instrumentation_ex_event" ref="ga26e4be9f62ffd954f2f95ba21ec92953" args="(drmgr_app2app_ex_cb_t app2app_func, drmgr_ilist_ex_cb_t analysis_func, drmgr_insertion_cb_t insertion_func, drmgr_ilist_ex_cb_t instru2instru_func, drmgr_priority_t *priority)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DR_EXPORT bool drmgr_register_bb_instrumentation_ex_event </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__drmgr.html#gacb8f7568c015abb3c26c78983bb7c533">drmgr_app2app_ex_cb_t</a>&nbsp;</td>
          <td class="paramname"> <em>app2app_func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__drmgr.html#ga434156c1ee1f2d695f8d897ede5afa50">drmgr_ilist_ex_cb_t</a>&nbsp;</td>
          <td class="paramname"> <em>analysis_func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__drmgr.html#ga17d7b1dae48792e4cc8b5b751850ac83">drmgr_insertion_cb_t</a>&nbsp;</td>
          <td class="paramname"> <em>insertion_func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__drmgr.html#ga434156c1ee1f2d695f8d897ede5afa50">drmgr_ilist_ex_cb_t</a>&nbsp;</td>
          <td class="paramname"> <em>instru2instru_func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct__drmgr__priority__t.html">drmgr_priority_t</a> *&nbsp;</td>
          <td class="paramname"> <em>priority</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Registers callbacks for all four instrumentation passes at once, with a <code>user_data</code> parameter passed among them all, enabling data sharing for all four. See the documentation for <a class="el" href="group__drmgr.html#gae270eeb1ab24d4e05f8588b23822f45c">drmgr_register_bb_app2app_event()</a>, <a class="el" href="group__drmgr.html#ga83a5fc96944e10bd7356e0c492c93966">drmgr_register_bb_instrumentation_event()</a>, and <a class="el" href="group__drmgr.html#ga2f1f4cb66a41c81a12a8b37ba96083de">drmgr_register_bb_instru2instru_event()</a> for further details of each pass. The aforemented routines are identical to this with the exception of the extra <code>user_data</code> parameter, which is an OUT parameter to the <code>app2app_func</code> and passed in to the three subsequent callbacks. </p>

</div>
</div>
<a class="anchor" id="ga933ff32be874004447af771283d0bcee"></a><!-- doxytag: member="drmgr.h::drmgr_register_cls_field" ref="ga933ff32be874004447af771283d0bcee" args="(void(*cb_init_func)(void *drcontext, bool new_depth), void(*cb_exit_func)(void *drcontext, bool thread_exit))" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DR_EXPORT int drmgr_register_cls_field </td>
          <td>(</td>
          <td class="paramtype">void(*)(void *drcontext, bool new_depth)&nbsp;</td>
          <td class="paramname"> <em>cb_init_func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(*)(void *drcontext, bool thread_exit)&nbsp;</td>
          <td class="paramname"> <em>cb_exit_func</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Reserves a callback-local storage (cls) slot. Thread-local storage (tls) is callback-shared. Callbacks interrupt thread execution to execute arbitrary amounts of code in a new context before returning to the interrupted context. Thread-local storage fields that persist across application execution can be overwritten during callback execution, resulting in incorrect values when returning to the original context. Callback-local storage, rather than thread-local storage, should be used for any fields that store information specific to the application's execution.</p>
<p>Returns the index of the slot, which should be passed to <a class="el" href="group__drmgr.html#ga67585e915e3f9b555ea4382ed6027812">drmgr_get_cls_field()</a> and <a class="el" href="group__drmgr.html#ga5d3bc85402a8909c862d9c06d415f138">drmgr_set_cls_field()</a>. Returns -1 if there are no more slots available.</p>
<p>Callbacks are frequent, but normally the stack of callback contexts is only a few entries deep. It is most efficient to re-use cls data from prior callbacks, only allocating new memory when entering a new context stack depth. The <code>cb_init_func</code> parameter is invoked on each new callback context, with <code>new_depth</code> set to true only when entering a new callback context stack depth. When <code>new_depth</code> is false, <a class="el" href="group__drmgr.html#ga67585e915e3f9b555ea4382ed6027812">drmgr_get_cls_field()</a> will return the value set at that depth the last time it was reached, and the client would normally not need to allocate memory but would only need to initialize it. When <code>new_depth</code> is true, <a class="el" href="group__drmgr.html#ga67585e915e3f9b555ea4382ed6027812">drmgr_get_cls_field()</a> will return NULL, and the user should use <a class="el" href="group__drmgr.html#ga5d3bc85402a8909c862d9c06d415f138">drmgr_set_cls_field()</a> to initialize the slot itself as well as whatever it points to.</p>
<p>Similarly, normal usage should ignore <code>cb_exit_func</code> unless it is called with <code>thread_exit</code> set to true, in which case any memory in the cls slot should be de-allocated.</p>
<p>Callbacks are Windows-specific. The cls interfaces are not marked for Windows-only, however, to facilitate cross-platform code. We recommend that cross-plaform code be written using cls fields on both platforms; the fields on Linux will never be stacked and will function as tls fields. Technically the same context interruption can occur with a Linux signal, but Linux signals typically execute small amounts of code and avoid making stateful changes; furthermore, there is no guaranteed end point to a signal. The <a class="el" href="group__drmgr.html#gae2a70abba090ee410babc6a1548bb21d">drmgr_push_cls()</a> and <a class="el" href="group__drmgr.html#ga4ac55faa0a4274ab5d8ac1cbd247b569">drmgr_pop_cls()</a> interface can be used to provide a stack of contexts on Linux, or to provide a stack of contexts for any other purpose such as layered wrapped functions. These push and pop functions are automatically called on Windows callback entry and exit. </p>

</div>
</div>
<a class="anchor" id="gad4c1941a911a84b4f0ec60d2c37c6862"></a><!-- doxytag: member="drmgr.h::drmgr_register_pre_syscall_event" ref="gad4c1941a911a84b4f0ec60d2c37c6862" args="(bool(*func)(void *drcontext, int sysnum))" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DR_EXPORT bool drmgr_register_pre_syscall_event </td>
          <td>(</td>
          <td class="paramtype">bool(*)(void *drcontext, int sysnum)&nbsp;</td>
          <td class="paramname"> <em>func</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Registers a callback function for the pre-syscall event, which behaves just like DR's pre-syscall event <a class="el" href="dr__events_8h.html#aa37d61a7f9dde4663b8dd4c3a44732f4">dr_register_pre_syscall_event()</a>. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>whether successful. </dd></dl>

</div>
</div>
<a class="anchor" id="ga2d3e4b9d9e8cff8e8ec01ef44392cfdd"></a><!-- doxytag: member="drmgr.h::drmgr_register_thread_exit_event" ref="ga2d3e4b9d9e8cff8e8ec01ef44392cfdd" args="(void(*func)(void *drcontext))" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DR_EXPORT bool drmgr_register_thread_exit_event </td>
          <td>(</td>
          <td class="paramtype">void(*)(void *drcontext)&nbsp;</td>
          <td class="paramname"> <em>func</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Registers a callback function for the thread exit event. drmgr calls <code>func</code> whenever DR would, when an application thread exits. All the constraints of <a class="el" href="dr__events_8h.html#a0b0c102bb9a99d67c3e62ea8b3790ff1">dr_register_thread_exit_event()</a> apply. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>whether successful. </dd></dl>

</div>
</div>
<a class="anchor" id="gaaac050cf70682f6fcb8e28aa942705cd"></a><!-- doxytag: member="drmgr.h::drmgr_register_thread_init_event" ref="gaaac050cf70682f6fcb8e28aa942705cd" args="(void(*func)(void *drcontext))" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DR_EXPORT bool drmgr_register_thread_init_event </td>
          <td>(</td>
          <td class="paramtype">void(*)(void *drcontext)&nbsp;</td>
          <td class="paramname"> <em>func</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Registers a callback function for the thread initialization event. drmgr calls <code>func</code> whenever the application creates a new thread. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>whether successful. </dd></dl>

</div>
</div>
<a class="anchor" id="ga512b4290d94b1874537e5b604cb27cab"></a><!-- doxytag: member="drmgr.h::drmgr_register_tls_field" ref="ga512b4290d94b1874537e5b604cb27cab" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DR_EXPORT int drmgr_register_tls_field </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Reserves a thread-local storage (tls) slot for every thread. Returns the index of the slot, which should be passed to <a class="el" href="group__drmgr.html#gade57b8de9ed73d579044aa8f12abfe8d">drmgr_get_tls_field()</a> and <a class="el" href="group__drmgr.html#gac92542bc4f09040f3085079e68d60f66">drmgr_set_tls_field()</a>. Returns -1 if there are no more slots available. Each slot is initialized to NULL for each thread and should be properly initialized with <a class="el" href="group__drmgr.html#gac92542bc4f09040f3085079e68d60f66">drmgr_set_tls_field()</a> in the thread initialization event (see <a class="el" href="dr__events_8h.html#a878920c40c76e2c18043f9db772a24c0">dr_register_thread_init_event()</a>). </p>

</div>
</div>
<a class="anchor" id="ga057f980fa9323a0bb8a4226c7c52c14a"></a><!-- doxytag: member="drmgr.h::drmgr_reserve_note_range" ref="ga057f980fa9323a0bb8a4226c7c52c14a" args="(size_t size)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DR_EXPORT ptr_uint_t drmgr_reserve_note_range </td>
          <td>(</td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>size</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Reserves <code>size</code> values in the namespace for use in the <code>note</code> field of instructions. The reserved range starts at the return value and is contiguous. Returns DRMGR_NOTE_NONE on failure. Un-reserving is not supported. </p>

</div>
</div>
<a class="anchor" id="ga5d3bc85402a8909c862d9c06d415f138"></a><!-- doxytag: member="drmgr.h::drmgr_set_cls_field" ref="ga5d3bc85402a8909c862d9c06d415f138" args="(void *drcontext, int idx, void *value)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DR_EXPORT bool drmgr_set_cls_field </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>drcontext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>idx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>value</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Sets the user-controlled callback-local-storage field for the given index, which was returned by <a class="el" href="group__drmgr.html#ga933ff32be874004447af771283d0bcee">drmgr_register_cls_field()</a>. To generate an instruction sequence that writes the drcontext field inline in the code cache, use <a class="el" href="group__drmgr.html#gaa1d2757949d817bae787612177c00d85">drmgr_insert_write_cls_field()</a>. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>whether successful. </dd></dl>

</div>
</div>
<a class="anchor" id="gac92542bc4f09040f3085079e68d60f66"></a><!-- doxytag: member="drmgr.h::drmgr_set_tls_field" ref="gac92542bc4f09040f3085079e68d60f66" args="(void *drcontext, int idx, void *value)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DR_EXPORT bool drmgr_set_tls_field </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>drcontext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>idx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>value</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Sets the user-controlled thread-local-storage field for the given index, which was returned by <a class="el" href="group__drmgr.html#ga512b4290d94b1874537e5b604cb27cab">drmgr_register_tls_field()</a>. To generate an instruction sequence that writes the drcontext field inline in the code cache, use <a class="el" href="group__drmgr.html#ga65e2ae3d0f058fb069db7969e390c881">drmgr_insert_write_tls_field()</a>. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>whether successful. </dd></dl>

</div>
</div>
<a class="anchor" id="ga22a83c67e54d71259e42b8e10abe62d6"></a><!-- doxytag: member="drmgr.h::drmgr_unregister_bb_app2app_event" ref="ga22a83c67e54d71259e42b8e10abe62d6" args="(drmgr_xform_cb_t func)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DR_EXPORT bool drmgr_unregister_bb_app2app_event </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__drmgr.html#ga20cf573c904b2885a2b65d5d3db42847">drmgr_xform_cb_t</a>&nbsp;</td>
          <td class="paramname"> <em>func</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Unregisters a callback function for the first instrumentation stage. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>true if unregistration is successful and false if it is not (e.g., <code>func</code> was not registered).</dd></dl>
<p>The recommendations for <a class="el" href="dr__events_8h.html#ac10e7ca1490fc450cab526c335693314">dr_unregister_bb_event()</a> about when it is safe to unregister apply here as well. </p>

</div>
</div>
<a class="anchor" id="ga4c692eb44a082c09833d13ed85360814"></a><!-- doxytag: member="drmgr.h::drmgr_unregister_bb_instru2instru_event" ref="ga4c692eb44a082c09833d13ed85360814" args="(drmgr_xform_cb_t func)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DR_EXPORT bool drmgr_unregister_bb_instru2instru_event </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__drmgr.html#ga20cf573c904b2885a2b65d5d3db42847">drmgr_xform_cb_t</a>&nbsp;</td>
          <td class="paramname"> <em>func</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Unregisters a callback function for the fourth instrumentation stage. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>true if unregistration is successful and false if it is not (e.g., <code>func</code> was not registered).</dd></dl>
<p>The recommendations for <a class="el" href="dr__events_8h.html#ac10e7ca1490fc450cab526c335693314">dr_unregister_bb_event()</a> about when it is safe to unregister apply here as well. </p>

</div>
</div>
<a class="anchor" id="gaff08fa96e523f613b7371835c5025422"></a><!-- doxytag: member="drmgr.h::drmgr_unregister_bb_instrumentation_event" ref="gaff08fa96e523f613b7371835c5025422" args="(drmgr_analysis_cb_t func)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DR_EXPORT bool drmgr_unregister_bb_instrumentation_event </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__drmgr.html#ga01c9afbdf3843c508d1b4c486f2f4f19">drmgr_analysis_cb_t</a>&nbsp;</td>
          <td class="paramname"> <em>func</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Unregisters <code>func</code> and its corresponding insertion callback from the second and third instrumentation stages. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>true if unregistration is successful and false if it is not (e.g., <code>func</code> was not registered).</dd></dl>
<p>The recommendations for <a class="el" href="dr__events_8h.html#ac10e7ca1490fc450cab526c335693314">dr_unregister_bb_event()</a> about when it is safe to unregister apply here as well. </p>

</div>
</div>
<a class="anchor" id="ga6980f5fdc8f1f74ecaca53d0ef49c16a"></a><!-- doxytag: member="drmgr.h::drmgr_unregister_bb_instrumentation_ex_event" ref="ga6980f5fdc8f1f74ecaca53d0ef49c16a" args="(drmgr_app2app_ex_cb_t app2app_func, drmgr_ilist_ex_cb_t analysis_func, drmgr_insertion_cb_t insertion_func, drmgr_ilist_ex_cb_t instru2instru_func)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DR_EXPORT bool drmgr_unregister_bb_instrumentation_ex_event </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__drmgr.html#gacb8f7568c015abb3c26c78983bb7c533">drmgr_app2app_ex_cb_t</a>&nbsp;</td>
          <td class="paramname"> <em>app2app_func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__drmgr.html#ga434156c1ee1f2d695f8d897ede5afa50">drmgr_ilist_ex_cb_t</a>&nbsp;</td>
          <td class="paramname"> <em>analysis_func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__drmgr.html#ga17d7b1dae48792e4cc8b5b751850ac83">drmgr_insertion_cb_t</a>&nbsp;</td>
          <td class="paramname"> <em>insertion_func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__drmgr.html#ga434156c1ee1f2d695f8d897ede5afa50">drmgr_ilist_ex_cb_t</a>&nbsp;</td>
          <td class="paramname"> <em>instru2instru_func</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Unregisters the given four callbacks that were registered via <a class="el" href="group__drmgr.html#ga26e4be9f62ffd954f2f95ba21ec92953">drmgr_register_bb_instrumentation_ex_event()</a>. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>true if unregistration is successful and false if it is not (e.g., <code>func</code> was not registered).</dd></dl>
<p>The recommendations for <a class="el" href="dr__events_8h.html#ac10e7ca1490fc450cab526c335693314">dr_unregister_bb_event()</a> about when it is safe to unregister apply here as well. </p>

</div>
</div>
<a class="anchor" id="gaab638b9a9480b505e6ae323ffb72bb1d"></a><!-- doxytag: member="drmgr.h::drmgr_unregister_cls_field" ref="gaab638b9a9480b505e6ae323ffb72bb1d" args="(void(*cb_init_func)(void *drcontext, bool new_depth), void(*cb_exit_func)(void *drcontext, bool thread_exit), int idx)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DR_EXPORT bool drmgr_unregister_cls_field </td>
          <td>(</td>
          <td class="paramtype">void(*)(void *drcontext, bool new_depth)&nbsp;</td>
          <td class="paramname"> <em>cb_init_func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(*)(void *drcontext, bool thread_exit)&nbsp;</td>
          <td class="paramname"> <em>cb_exit_func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>idx</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Frees a previously reserved callback-local storage (cls) slot index and unregisters its event callbacks. Returns false if the slot was not actually reserved. </p>

</div>
</div>
<a class="anchor" id="ga7b437d862c741e995a75dc2d59ed6e43"></a><!-- doxytag: member="drmgr.h::drmgr_unregister_pre_syscall_event" ref="ga7b437d862c741e995a75dc2d59ed6e43" args="(bool(*func)(void *drcontext, int sysnum))" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DR_EXPORT bool drmgr_unregister_pre_syscall_event </td>
          <td>(</td>
          <td class="paramtype">bool(*)(void *drcontext, int sysnum)&nbsp;</td>
          <td class="paramname"> <em>func</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Unregister a callback function for the pre-syscall event. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>true if unregistration is successful and false if it is not (e.g., <code>func</code> was not registered). </dd></dl>

</div>
</div>
<a class="anchor" id="ga1a83a4ecf1b6172eab85e116aef96bea"></a><!-- doxytag: member="drmgr.h::drmgr_unregister_thread_exit_event" ref="ga1a83a4ecf1b6172eab85e116aef96bea" args="(void(*func)(void *drcontext))" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DR_EXPORT bool drmgr_unregister_thread_exit_event </td>
          <td>(</td>
          <td class="paramtype">void(*)(void *drcontext)&nbsp;</td>
          <td class="paramname"> <em>func</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Unregister a callback function for the thread exit event. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>true if unregistration is successful and false if it is not (e.g., <code>func</code> was not registered). </dd></dl>

</div>
</div>
<a class="anchor" id="ga835120bfe4726d59d13f8fbcd01fb264"></a><!-- doxytag: member="drmgr.h::drmgr_unregister_thread_init_event" ref="ga835120bfe4726d59d13f8fbcd01fb264" args="(void(*func)(void *drcontext))" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DR_EXPORT bool drmgr_unregister_thread_init_event </td>
          <td>(</td>
          <td class="paramtype">void(*)(void *drcontext)&nbsp;</td>
          <td class="paramname"> <em>func</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Unregister a callback function for the thread initialization event. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>true if unregistration is successful and false if it is not (e.g., <code>func</code> was not registered). </dd></dl>

</div>
</div>
<a class="anchor" id="ga0389d904f0e656f8a8777d850e6187f3"></a><!-- doxytag: member="drmgr.h::drmgr_unregister_tls_field" ref="ga0389d904f0e656f8a8777d850e6187f3" args="(int idx)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DR_EXPORT bool drmgr_unregister_tls_field </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>idx</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Frees a previously reserved thread-local storage (tls) slot index. Returns false if the slot was not actually reserved. </p>

</div>
</div>
</div>
<hr size="1"><address style="text-align: center;"><small>
<img border=0 src="favicon.png"> &nbsp; DynamoRIO API version 3.2.0 --- Wed Mar 28 12:55:33 2012 
&nbsp; <img border=0 src="favicon.png">
</body>
</html>
